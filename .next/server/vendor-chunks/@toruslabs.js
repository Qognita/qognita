"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toruslabs";
exports.ids = ["vendor-chunks/@toruslabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACCOUNT_CATEGORY: () => (/* binding */ ACCOUNT_CATEGORY),\n/* harmony export */   ACTIVITY_ACTION: () => (/* binding */ ACTIVITY_ACTION),\n/* harmony export */   ACTIVITY_ACTION_ACCEPT_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_ACCEPT_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_ALL: () => (/* binding */ ACTIVITY_ACTION_ALL),\n/* harmony export */   ACTIVITY_ACTION_BURN: () => (/* binding */ ACTIVITY_ACTION_BURN),\n/* harmony export */   ACTIVITY_ACTION_CANCEL_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_CANCEL_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_CREATE_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_CREATE_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_CREATE_TRUSTLINE: () => (/* binding */ ACTIVITY_ACTION_CREATE_TRUSTLINE),\n/* harmony export */   ACTIVITY_ACTION_RECEIVE: () => (/* binding */ ACTIVITY_ACTION_RECEIVE),\n/* harmony export */   ACTIVITY_ACTION_REMOVE_TRUSTLINE: () => (/* binding */ ACTIVITY_ACTION_REMOVE_TRUSTLINE),\n/* harmony export */   ACTIVITY_ACTION_SEND: () => (/* binding */ ACTIVITY_ACTION_SEND),\n/* harmony export */   ACTIVITY_ACTION_TOPUP: () => (/* binding */ ACTIVITY_ACTION_TOPUP),\n/* harmony export */   ACTIVITY_PERIOD_ALL: () => (/* binding */ ACTIVITY_PERIOD_ALL),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_ONE: () => (/* binding */ ACTIVITY_PERIOD_MONTH_ONE),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_SIX: () => (/* binding */ ACTIVITY_PERIOD_MONTH_SIX),\n/* harmony export */   ACTIVITY_PERIOD_WEEK_ONE: () => (/* binding */ ACTIVITY_PERIOD_WEEK_ONE),\n/* harmony export */   ACTIVITY_STATUS_CANCELLED: () => (/* binding */ ACTIVITY_STATUS_CANCELLED),\n/* harmony export */   ACTIVITY_STATUS_CANCELLING: () => (/* binding */ ACTIVITY_STATUS_CANCELLING),\n/* harmony export */   ACTIVITY_STATUS_PENDING: () => (/* binding */ ACTIVITY_STATUS_PENDING),\n/* harmony export */   ACTIVITY_STATUS_SUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_SUCCESSFUL),\n/* harmony export */   ACTIVITY_STATUS_UNSUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_UNSUCCESSFUL),\n/* harmony export */   BROADCAST_CHANNELS: () => (/* binding */ BROADCAST_CHANNELS),\n/* harmony export */   BROADCAST_CHANNELS_MSGS: () => (/* binding */ BROADCAST_CHANNELS_MSGS),\n/* harmony export */   BUTTON_POSITION: () => (/* binding */ BUTTON_POSITION),\n/* harmony export */   BaseBlockTracker: () => (/* binding */ BaseBlockTracker),\n/* harmony export */   BaseController: () => (/* binding */ BaseController),\n/* harmony export */   BaseCurrencyController: () => (/* binding */ BaseCurrencyController),\n/* harmony export */   BaseEmbedController: () => (/* binding */ BaseEmbedController),\n/* harmony export */   BaseKeyringController: () => (/* binding */ BaseKeyringController),\n/* harmony export */   BasePreferencesController: () => (/* binding */ BasePreferencesController),\n/* harmony export */   BaseTransactionStateManager: () => (/* binding */ BaseTransactionStateManager),\n/* harmony export */   BroadcastChannelHandler: () => (/* binding */ BroadcastChannelHandler),\n/* harmony export */   CHAIN_NAMESPACES: () => (/* binding */ CHAIN_NAMESPACES),\n/* harmony export */   COMMUNICATION_JRPC_METHODS: () => (/* binding */ COMMUNICATION_JRPC_METHODS),\n/* harmony export */   COMMUNICATION_NOTIFICATIONS: () => (/* binding */ COMMUNICATION_NOTIFICATIONS),\n/* harmony export */   CONFIRMATION_STRATEGY: () => (/* binding */ CONFIRMATION_STRATEGY),\n/* harmony export */   CommunicationWindowManager: () => (/* binding */ CommunicationWindowManager),\n/* harmony export */   ControllerEvents: () => (/* binding */ ControllerEvents),\n/* harmony export */   DEFAULT_PREFERENCES: () => (/* binding */ DEFAULT_PREFERENCES),\n/* harmony export */   FEATURES_CONFIRM_WINDOW: () => (/* binding */ FEATURES_CONFIRM_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_POPUP_WINDOW: () => (/* binding */ FEATURES_DEFAULT_POPUP_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_WALLET_WINDOW: () => (/* binding */ FEATURES_DEFAULT_WALLET_WINDOW),\n/* harmony export */   FEATURES_PROVIDER_CHANGE_WINDOW: () => (/* binding */ FEATURES_PROVIDER_CHANGE_WINDOW),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   POPUP_LOADED: () => (/* binding */ POPUP_LOADED),\n/* harmony export */   POPUP_RESULT: () => (/* binding */ POPUP_RESULT),\n/* harmony export */   PROVIDER_JRPC_METHODS: () => (/* binding */ PROVIDER_JRPC_METHODS),\n/* harmony export */   PROVIDER_NOTIFICATIONS: () => (/* binding */ PROVIDER_NOTIFICATIONS),\n/* harmony export */   PopupHandler: () => (/* binding */ PopupHandler),\n/* harmony export */   PopupStoreChannel: () => (/* binding */ PopupStoreChannel),\n/* harmony export */   PopupWithBcHandler: () => (/* binding */ PopupWithBcHandler),\n/* harmony export */   RedirectHandler: () => (/* binding */ RedirectHandler),\n/* harmony export */   SETUP_COMPLETE: () => (/* binding */ SETUP_COMPLETE),\n/* harmony export */   StreamWindow: () => (/* binding */ StreamWindow),\n/* harmony export */   TRANSACTION_TYPES: () => (/* binding */ TRANSACTION_TYPES),\n/* harmony export */   TX_EVENTS: () => (/* binding */ TX_EVENTS),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   UserError: () => (/* binding */ UserError),\n/* harmony export */   WSApiClient: () => (/* binding */ WSApiClient),\n/* harmony export */   addressSlicer: () => (/* binding */ addressSlicer),\n/* harmony export */   authServer: () => (/* binding */ authServer),\n/* harmony export */   broadcastChannelOptions: () => (/* binding */ broadcastChannelOptions),\n/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep),\n/* harmony export */   concatSig: () => (/* binding */ concatSig),\n/* harmony export */   createChangeProviderMiddlewareMiddleware: () => (/* binding */ createChangeProviderMiddlewareMiddleware),\n/* harmony export */   createCommunicationMiddleware: () => (/* binding */ createCommunicationMiddleware),\n/* harmony export */   createEventEmitterProxy: () => (/* binding */ createEventEmitterProxy),\n/* harmony export */   createFetchConfigFromReq: () => (/* binding */ createFetchConfigFromReq),\n/* harmony export */   createFetchMiddleware: () => (/* binding */ createFetchMiddleware),\n/* harmony export */   createGenericJRPCMiddleware: () => (/* binding */ createGenericJRPCMiddleware),\n/* harmony export */   createInflightCacheMiddleware: () => (/* binding */ createInflightCacheMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createOriginMiddleware: () => (/* binding */ createOriginMiddleware),\n/* harmony export */   createRandomId: () => (/* binding */ createRandomId),\n/* harmony export */   createSwappableProxy: () => (/* binding */ createSwappableProxy),\n/* harmony export */   createTopupMiddleware: () => (/* binding */ createTopupMiddleware),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatSmallNumbers: () => (/* binding */ formatSmallNumbers),\n/* harmony export */   formatTime: () => (/* binding */ formatTime),\n/* harmony export */   getCustomDeviceInfo: () => (/* binding */ getCustomDeviceInfo),\n/* harmony export */   getHeaders: () => (/* binding */ getHeaders),\n/* harmony export */   getPopupFeatures: () => (/* binding */ getPopupFeatures),\n/* harmony export */   getTxStatusText: () => (/* binding */ getTxStatusText),\n/* harmony export */   handleRedirectParameters: () => (/* binding */ handleRedirectParameters),\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage),\n/* harmony export */   intToHex: () => (/* binding */ intToHex),\n/* harmony export */   isUnauthorizedError: () => (/* binding */ isUnauthorizedError),\n/* harmony export */   omitBy: () => (/* binding */ omitBy),\n/* harmony export */   padWithZeroes: () => (/* binding */ padWithZeroes),\n/* harmony export */   pickBy: () => (/* binding */ pickBy),\n/* harmony export */   randomId: () => (/* binding */ randomId),\n/* harmony export */   signChallenge: () => (/* binding */ signChallenge),\n/* harmony export */   signMessage: () => (/* binding */ signMessage),\n/* harmony export */   significantDigits: () => (/* binding */ significantDigits),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeout: () => (/* binding */ timeout$1),\n/* harmony export */   transactionMatchesNetwork: () => (/* binding */ transactionMatchesNetwork),\n/* harmony export */   verifySignedChallenge: () => (/* binding */ verifySignedChallenge)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/esm/index.js\");\n/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/openlogin-utils */ \"(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @toruslabs/broadcast-channel */ \"(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bowser */ \"(ssr)/./node_modules/bowser/src/bowser.js\");\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jwt-decode */ \"(ssr)/./node_modules/jwt-decode/build/esm/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */ class BaseController extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.SafeEventEmitter {\n    /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor({ config = {}, state = {} }){\n        super();\n        // Use assign since generics can't be spread: https://git.io/vpRhY\n        /**\n     * Default options used to configure this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultConfig\", {});\n        /**\n     * Default state set on this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultState\", {});\n        /**\n     * Determines if listeners are notified of state changes\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"disabled\", false);\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"BaseController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialConfig\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialState\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalConfig\", this.defaultConfig);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalState\", this.defaultState);\n        this.initialState = state;\n        this.initialConfig = config;\n    }\n    /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */ get config() {\n        return this.internalConfig;\n    }\n    /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */ get state() {\n        return this.internalState;\n    }\n    /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */ configure(config, overwrite = false, fullUpdate = true) {\n        if (fullUpdate) {\n            this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n            for(const key in this.internalConfig){\n                if (typeof this.internalConfig[key] !== \"undefined\") {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this[key] = this.internalConfig[key];\n                }\n            }\n        } else {\n            for(const key in config){\n                /* istanbul ignore else */ if (typeof this.internalConfig[key] !== \"undefined\") {\n                    this.internalConfig[key] = config[key];\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n    /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */ update(state, overwrite = false) {\n        this.internalState = overwrite ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, state) : _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.internalState), state);\n        this.emit(\"store\", this.internalState);\n    }\n    /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */ initialize() {\n        this.internalState = this.defaultState;\n        this.internalConfig = this.defaultConfig;\n        this.configure(this.initialConfig);\n        this.update(this.initialState);\n        return this;\n    }\n}\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue)=>accumulator + currentValue;\nconst blockTrackerEvents = [\n    \"sync\",\n    \"latest\"\n];\nclass BaseBlockTracker extends BaseController {\n    constructor({ config = {}, state = {} }){\n        super({\n            config,\n            state\n        });\n        // config\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"BaseBlockTracker\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_blockResetTimeout\", void 0);\n        this.defaultState = {\n            _currentBlock: {\n                idempotencyKey: \"\"\n            },\n            _isRunning: false\n        };\n        this.defaultConfig = {\n            blockResetDuration: 20 * sec\n        };\n        this.initialize();\n        // bind functions for internal use\n        this._onNewListener = this._onNewListener.bind(this);\n        this._onRemoveListener = this._onRemoveListener.bind(this);\n        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        this._setupInternalEvents();\n    }\n    isRunning() {\n        return this.state._isRunning;\n    }\n    getCurrentBlock() {\n        return this.state._currentBlock;\n    }\n    async getLatestBlock() {\n        // return if available\n        if (this.state._currentBlock.idempotencyKey) {\n            return this.state._currentBlock;\n        }\n        // wait for a new latest block\n        const latestBlock = await new Promise((resolve)=>{\n            this.once(\"latest\", (block)=>{\n                if (block) {\n                    resolve(block);\n                }\n            });\n        });\n        // return newly set current block\n        return latestBlock;\n    }\n    // dont allow module consumer to remove our internal event listeners\n    removeAllListeners(eventName) {\n        if (eventName) {\n            super.removeAllListeners(eventName);\n        } else {\n            super.removeAllListeners();\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener();\n        return this;\n    }\n    /**\n   * To be implemented in subclass.\n   */ _start() {\n    // default behavior is noop\n    }\n    /**\n   * To be implemented in subclass.\n   */ _end() {\n    // default behavior is noop\n    }\n    _newPotentialLatest(newBlock) {\n        const currentBlock = this.state._currentBlock;\n        // only update if block number is higher\n        if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    }\n    _setupInternalEvents() {\n        // first remove listeners for idempotency\n        this.removeListener(\"newListener\", this._onNewListener);\n        this.removeListener(\"removeListener\", this._onRemoveListener);\n        // then add them\n        this.on(\"removeListener\", this._onRemoveListener);\n        this.on(\"newListener\", this._onNewListener);\n    }\n    _onNewListener() {\n        this._maybeStart();\n    }\n    _onRemoveListener() {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    }\n    _maybeStart() {\n        if (this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        this._start();\n    }\n    _maybeEnd() {\n        if (!this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = false;\n        this._setupBlockResetTimeout();\n        this._end();\n    }\n    _getBlockTrackerEventCount() {\n        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);\n    }\n    _setCurrentBlock(newBlock) {\n        const oldBlock = this.state._currentBlock;\n        this.update({\n            _currentBlock: newBlock\n        });\n        this.emit(\"latest\", newBlock);\n        this.emit(\"sync\", {\n            oldBlock,\n            newBlock\n        });\n    }\n    _setupBlockResetTimeout() {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    }\n    _cancelBlockResetTimeout() {\n        if (this._blockResetTimeout) {\n            clearTimeout(this._blockResetTimeout);\n        }\n    }\n    _resetCurrentBlock() {\n        this.update({\n            _currentBlock: {\n                idempotencyKey: \"\"\n            }\n        });\n    }\n}\nconst filterNoop = ()=>true;\nconst internalEvents = [\n    \"newListener\",\n    \"removeListener\"\n];\nconst externalEventFilter = (name)=>!internalEvents.includes(name);\nfunction getRawListeners(eventEmitter, name) {\n    // prefer native\n    return typeof eventEmitter.rawListeners !== \"undefined\" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);\n}\nfunction createEventEmitterProxy(initialTarget, opts) {\n    // parse options\n    const finalOpts = opts || {};\n    let eventFilter = finalOpts.eventFilter || filterNoop;\n    if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n    if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        const oldTarget = target;\n        target = newTarget;\n        oldTarget.eventNames().filter(eventFilter).forEach((name)=>{\n            getRawListeners(oldTarget, name).forEach((handler)=>{\n                newTarget.on(name, handler);\n            });\n        });\n        // remove old listeners\n        oldTarget.removeAllListeners();\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\nfunction createSwappableProxy(initialTarget) {\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        target = newTarget;\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\n// every ten minutes\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n    constructor({ config = {}, state }){\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            currentCurrency: \"usd\",\n            conversionRate: 0,\n            conversionDate: \"N/A\",\n            nativeCurrency: \"ETH\"\n        };\n        this.defaultConfig = {\n            pollInterval: POLLING_INTERVAL\n        };\n        this.initialize();\n    }\n    //\n    // PUBLIC METHODS\n    //\n    getNativeCurrency() {\n        return this.state.nativeCurrency;\n    }\n    setNativeCurrency(nativeCurrency) {\n        this.update({\n            nativeCurrency,\n            ticker: nativeCurrency\n        });\n    }\n    getCurrentCurrency() {\n        return this.state.currentCurrency;\n    }\n    setCurrentCurrency(currentCurrency) {\n        this.update({\n            currentCurrency\n        });\n    }\n    /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */ getConversionRate() {\n        return this.state.conversionRate;\n    }\n    setConversionRate(conversionRate) {\n        this.update({\n            conversionRate\n        });\n    }\n    /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */ getConversionDate() {\n        return this.state.conversionDate;\n    }\n    setConversionDate(conversionDate) {\n        this.update({\n            conversionDate\n        });\n    }\n}\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 700,\n    width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_ACTION_CREATE_TRUSTLINE = \"walletActivity.createTrustline\";\nconst ACTIVITY_ACTION_REMOVE_TRUSTLINE = \"walletActivity.removeTrustline\";\nconst ACTIVITY_ACTION_CREATE_NFT_OFFER = \"walletActivity.createNftOffer\";\nconst ACTIVITY_ACTION_ACCEPT_NFT_OFFER = \"walletActivity.acceptNftOffer\";\nconst ACTIVITY_ACTION_CANCEL_NFT_OFFER = \"walletActivity.cancelNftOffer\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n    IFRAME_STATUS: \"iframe_status\",\n    // Tell embed to close the window\n    CLOSE_WINDOW: \"close_window\",\n    USER_LOGGED_IN: \"user_logged_in\",\n    USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n    LOGOUT: \"logout\",\n    WALLET_INSTANCE_ID: \"wallet_instance_id\",\n    USER_INFO: \"user_info\",\n    SET_PROVIDER: \"set_provider\",\n    TOPUP: \"topup\",\n    IFRAME_STATUS: \"iframe_status\",\n    // user has closed the window from embed's side\n    CLOSED_WINDOW: \"closed_window\",\n    WINDOW_BLOCKED: \"window_blocked\",\n    GET_PROVIDER_STATE: \"get_provider_state\",\n    LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\",\n    SHOW_WALLET_CONNECT: \"show_wallet_connect\",\n    SHOW_CHECKOUT: \"show_checkout\",\n    SHOW_WALLET_UI: \"show_wallet_ui\",\n    LOGIN_WITH_SESSION_ID: \"login_with_session_id\"\n};\nconst PROVIDER_JRPC_METHODS = {\n    GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n    ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n    CHAIN_CHANGED: \"wallet_chain_changed\",\n    UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n    REDIRECT_CHANNEL: \"redirect_channel\",\n    PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n    TRANSACTION_CHANNEL: \"torus_channel\",\n    MESSAGE_CHANNEL: \"torus_message_channel\",\n    WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n    WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n    WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n    WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n    THEME_CHANGE: \"theme_change_channel\",\n    TOP_UP_CHANNEL: \"top_up_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n    LOGOUT: \"logout\",\n    ACCOUNT_IMPORTED: \"account_imported\",\n    SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n    NETWORK_CHANGE: \"network_change\",\n    SET_THEME: \"set_theme\"\n};\nlet ControllerEvents = /*#__PURE__*/ function(ControllerEvents) {\n    ControllerEvents[\"UserUnauthorized\"] = \"user.unauthorized\";\n    return ControllerEvents;\n}({});\nfunction createChangeProviderMiddlewareMiddleware({ changeProvider }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n        if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n        response.result = await changeProvider(request);\n    });\n}\nfunction createTopupMiddleware({ topup }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n        if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n        response.result = await topup(request);\n    });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== targetMethod) return next();\n        if (!handler) throw new Error(`CommunicationMiddleware - ${targetMethod} not provided`);\n        const result = await handler(request);\n        if (!result) {\n            return next();\n        }\n        response.result = result;\n        return undefined;\n    });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n    const { getUserInfo, getWalletInstanceId, topup, logout, changeProvider, setIFrameStatus, handleWindowRpc, getProviderState, loginWithPrivateKey, showWalletConnect, showCheckout, showWalletUi, showWindowBlockAlert, loginWithSessionId } = providerHandlers;\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.mergeMiddleware)([\n        createChangeProviderMiddlewareMiddleware({\n            changeProvider\n        }),\n        createTopupMiddleware({\n            topup\n        }),\n        (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createScaffoldMiddleware)({\n            [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n            [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n            [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n            [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n            // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n            [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n            [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState,\n            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT]: showWalletConnect,\n            [COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT]: showCheckout,\n            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI]: showWalletUi,\n            [COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED]: showWindowBlockAlert\n        }),\n        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey),\n        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID, loginWithSessionId)\n    ]);\n}\nclass BaseEmbedController extends BaseController {\n    constructor({ config = {}, state }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_communicationProviderProxy\", void 0);\n        this.defaultState = {\n            isIFrameFullScreen: true,\n            oauthModalVisibility: false,\n            loginInProgress: false,\n            dappMetadata: {\n                name: \"\",\n                icon: \"\"\n            },\n            web3AuthClientId: \"\",\n            web3AuthNetwork: \"mainnet\",\n            whiteLabel: null,\n            confirmationStrategy: \"popup\"\n        };\n        this.initialize();\n    }\n    /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */ initializeProvider(handlers) {\n        const engine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.JRPCEngine();\n        const communicationMiddleware = createCommunicationMiddleware(handlers);\n        engine.push(communicationMiddleware);\n        const communicationProvider = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.providerFromEngine)(engine);\n        this.setCommunicationProvider(communicationProvider);\n    }\n    setCommunicationProvider(communicationProvider) {\n        if (this._communicationProviderProxy) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this._communicationProviderProxy.setTarget(communicationProvider);\n        } else {\n            this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n        }\n    }\n}\nclass CommunicationWindowManager extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.SafeEventEmitter {\n    constructor(...args){\n        super(...args);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleWindowRpc\", (request, response, next, end)=>{\n            const { method, params } = request;\n            if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n                const { windowId } = params;\n                // I've been informed that a window has been closed\n                this.emit(`${windowId}:closed`);\n                response.result = true;\n                end();\n            } else {\n                next();\n            }\n        });\n    }\n}\nconst BUTTON_POSITION = {\n    BOTTOM_LEFT: \"bottom-left\",\n    TOP_LEFT: \"top-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    TOP_RIGHT: \"top-right\"\n};\nconst CONFIRMATION_STRATEGY = {\n    POPUP: \"popup\",\n    MODAL: \"modal\",\n    AUTO_APPROVE: \"auto-approve\",\n    DEFAULT: \"default\"\n};\n/**\n * State change callbacks\n */ /**\n * Base controller configuration\n */ /**\n * Base state representation\n */ const LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\",\n    SMS_PASSWORDLESS: \"sms_passwordless\"\n};\n/**\n * {@label loginProviderType}\n */ const PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nfunction omitBy(object, predicate) {\n    // Create a new object to store the results\n    const result = {};\n    // Iterate over all own properties of the object\n    for (const [key, value] of Object.entries(object)){\n        if (!predicate(value, key)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nfunction pickBy(object, predicate) {\n    // Create a new object to store the results\n    const result = {};\n    for (const [key, value] of Object.entries(object)){\n        if (predicate(value, key)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nfunction cloneDeep(object) {\n    try {\n        return structuredClone(object);\n    } catch (error) {\n        return JSON.parse(JSON.stringify(object));\n    }\n}\nconst authServer = \"https://authjs.web3auth.io\";\nconst signChallenge = async (payload, chainNamespace)=>{\n    const t = chainNamespace === \"solana\" ? \"sip99\" : \"eip191\";\n    const header = {\n        t\n    };\n    const network = chainNamespace === \"solana\" ? \"solana\" : \"ethereum\";\n    const data = {\n        payload,\n        header,\n        network\n    };\n    const res = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${authServer}/siww/get`, data);\n    if (!res.success) {\n        throw new Error(\"Failed to authenticate user, Please reach out to Web3Auth Support team\");\n    }\n    return res.challenge;\n};\nconst verifySignedChallenge = async (chainNamespace, signedMessage, challenge, issuer, sessionTime, clientId, web3AuthNetwork, audience, additionalMetadata)=>{\n    var _window$location;\n    const t = chainNamespace === \"solana\" ? \"sip99\" : \"eip191\";\n    const sigData = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n        signature: {\n            s: signedMessage,\n            t\n        },\n        message: challenge,\n        issuer,\n        audience: audience || ( false ? 0 : \"com://reactnative\"),\n        timeout: sessionTime\n    }, additionalMetadata || {});\n    const idTokenRes = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${authServer}/siww/verify`, sigData, {\n        headers: {\n            client_id: clientId,\n            wallet_provider: issuer,\n            web3auth_network: web3AuthNetwork\n        }\n    });\n    if (!idTokenRes.success) {\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"Failed to authenticate user, ,message verification failed\", idTokenRes.error);\n        throw new Error(\"Failed to authenticate user, ,message verification failed\");\n    }\n    return idTokenRes.token;\n};\nconst getTxStatusText = (txStatus)=>{\n    switch(txStatus){\n        case \"rejected\":\n        case \"unapproved\":\n        case \"failed\":\n            return ACTIVITY_STATUS_UNSUCCESSFUL;\n        case \"confirmed\":\n            return ACTIVITY_STATUS_SUCCESSFUL;\n        case \"submitted\":\n            return ACTIVITY_STATUS_PENDING;\n        case \"cancelled\":\n            return ACTIVITY_STATUS_CANCELLED;\n        default:\n            return \"\";\n    }\n};\n/**\n * General utility functions\n */ function intToHex(i) {\n    const hex = i.toString(16);\n    return `0x${hex}`;\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */ const randomId = ()=>Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */ function padWithZeroes(hexString, targetLength) {\n    if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */ function concatSig(v, r, s) {\n    const rSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.fromSigned)(r);\n    const sSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.fromSigned)(s);\n    const vSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt)(v);\n    const rStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.toUnsigned)(rSig)).toString(\"hex\"), 64);\n    const sStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.toUnsigned)(sSig)).toString(\"hex\"), 64);\n    const vStr = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.stripHexPrefix)((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bigIntToHex)(vSig));\n    return (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.addHexPrefix)(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n    return new Promise((resolve)=>{\n        const timeoutRef = window.setTimeout(()=>{\n            resolve();\n            window.clearTimeout(timeoutRef);\n        }, duration);\n    });\n}\nconst getHeaders = (jwt, publicAddress)=>{\n    return {\n        headers: {\n            Authorization: `Bearer ${jwt}`,\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"public-address\": publicAddress\n        }\n    };\n};\n/**\n * Text/number formatting utilities\n */ const formatSmallNumbers = (number, currency = \"usd\", noTilde = false)=>{\n    const finalNumber = bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isBigNumber(number) ? number.toNumber() : number;\n    if (!Number.isFinite(finalNumber)) return \"\";\n    const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n    const tilde = value > 0 ? \"~ \" : \"\";\n    return `${currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde}${Number(value)} ${currency.toUpperCase()}`;\n};\nconst addressSlicer = (address, sliceLength = 5)=>{\n    if (!address) return \"\";\n    if (address.length < 11) {\n        return address;\n    }\n    if (typeof address !== \"string\") return \"\";\n    return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;\n};\nconst significantDigits = (number, perc = false, length_ = 2)=>{\n    let input = !bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isBigNumber(number) ? new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](number) : number;\n    if (input.isZero()) return input;\n    if (perc) {\n        input = input.times(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](100));\n    }\n    let depth;\n    if (input.gte(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](1))) {\n        depth = length_;\n    } else {\n        depth = length_ - 1 + Math.ceil(Math.log10(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](\"1\").div(input).toNumber()));\n    }\n    const shift = new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](10).pow(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](depth));\n    const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n    return roundedNumber;\n};\nconst formatDate = (inputDate)=>{\n    const monthList = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ];\n    const date = new Date(inputDate);\n    const day = date.getDate();\n    const month = monthList[date.getMonth()];\n    const year = date.getFullYear();\n    return `${day} ${month} ${year}`;\n};\nconst formatTime = (time)=>{\n    return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */ const transactionMatchesNetwork = (transaction, chainId)=>{\n    if (typeof transaction.chainId !== \"undefined\") {\n        return transaction.chainId === chainId;\n    }\n    return false;\n};\n/**\n * Signing utils\n */ const hashMessage = (message)=>{\n    const bufferedMessage = Buffer.from(message, \"utf8\");\n    const el = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.hashPersonalMessage)(bufferedMessage);\n    return Buffer.from(el);\n};\nconst signMessage = async (privateKey, data)=>{\n    const privKey = Buffer.from(privateKey, \"hex\");\n    const message = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.stripHexPrefix)(data);\n    const msgSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.ecsign)(Buffer.from(message, \"hex\"), privKey);\n    const rawMsgSig = concatSig(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bigIntToBytes)(msgSig.v)), Buffer.from(msgSig.r), Buffer.from(msgSig.s));\n    return rawMsgSig;\n};\n/**\n * popup handler utils\n */ function getPopupFeatures({ width: w, height: h }) {\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nconst broadcastChannelOptions = {\n    type: \"server\",\n    // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n    webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n};\nfunction getCustomDeviceInfo() {\n    var _navigator;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n        return {\n            browser: \"Brave\"\n        };\n    }\n}\nclass UserError extends Error {\n}\nconst handleRedirectParameters = (hash, queryParameters)=>{\n    const hashParameters = {};\n    const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);\n    hashUrl.searchParams.forEach((value, key)=>{\n        hashParameters[key] = value;\n    });\n    let instanceParameters = {};\n    let error = \"\";\n    if (!queryParameters.windowId) {\n        if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n            instanceParameters = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n            error = hashParameters.error_description || hashParameters.error || error;\n        } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n            instanceParameters = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n            if (queryParameters.error) error = queryParameters.error;\n        }\n    }\n    return {\n        error,\n        instanceParameters,\n        hashParameters\n    };\n};\nfunction sleep(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n}\nconst isUnauthorizedError = (error)=>{\n    return error instanceof Response && error.status === 401;\n};\nclass BaseKeyringController extends BaseController {\n    constructor({ config = {}, state }){\n        var _state$wallets;\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n        };\n        this.initialize();\n    }\n    // for signing auth message\n    async signAuthMessage(address, message) {\n        const keyring = this.state.wallets.find((x)=>x.address === address);\n        if (!keyring) {\n            throw new Error(\"key does not exist\");\n        }\n        const hashedMessage = hashMessage(message).toString(\"hex\");\n        const rawMessageSig = await signMessage(keyring.privateKey, hashedMessage);\n        return rawMessageSig;\n    }\n}\nconst RETRIABLE_ERRORS = [\n    // ignore server overload errors\n    \"Gateway timeout\",\n    \"ETIMEDOUT\",\n    // ignore server sent html error pages\n    // or truncated json responses\n    \"failed to parse response body\",\n    // ignore errors where http req failed to establish\n    \"Failed to fetch\"\n];\nfunction checkForHttpErrors(fetchRes) {\n    // check for errors\n    switch(fetchRes.status){\n        case 405:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.methodNotFound();\n        case 418:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n                message: `Request is being rate limited.`,\n                data: {\n                    cause: fetchRes\n                }\n            });\n        case 503:\n        case 504:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n                message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`\n            });\n    }\n}\nfunction timeout(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction parseResponse(fetchRes, body) {\n    // check for error code\n    if (fetchRes.status !== 200) {\n        throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n            message: `Non-200 status code: '${fetchRes.status}'`,\n            data: body\n        });\n    }\n    // check for rpc error\n    if (body.error) {\n        throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n            data: body.error\n        });\n    }\n    // return successful result\n    return body.result;\n}\nfunction createFetchConfigFromReq({ req, rpcTarget, originHttpHeaderKey }) {\n    const parsedUrl = new URL(rpcTarget);\n    // prepare payload\n    // copy only canonical json rpc properties\n    const payload = {\n        id: req.id,\n        jsonrpc: req.jsonrpc,\n        method: req.method,\n        params: req.params\n    };\n    // extract 'origin' parameter from request\n    const originDomain = req.origin;\n    // serialize request body\n    const serializedPayload = JSON.stringify(payload);\n    // configure fetch params\n    const fetchParams = {\n        method: \"POST\",\n        headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\"\n        },\n        body: serializedPayload\n    };\n    // optional: add request origin as header\n    if (originHttpHeaderKey && originDomain) {\n        fetchParams.headers[originHttpHeaderKey] = originDomain;\n    }\n    return {\n        fetchUrl: parsedUrl.href,\n        fetchParams\n    };\n}\nfunction createFetchMiddleware({ rpcTarget, originHttpHeaderKey }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (req, res, _next)=>{\n        const { fetchUrl, fetchParams } = createFetchConfigFromReq({\n            req,\n            rpcTarget,\n            originHttpHeaderKey\n        });\n        // attempt request multiple times\n        const maxAttempts = 5;\n        const retryInterval = 1000;\n        for(let attempt = 0; attempt < maxAttempts; attempt++){\n            try {\n                const fetchRes = await fetch(fetchUrl, fetchParams);\n                // check for http errrors\n                checkForHttpErrors(fetchRes);\n                // parse response body\n                const fetchBody = await fetchRes.json();\n                const result = parseResponse(fetchRes, fetchBody);\n                // set result and exit retry loop\n                res.result = result;\n                return;\n            } catch (err) {\n                const errMsg = (err.message || err).toString();\n                const isRetriable = RETRIABLE_ERRORS.some((phrase)=>errMsg.includes(phrase));\n                // re-throw error if not retriable\n                if (!isRetriable) {\n                    throw err;\n                }\n            }\n            // delay before retrying\n            await timeout(retryInterval);\n        }\n    });\n}\nfunction deferredPromise() {\n    let resolve;\n    const promise = new Promise((_resolve)=>{\n        resolve = _resolve;\n    });\n    return {\n        resolve,\n        promise\n    };\n}\nfunction createInflightCacheMiddleware({ cacheIdentifierForRequest }) {\n    const inflightRequests = {};\n    async function createActiveRequestHandler(res, activeRequestHandlers) {\n        const { resolve, promise } = deferredPromise();\n        activeRequestHandlers.push((handledRes)=>{\n            // append a copy of the result and error to the response\n            res.result = cloneDeep(handledRes.result);\n            res.error = cloneDeep(handledRes.error);\n            resolve();\n        });\n        return promise;\n    }\n    function handleActiveRequest(res, activeRequestHandlers) {\n        // use setTimeout so we can resolve our original request first\n        setTimeout(()=>{\n            activeRequestHandlers.forEach((handler)=>{\n                try {\n                    handler(res);\n                } catch (err) {\n                    // catch error so all requests are handled correctly\n                    loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err);\n                }\n            });\n        });\n    }\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (req, res, next)=>{\n        // allow cach to be skipped if so specified\n        if (req.skipCache) {\n            return next();\n        }\n        // get cacheId, if cacheable\n        const cacheId = cacheIdentifierForRequest(req);\n        // if not cacheable, skip\n        if (!cacheId) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Request is not cacheable, proceeding. req = %o\", req);\n            return next();\n        }\n        // check for matching requests\n        let activeRequestHandlers = inflightRequests[cacheId];\n        // if found, wait for the active request to be handled\n        if (activeRequestHandlers) {\n            // setup the response listener and wait for it to be called\n            // it will handle copying the result and request fields\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Running %i handler(s) for request %o\", activeRequestHandlers.length, req);\n            await createActiveRequestHandler(res, activeRequestHandlers);\n            return undefined;\n        }\n        // setup response handler array for subsequent requests\n        activeRequestHandlers = [];\n        inflightRequests[cacheId] = activeRequestHandlers;\n        // allow request to be handled normally\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Carrying original request forward %o\", req);\n        await next();\n        // clear inflight requests\n        delete inflightRequests[cacheId];\n        // schedule activeRequestHandlers to be handled\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Running %i collected handler(s) for request %o\", activeRequestHandlers.length, req);\n        handleActiveRequest(res, activeRequestHandlers);\n        // complete\n        return undefined;\n    });\n}\nfunction createLoggerMiddleware(options) {\n    return function loggerMiddleware(request, response, next) {\n        next((callback)=>{\n            if (response.error) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().warn(\"Error in RPC response:\\n\", response);\n            }\n            if (request.isTorusInternal) return;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`RPC (${options.origin}):`, request, \"->\", response);\n            callback();\n        });\n    };\n}\nfunction createOriginMiddleware(options) {\n    return function originMiddleware(request, _, next) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        request.origin = options.origin;\n        next();\n    };\n}\nconst createRandomId = ()=>Math.random().toString(36).substring(2);\nconst CHAIN_NAMESPACES = {\n    EIP155: \"eip155\",\n    SOLANA: \"solana\",\n    CASPER: \"casper\",\n    XRPL: \"xrpl\",\n    OTHER: \"other\"\n};\n// eip155 for all evm chains\n/**\n * Custom network properties\n * @example isEIP1559Compatible: true etc.\n */ /**\n *\n */ class BroadcastChannelHandler {\n    constructor(channelPrefix, instanceId){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"bc\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"channel\", void 0);\n        const queryParameters = new URLSearchParams(window.location.search);\n        const windowId = queryParameters.get(\"windowId\");\n        this.channel = `${channelPrefix}_${instanceId}_${windowId}`;\n        this.bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(this.channel, broadcastChannelOptions);\n    }\n    getMessageFromChannel() {\n        return new Promise((resolve, reject)=>{\n            this.bc.addEventListener(\"message\", async (ev)=>{\n                this.bc.close();\n                if (ev.error) {\n                    reject(ev.error);\n                } else {\n                    resolve(ev.data);\n                }\n            });\n            this.bc.postMessage({\n                data: {\n                    type: POPUP_LOADED\n                }\n            });\n        });\n    }\n}\nclass StreamWindow extends BaseController {\n    constructor({ config, state = {} }){\n        super({\n            config,\n            state\n        });\n        // if window has been closed by users\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"closed\", false);\n        this.initialize();\n    }\n    async open() {\n        return new Promise((resolve, reject)=>{\n            const { communicationEngine, communicationWindowManager } = this.config;\n            let popupSuccess = false;\n            communicationWindowManager.once(`${this.state.windowId}:closed`, ()=>{\n                this.closed = true;\n            });\n            // Window is not open yet\n            if (!this.state.windowId) {\n                // since, we're opening window now, no need to tell window anything\n                this.update({\n                    windowId: randomId()\n                });\n                if (typeof this.config.handleWindowBlockAlert !== \"function\") reject(new Error(\"handleWindowBlockAlert is not a function\"));\n                communicationWindowManager.once(`${this.state.windowId}:iframe-opened`, ()=>{\n                    // this means iframe is full screen now\n                    // there might be multiple block alerts at a time. so, we don't set iframe to close after handling this here\n                    this.config.handleWindowBlockAlert({\n                        windowId: this.state.windowId,\n                        finalUrl: this.state.url.href\n                    }).then(resolve).catch(reject);\n                });\n                // Tell the other party to maximize the iframe\n                communicationEngine.emit(\"notification\", {\n                    method: COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS,\n                    params: {\n                        isFullScreen: true,\n                        rid: this.state.windowId\n                    }\n                });\n            } else {\n                // this is a pre-opened window. so, we need to tell it to redirect to correct url. it's currently waiting on /redirect and uses `RedirectHandler` code\n                // Send this window with `windowId` the url to open via bc\n                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.config.instanceId}_${this.state.windowId}`;\n                const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n                bc.addEventListener(\"message\", async (ev)=>{\n                    try {\n                        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                        const { error } = ev;\n                        if (error) {\n                            // Popup says some error. so, we say it's not really opened\n                            reject(new Error(error));\n                            return;\n                        }\n                        const { message } = ev.data;\n                        if (message === POPUP_LOADED) {\n                            popupSuccess = true;\n                            await bc.postMessage({\n                                data: {\n                                    url: this.state.url.href,\n                                    message: \"\" // No need of a msg\n                                }\n                            });\n                            resolve(this);\n                            bc.close();\n                        }\n                    } catch (error) {\n                        reject(error);\n                        bc.close();\n                        // Something went wrong. so, we close that window\n                        this.close();\n                    }\n                });\n                // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n                // we need backoff strategy\n                // we need to wait for first attempt to succeed/fail until the second attempt\n                // If we get 429, we need to wait for a while and then try again\n                const postMsg = async ()=>{\n                    // this never throws\n                    const localResponse = await bc.postMessage({\n                        data: {\n                            message: SETUP_COMPLETE\n                        }\n                    });\n                    return localResponse;\n                };\n                let currentDelay = bc.type === \"server\" ? 1000 : 200;\n                const recursiveFn = async ()=>{\n                    if (!popupSuccess && !this.closed) {\n                        const localResponse = await postMsg();\n                        if (bc.type === \"server\") {\n                            const serverResponse = localResponse;\n                            if (serverResponse.status >= 400) {\n                                // We need to wait for a while and then try again\n                                currentDelay = Math.round(currentDelay * 1.5);\n                            }\n                        }\n                        await sleep(currentDelay);\n                        await recursiveFn();\n                    }\n                };\n                recursiveFn();\n            }\n        });\n    }\n    close() {\n        const { communicationEngine } = this.config;\n        communicationEngine.emit(\"notification\", {\n            method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n            params: {\n                windowId: this.state.windowId\n            }\n        });\n    }\n}\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler. \n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\n  StreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/ /**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */ class PopupHandler extends BaseController {\n    constructor({ config, state }){\n        super({\n            config,\n            state\n        });\n        // this.id = randomId()\n        // Add in dapp storage key to all popups as a hash parameter\n        this.defaultConfig = {\n            features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n            target: \"_blank\",\n            communicationEngine: null,\n            communicationWindowManager: null,\n            timeout: 30000,\n            instanceId: \"\",\n            handleWindowBlockAlert: null\n        };\n        this.defaultState = {\n            windowTimer: null,\n            window: null,\n            iClosedWindow: false,\n            windowId: \"\",\n            url: state.url\n        };\n        this.initialize();\n        this._setupTimer();\n    }\n    async open() {\n        // if window is already open\n        const { target, features, communicationEngine, communicationWindowManager } = this.config;\n        const { windowId, url } = this.state;\n        // No window has been pre-opened\n        if (!windowId) {\n            // try to open a window first\n            let localWindow = window.open(url.href, target, features);\n            let finalWindowId = \"\";\n            if (!localWindow) {\n                // if it's blocked, open StreamWindow\n                const streamWindow = new StreamWindow({\n                    config: {\n                        communicationEngine,\n                        communicationWindowManager,\n                        instanceId: this.config.instanceId,\n                        handleWindowBlockAlert: this.config.handleWindowBlockAlert\n                    },\n                    state: {\n                        url\n                    }\n                });\n                streamWindow.open();\n                finalWindowId = streamWindow.state.windowId;\n                localWindow = streamWindow;\n            }\n            this.update({\n                window: localWindow,\n                windowId: finalWindowId || randomId()\n            });\n            return;\n        }\n        // A window has been pre-opened with a query parameter `windowId`\n        const localWindow = new StreamWindow({\n            config: {\n                communicationEngine,\n                communicationWindowManager,\n                instanceId: this.config.instanceId,\n                handleWindowBlockAlert: this.config.handleWindowBlockAlert\n            },\n            state: {\n                url,\n                windowId\n            }\n        });\n        this.update({\n            window: localWindow,\n            windowId: localWindow.state.windowId\n        });\n        await localWindow.open();\n    }\n    close() {\n        this.update({\n            iClosedWindow: true\n        });\n        const { window: window1 } = this.state;\n        if (window1) window1.close();\n    }\n    _setupTimer() {\n        const timer = window.setInterval(()=>{\n            const { window: window1, windowTimer, iClosedWindow } = this.state;\n            if (window1 && window1.closed) {\n                if (windowTimer) clearInterval(windowTimer);\n                setTimeout(()=>{\n                    if (!iClosedWindow) {\n                        this.emit(\"close\");\n                    }\n                    this.update({\n                        iClosedWindow: false,\n                        window: null\n                    });\n                }, this.config.timeout);\n            }\n            if (window1 === null && windowTimer) clearInterval(windowTimer);\n        }, 500);\n        this.update({\n            windowTimer: timer\n        });\n    }\n}\n// Always listening channels. Hence, no window id\nclass PopupStoreChannel {\n    constructor({ instanceId, handleLogout, handleAccountImport, handleNetworkChange, handleSelectedAddressChange, handleThemeChange }){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleLogout\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleAccountImport\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleNetworkChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleThemeChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleSelectedAddressChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceId\", void 0);\n        this.instanceId = instanceId;\n        this.handleLogout = handleLogout;\n        this.handleAccountImport = handleAccountImport;\n        this.handleNetworkChange = handleNetworkChange;\n        this.handleSelectedAddressChange = handleSelectedAddressChange;\n        this.handleThemeChange = handleThemeChange;\n    }\n    setupStoreChannels() {\n        this.logoutChannel();\n        this.importAccountChannel();\n        this.networkChangeChannel();\n        this.selectedAddressChangeChannel();\n        this.themeChangedChannel();\n    }\n    logoutChannel() {\n        const logoutChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        logoutChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"received logout message\", ev);\n            if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Logging Out\");\n                this.handleLogout();\n            }\n        });\n    }\n    importAccountChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data2;\n            if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n                var _ev$data3;\n                this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n            }\n        });\n    }\n    networkChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data4;\n            if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n                var _ev$data5;\n                this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n            }\n        });\n    }\n    themeChangedChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.THEME_CHANGE}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data6;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info({\n                ev\n            });\n            if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n                var _ev$data7;\n                this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n            }\n        });\n    }\n    selectedAddressChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data8;\n            if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n                var _ev$data9;\n                this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n            }\n        });\n    }\n}\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */ class PopupWithBcHandler extends PopupHandler {\n    constructor({ config, state, channelPrefix }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"channelPrefix\", void 0);\n        this.channelPrefix = channelPrefix;\n    }\n    /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handle(successExtraFn) {\n        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;\n        const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            bc.addEventListener(\"message\", async (ev)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                try {\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    if (successExtraFn) await successExtraFn.call(this, data);\n                    resolve(data);\n                } catch (error) {\n                    reject(error);\n                } finally{\n                    bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`opened window ${bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n    /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handleWithHandshake(payload, successExtraFn) {\n        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;\n        const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            bc.addEventListener(\"message\", async (ev)=>{\n                try {\n                    loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    // Do handshake\n                    const { type = \"\" } = data;\n                    if (type === POPUP_LOADED) {\n                        // Hack with generic to use the same type for both send and receive\n                        await bc.postMessage({\n                            data: payload\n                        });\n                    } else if (type === POPUP_RESULT) {\n                        if (successExtraFn) await successExtraFn.call(this, data);\n                        resolve(data);\n                        // Must only close the bc after result is done\n                        bc.close();\n                        this.close();\n                    }\n                } catch (error) {\n                    reject(error);\n                    bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`opened window ${bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n}\nclass RedirectHandler {\n    // private hashParameters: Record<string, string>;\n    constructor(instanceId){\n        // private error: string;\n        // this is sessionid post login\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceId\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"finalQueryParams\", {});\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceParameters\", void 0);\n        const { hash } = window.location;\n        const queryParameters = new URLSearchParams(window.location.search);\n        queryParameters.forEach((value, key)=>{\n            this.finalQueryParams[key] = value;\n        });\n        const { instanceParameters } = handleRedirectParameters(hash, this.finalQueryParams);\n        // this.error = error;\n        this.instanceParameters = instanceParameters;\n        // this.hashParameters = hashParameters;\n        this.instanceId = instanceId;\n    }\n    async handle() {\n        return new Promise((resolve, reject)=>{\n            const { finalQueryParams, instanceParameters } = this;\n            let bc;\n            try {\n                // used for login case. there's no windowId here\n                // if (!finalQueryParams.windowId) {\n                //   bc = new BroadcastChannel(`${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${instanceParameters.instanceId}`, broadcastChannelOptions);\n                //   bc.addEventListener(\"message\", async (ev) => {\n                //     if (ev.error) {\n                //       reject(ev.error);\n                //       window.close();\n                //     } else {\n                //       resolve();\n                //       bc.close();\n                //       log.info(\"posted\", { finalQueryParams, hashParameters, instanceParameters });\n                //     }\n                //   });\n                //   bc.postMessage({\n                //     data: {\n                //       instanceParams: instanceParameters,\n                //       hashParams: hashParameters,\n                //       queryParams: finalQueryParams,\n                //     },\n                //     error,\n                //   });\n                //   setTimeout(() => {\n                //     resolve();\n                //     window.location.href = window.location.origin + window.location.search + window.location.hash;\n                //   }, 5000);\n                // } else {\n                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.instanceId || instanceParameters.instanceId}_${finalQueryParams.windowId || instanceParameters.windowId}`;\n                bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n                bc.addEventListener(\"message\", async (ev)=>{\n                    const { url, message } = ev.data;\n                    if (url) {\n                        resolve();\n                        window.location.href = url;\n                    } else if (message === SETUP_COMPLETE) {\n                        await bc.postMessage({\n                            data: {\n                                windowId: finalQueryParams.windowId,\n                                message: POPUP_LOADED\n                            }\n                        });\n                    }\n                    if (ev.error && ev.error !== \"\") {\n                        loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(ev.error);\n                        resolve();\n                        bc.close();\n                    }\n                });\n            // }\n            } catch (err) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(err, \"something went wrong\");\n                reject(err);\n                if (bc) bc.close();\n                window.close();\n            }\n        });\n    }\n}\nvar HTTP_METHOD = /*#__PURE__*/ function(HTTP_METHOD) {\n    HTTP_METHOD[HTTP_METHOD[\"GET\"] = 0] = \"GET\";\n    HTTP_METHOD[HTTP_METHOD[\"POST\"] = 1] = \"POST\";\n    HTTP_METHOD[HTTP_METHOD[\"PUT\"] = 2] = \"PUT\";\n    HTTP_METHOD[HTTP_METHOD[\"PATCH\"] = 3] = \"PATCH\";\n    HTTP_METHOD[HTTP_METHOD[\"DELETE\"] = 4] = \"DELETE\";\n    return HTTP_METHOD;\n}(HTTP_METHOD || {});\nconst constructAuthHeaders = ({ jwtToken, publicAddress })=>{\n    return {\n        headers: {\n            Authorization: `Bearer ${jwtToken}`,\n            \"public-address\": publicAddress\n        }\n    };\n};\nconst withUnauthorizedHandler = async (fn, emitter)=>{\n    try {\n        const response = await fn();\n        return response;\n    } catch (e) {\n        if (isUnauthorizedError(e)) {\n            emitter.emit(ControllerEvents.UserUnauthorized);\n        }\n        throw e;\n    }\n};\nconst jwtTokenExpired = (jwt)=>{\n    const decoded = (0,jwt_decode__WEBPACK_IMPORTED_MODULE_9__.jwtDecode)(jwt);\n    const jwtExpiry = decoded.exp * 1000;\n    const currentTime = new Date().getTime();\n    return currentTime >= jwtExpiry;\n};\nconst WSApiClient = (baseApiUrl, emitter)=>{\n    const authRequest = (method, url, data, authCredentials, customOptions)=>{\n        if (jwtTokenExpired(authCredentials.jwtToken)) {\n            emitter.emit(ControllerEvents.UserUnauthorized);\n            // eslint-disable-next-line @typescript-eslint/no-throw-literal\n            throw new Response(null, {\n                status: 401,\n                statusText: \"Unauthorized\"\n            });\n        }\n        const headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }, constructAuthHeaders(authCredentials));\n        if (method === HTTP_METHOD.GET) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.get)(url, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.POST) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.PUT) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.put)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.PATCH) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.patch)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.DELETE) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.remove)(url, data, headers, customOptions), emitter);\n        }\n    };\n    return {\n        authGet: (url, authCredentials, customOptions)=>authRequest(HTTP_METHOD.GET, `${baseApiUrl}/${url}`, {}, authCredentials, customOptions),\n        authPost: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.POST, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authPut: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PUT, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authPatch: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PATCH, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authRemove: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.DELETE, `${baseApiUrl}/${url}`, data, authCredentials, customOptions)\n    };\n};\nconst ACTIVITY_ACTION = {\n    ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n    ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n    ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n    ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n    NORMAL: \"normal\",\n    THRESHOLD: \"threshold\",\n    IMPORTED: \"imported\",\n    // we have private key here\n    APP_SCOPED: \"app_scoped\",\n    ACCOUNT_ABSTRACTION: \"account_abstraction\",\n    EXTERNAL: \"external\",\n    // like metamask, wallet connect\n    MPC: \"mpc\",\n    SFA: \"sfa\"\n};\n/**\n * Preferences controller state\n */ /**\n * @param address - address of the user\n * @param jwtToken - if jwt token already exists, it will be used instead of fetching from backend\n * @param calledFromEmbed - if called from embed\n * @param userInfo - optional user info\n * @param rehydrate - Rehydrate the preferences from the local storage\n */ // By default, poll every 3 minutes\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n    selectedCurrency: \"USD\",\n    theme: \"dark\",\n    locale: \"en\",\n    accountType: ACCOUNT_CATEGORY.NORMAL,\n    contacts: [],\n    jwtToken: \"\",\n    fetchedPastTx: [],\n    pastTransactions: [],\n    paymentTx: [],\n    defaultPublicAddress: \"\",\n    customTokens: [],\n    customNfts: [],\n    crashReport: true,\n    userInfo: {\n        aggregateVerifier: \"\",\n        email: \"\",\n        name: \"\",\n        profileImage: \"\",\n        typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n        verifier: \"\",\n        verifierId: \"\"\n    }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */ class BasePreferencesController extends BaseController {\n    /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor({ config, state, defaultPreferences, signAuthMessage, validateSignMessage }){\n        super({\n            config,\n            state\n        });\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"PreferencesController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"iframeOrigin\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"wsApiClient\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"signAuthMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"validateSignMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultPreferences\", void 0);\n        if (!config.api) {\n            throw new Error(\"PreferencesController - no api specified in config.\");\n        }\n        this.defaultState = {\n            identities: {},\n            selectedAddress: \"\",\n            lastErrorMessage: \"\",\n            lastSuccessMessage: \"\"\n        };\n        this.defaultConfig = {\n            api: config.api,\n            pollInterval: DEFAULT_INTERVAL\n        };\n        this.initialize();\n        this.defaultPreferences = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, DEFAULT_PREFERENCES), defaultPreferences);\n        this.signAuthMessage = signAuthMessage;\n        this.validateSignMessage = validateSignMessage;\n        this.wsApiClient = WSApiClient(this.config.api, this);\n    }\n    setIframeOrigin(origin) {\n        this.iframeOrigin = origin;\n    }\n    getAddressState(address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        return this.state.identities[selectedAddress];\n    }\n    /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */ setSelectedAddress(selectedAddress) {\n        this.update({\n            selectedAddress\n        });\n    }\n    async getUser(address) {\n        const user = await this.wsApiClient.authGet(\"user?fetchTx=false\", this.authCredentials(address), {\n            useAPIKey: true\n        });\n        return user.data;\n    }\n    async createUser(params) {\n        const { selectedCurrency, theme, verifier, verifierId, locale, address, idToken, type, web3AuthNetwork } = params;\n        const userPayload = {\n            default_currency: selectedCurrency,\n            theme,\n            verifier,\n            verifier_id: verifierId,\n            locale,\n            idToken,\n            account_type: type,\n            web3auth_network: web3AuthNetwork\n        };\n        await this.wsApiClient.authPost(\"user\", userPayload, this.authCredentials(address), {\n            useAPIKey: true\n        });\n        this.updateState({\n            theme,\n            defaultPublicAddress: address,\n            selectedCurrency,\n            locale,\n            accountType: type\n        }, address);\n    }\n    async storeUserLogin(params) {\n        const { verifierId, verifier, options, address, idToken, web3AuthClientId, web3AuthNetwork, sessionPubKey, loginMode } = params;\n        if (!options.rehydrate) {\n            const browser = bowser__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getParser(window.navigator.userAgent);\n            const specialBrowser = getCustomDeviceInfo();\n            const recordLoginPayload = {\n                os: browser.getOSName(),\n                os_version: browser.getOSVersion() || \"unidentified\",\n                browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n                browser_version: browser.getBrowserVersion() || \"unidentified\",\n                platform: browser.getPlatform().type || \"desktop\",\n                hostname: this.iframeOrigin,\n                verifier,\n                verifier_id: verifierId,\n                idToken,\n                web3auth_client_id: web3AuthClientId,\n                web3auth_network: web3AuthNetwork,\n                session_pub_key: sessionPubKey,\n                login_mode: loginMode\n            };\n            await this.wsApiClient.authPost(\"user/recordLogin\", recordLoginPayload, this.authCredentials(address), {\n                useAPIKey: true\n            });\n        }\n    }\n    async setCrashReport(isEnabled) {\n        var _this$getAddressState;\n        if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                enable_crash_reporter: isEnabled\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                crashReport: isEnabled\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async setUserTheme(theme) {\n        var _this$getAddressState2;\n        if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                theme\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                theme\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async setUserLocale(locale) {\n        var _this$getAddressState3;\n        if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                locale\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                locale\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to set locale\", error);\n            return false;\n        }\n    }\n    async setSelectedCurrency(payload) {\n        var _this$getAddressState4;\n        if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                default_currency: payload.selectedCurrency\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                selectedCurrency: payload.selectedCurrency\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async addContact(contact) {\n        try {\n            var _this$getAddressState5;\n            const response = await this.wsApiClient.authPost(\"contact\", contact, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                contacts: [\n                    ...((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || [],\n                    response.data\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to add contact\", error);\n            return false;\n        }\n    }\n    async deleteContact(contactId) {\n        try {\n            var _this$getAddressState6;\n            const response = await this.wsApiClient.authRemove(`contact/${contactId}`, {}, this.authCredentials(), {\n                useAPIKey: true\n            });\n            const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter((contact)=>contact.id !== response.data.id);\n            if (finalContacts) this.updateState({\n                contacts: [\n                    ...finalContacts\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to delete contact\", error);\n            return false;\n        }\n    }\n    async revokeDiscord(idToken) {\n        try {\n            const resp = await this.wsApiClient.authPost(\"revoke/discord\", {\n                token: idToken\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(resp);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n        }\n    }\n    async patchPastTx(body, address) {\n        try {\n            const response = await this.wsApiClient.authPatch(\"transaction\", body, this.authCredentials(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"successfully patched\", response);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to patch tx\", error);\n        }\n    }\n    async postPastTx(tx, address) {\n        try {\n            const response = await this.wsApiClient.authPost(\"transaction\", tx, this.authCredentials(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"successfully posted tx\", response);\n            return response;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error, \"unable to insert transaction\");\n        }\n    }\n    async getWalletOrders(address) {\n        try {\n            const response = await this.wsApiClient.authGet(\"transaction\", this.authCredentials(address), {\n                useAPIKey: true\n            });\n            return response.success ? response.data ? response.data : [] : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get wallet orders tx\", error);\n            return [];\n        }\n    }\n    async getTopUpOrders(address) {\n        try {\n            const response = await this.wsApiClient.authGet(\"transaction\", this.authCredentials(address), {\n                useAPIKey: true\n            });\n            return response.data || [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to fetch past Top up orders\", error);\n        }\n    }\n    async getBillBoardData() {\n        try {\n            const response = await this.wsApiClient.authGet(\"billboard\", this.authCredentials(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get billboard data\", error);\n            return [];\n        }\n    }\n    async getMessageForSigning(publicAddress, web3AuthIdToken) {\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/message`, {\n            public_address: publicAddress,\n            id_token: web3AuthIdToken\n        }, {}, {\n            useAPIKey: true\n        });\n        return response.message;\n    }\n    async getTwitterId(payload) {\n        const res = await this.wsApiClient.authGet(`twitter?screen_name=${payload.nick}`, this.authCredentials(), {\n            useAPIKey: true\n        });\n        return `${payload.typeOfLogin.toLowerCase()}|${res.data.toString()}`;\n    }\n    async sendEmail(payload) {\n        return this.wsApiClient.authPost(\"transaction/sendemail\", payload.emailObject, this.authCredentials(), {\n            useAPIKey: true\n        });\n    }\n    async refreshJwt() {\n        const address = this.state.selectedAddress;\n        const messageToSign = await this.getMessageForSigning(address);\n        await this.validateSignMessage(messageToSign);\n        const signedMessage = await this.signAuthMessage(address, messageToSign);\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, {\n            challenge: messageToSign,\n            public_address: address,\n            signed_message: signedMessage\n        }, {}, {\n            useAPIKey: true\n        });\n        this.updateState({\n            jwtToken: response.token\n        }, address);\n    }\n    async getDappList() {\n        try {\n            const response = await this.wsApiClient.authGet(\"dapps\", this.authCredentials(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get dapps list\", error);\n            return [];\n        }\n    }\n    /**\n   * Strategy\n   * For account type: threshold, normal (web3auth login)\n   * idToken from web3auth login must be present. We use it directly\n   *\n   * For account type: app_scoped, IMPORTED\n   * idToken from web3auth login must be present. We request a message for signing using the idToken\n   * and sign it using the private key of the account. We then send the signed message to the backend\n   * to verify the signature and return a new jwtToken that includes the app_scoped address\n   *\n   * For account type: Account abstraction\n   * idToken from web3auth login must be present. We use it to exchange for a new jwtToken.\n   * Because backend can derive AA address from public address and issue this token easily.\n   *\n   * For account type: external\n   * idToken from web3auth `authenticateUser` (siww) login must be present. We use it directly\n   */ async init(params) {\n        const { address, userInfo, idToken, metadata = {}, type } = params;\n        if (this.getAddressState(address)) return;\n        let jwtToken;\n        switch(type){\n            case ACCOUNT_CATEGORY.IMPORTED:\n                {\n                    if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                    const messageToSign = await this.getMessageForSigning(address, idToken);\n                    await this.validateSignMessage(messageToSign);\n                    const signedMessage = await this.signAuthMessage(address, messageToSign);\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        challenge: messageToSign,\n                        account_type: type,\n                        public_address: address,\n                        signed_message: signedMessage,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.EXTERNAL:\n                {\n                    if (!idToken) throw new Error(\"SIWW idToken must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        account_type: type,\n                        public_address: address,\n                        id_token: idToken,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.ACCOUNT_ABSTRACTION:\n                {\n                    if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        public_address: address,\n                        id_token: idToken,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId,\n                        account_type: type\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.MPC:\n            case ACCOUNT_CATEGORY.SFA:\n                {\n                    if (!metadata.signatures) throw new Error(\"MPC signatures must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        public_address: address,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId,\n                        account_type: type\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.NORMAL:\n            case ACCOUNT_CATEGORY.THRESHOLD:\n            case ACCOUNT_CATEGORY.APP_SCOPED:\n            default:\n                if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                jwtToken = idToken;\n                break;\n        }\n        this.updateState({\n            jwtToken,\n            userInfo,\n            accountType: type !== null && type !== void 0 ? type : this.defaultPreferences.accountType\n        }, address);\n    }\n    updateState(preferences, address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n        const mergedState = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, currentState), preferences);\n        this.update({\n            identities: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.state.identities), {}, {\n                [selectedAddress]: mergedState\n            })\n        });\n        return mergedState;\n    }\n    authCredentials(address) {\n        var _this$getAddressState7;\n        const selectedAddress = address || this.state.selectedAddress;\n        const jwtToken = ((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\";\n        return {\n            jwtToken,\n            publicAddress: selectedAddress\n        };\n    }\n    headers(address) {\n        var _this$getAddressState8;\n        const selectedAddress = address || this.state.selectedAddress;\n        return getHeaders(((_this$getAddressState8 = this.getAddressState(selectedAddress)) === null || _this$getAddressState8 === void 0 ? void 0 : _this$getAddressState8.jwtToken) || \"\", selectedAddress);\n    }\n}\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[\"approved\"] = \"approved\";\n    TransactionStatus[\"cancelled\"] = \"cancelled\";\n    TransactionStatus[\"cancelling\"] = \"cancelling\";\n    TransactionStatus[\"confirmed\"] = \"confirmed\";\n    TransactionStatus[\"failed\"] = \"failed\";\n    TransactionStatus[\"finalized\"] = \"finalized\";\n    TransactionStatus[\"processed\"] = \"processed\";\n    TransactionStatus[\"rejected\"] = \"rejected\";\n    TransactionStatus[\"signed\"] = \"signed\";\n    TransactionStatus[\"submitted\"] = \"submitted\";\n    TransactionStatus[\"unapproved\"] = \"unapproved\";\n    TransactionStatus[\"dropped\"] = \"dropped\";\n    TransactionStatus[\"expired\"] = \"expired\";\n    TransactionStatus[\"pending\"] = \"pending\";\n    return TransactionStatus;\n}({});\nconst TRANSACTION_TYPES = {\n    CANCEL: \"cancel\",\n    RETRY: \"retry\",\n    CONTRACT_INTERACTION: \"contractInteraction\",\n    DEPLOY_CONTRACT: \"contractDeployment\",\n    WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n    STANDARD_TRANSACTION: \"transaction\",\n    STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\",\n    // specific to chains like solana and casper\n    SENT_ETHER: \"sentEther\",\n    TOKEN_METHOD_TRANSFER: \"transfer\",\n    TOKEN_METHOD_TRANSFER_FROM: \"transferFrom\",\n    TOKEN_METHOD_APPROVE: \"approve\",\n    COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM: \"safeTransferFrom\",\n    SET_APPROVAL_FOR_ALL: \"setApprovalForAll\"\n};\nconst TX_EVENTS = {\n    TX_WARNING: \"tx:warning\",\n    TX_ERROR: \"tx:error\",\n    TX_FAILED: \"tx:failed\",\n    TX_CONFIRMED: \"tx:confirmed\",\n    TX_DROPPED: \"tx:dropped\",\n    TX_EXPIRED: \"tx:expired\",\n    TX_STATUS_UPDATE: \"tx:status_update\",\n    TX_UNAPPROVED: \"tx:unapproved\",\n    TX_RETRY: \"tx:retry\",\n    TX_BLOCK_UPDATE: \"tx:block_update\"\n};\n/**\n * Transaction controller configuration\n */ /**\n * Transaction controller state\n */ /**\n * Result\n *\n * result - Promise resolving to a new transaction hash\n * transactionMeta - Meta information about this new transaction\n */ class BaseTransactionStateManager extends BaseController {\n    constructor({ config, state, getCurrentChainId }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"getCurrentChainId\", void 0);\n        this.defaultConfig = {\n            txHistoryLimit: 40\n        };\n        this.defaultState = {\n            transactions: {},\n            unapprovedTxs: {},\n            currentNetworkTxsList: []\n        };\n        this.initialize();\n        this.getCurrentChainId = getCurrentChainId;\n    }\n    getUnapprovedTxList() {\n        const chainId = this.getCurrentChainId();\n        return pickBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n    }\n    getTransaction(txId) {\n        const { transactions } = this.state;\n        return transactions[txId];\n    }\n    updateTransaction(txMeta) {\n        // commit txMeta to state\n        const txId = txMeta.id;\n        txMeta.updated_at = new Date().toISOString();\n        this.update({\n            transactions: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.state.transactions), {}, {\n                [txId]: txMeta\n            })\n        });\n    }\n    setTxStatusRejected(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.rejected);\n        this._deleteTransaction(txId);\n    }\n    /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */ setTxStatusUnapproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.unapproved);\n    }\n    setTxStatusApproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.approved);\n    }\n    setTxStatusSigned(txId, isFinalStep) {\n        this._setTransactionStatus(txId, TransactionStatus.signed, isFinalStep);\n    }\n    setTxStatusSubmitted(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.submitted);\n    }\n    setTxStatusDropped(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.dropped);\n    }\n    setTxStatusExpired(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.expired);\n    }\n    setTxStatusConfirmed(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.confirmed);\n    }\n    setTxStatusFailed(txId, error_) {\n        const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n        const txMeta = this.getTransaction(txId);\n        txMeta.error = error;\n        this.updateTransaction(txMeta);\n        this._setTransactionStatus(txId, TransactionStatus.failed);\n    }\n    /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */ isFinalState(status) {\n        return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n    }\n    /**\n   * Filters out the unapproved transactions from state\n   */ clearUnapprovedTxs() {\n        this.update({\n            transactions: omitBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved)\n        });\n    }\n    /**\n   * will append new transactions to old txns.\n   */ _addTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, this.state.transactions)\n        });\n    }\n    /**\n   * will set new txns, override existing if any in state.\n   */ _setTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, {})\n        });\n    }\n    _deleteTransaction(targetTransactionId) {\n        const { transactions } = this.state;\n        delete transactions[targetTransactionId];\n        this.update({\n            transactions\n        });\n    }\n    _deleteTransactions(targetTransactionIds) {\n        const { transactions } = this.state;\n        targetTransactionIds.forEach((transactionId)=>{\n            delete transactions[transactionId];\n        });\n        this.update({\n            transactions\n        });\n    }\n    _setTransactionStatus(txId, status, isFinalStep) {\n        const txMeta = this.getTransaction(txId);\n        if (!txMeta) {\n            return;\n        }\n        txMeta.status = status;\n        // only updating status so no validation required on txn.\n        this.updateTransaction(txMeta);\n        this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n            txId,\n            status\n        });\n        if (this.isFinalState(status) || isFinalStep) {\n            this.emit(`${txMeta.id}:finished`, txMeta);\n        } else {\n            this.emit(`${txMeta.id}:${status}`, txId);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvYmFzZUNvbnRyb2xsZXJzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNHO0FBQ3NHO0FBQ2xHO0FBQzdDO0FBQ3FJO0FBQzFHO0FBQ2pCO0FBQzJCO0FBQ3BDO0FBQ1c7QUFFdkM7O0NBRUMsR0FDRCxNQUFNNkIsdUJBQXVCM0IsdUVBQWdCQTtJQUMzQzs7Ozs7O0dBTUMsR0FDRDRCLFlBQVksRUFDVkMsU0FBUyxDQUFDLENBQUMsRUFDWEMsUUFBUSxDQUFDLENBQUMsRUFDWCxDQUFFO1FBQ0QsS0FBSztRQUNMLGtFQUFrRTtRQUNsRTs7S0FFQyxHQUNEL0IsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixDQUFDO1FBQ3hDOztLQUVDLEdBQ0RBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQztRQUN2Qzs7S0FFQyxHQUNEQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsWUFBWTtRQUNsQzs7S0FFQyxHQUNEQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsUUFBUTtRQUM5QkEsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEtBQUs7UUFDM0NBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxrQkFBa0IsSUFBSSxDQUFDZ0MsYUFBYTtRQUMxRGhDLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsSUFBSSxDQUFDaUMsWUFBWTtRQUN4RCxJQUFJLENBQUNDLFlBQVksR0FBR0g7UUFDcEIsSUFBSSxDQUFDSSxhQUFhLEdBQUdMO0lBQ3ZCO0lBRUE7Ozs7R0FJQyxHQUNELElB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eUMsY0FBYztRQUNwQztRQUNBLElBQUksQ0FBQ3p4QixNQUFNLENBQUM7WUFDVmd2QjtRQUNGO0lBQ0Y7SUFDQVksc0JBQXNCTixJQUFJLEVBQUV4VSxNQUFNLEVBQUVxVixXQUFXLEVBQUU7UUFDL0MsTUFBTVgsU0FBUyxJQUFJLENBQUNILGNBQWMsQ0FBQ0M7UUFDbkMsSUFBSSxDQUFDRSxRQUFRO1lBQ1g7UUFDRjtRQUNBQSxPQUFPMVUsTUFBTSxHQUFHQTtRQUNoQix5REFBeUQ7UUFDekQsSUFBSSxDQUFDeVUsaUJBQWlCLENBQUNDO1FBQ3ZCLElBQUksQ0FBQ3Z2QixJQUFJLENBQUNpdUIsVUFBVU8sZ0JBQWdCLEVBQUU7WUFDcENhO1lBQ0F4VTtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNrVyxZQUFZLENBQUNsVyxXQUFXcVYsYUFBYTtZQUM1QyxJQUFJLENBQUNsd0IsSUFBSSxDQUFDLENBQUMsRUFBRXV2QixPQUFPblQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFbVQ7UUFDckMsT0FBTztZQUNMLElBQUksQ0FBQ3Z2QixJQUFJLENBQUMsQ0FBQyxFQUFFdXZCLE9BQU9uVCxFQUFFLENBQUMsQ0FBQyxFQUFFdkIsT0FBTyxDQUFDLEVBQUV3VTtRQUN0QztJQUNGO0FBQ0Y7QUFFdWtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcW9nbml0YS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jhc2UtY29udHJvbGxlcnMvZGlzdC9iYXNlQ29udHJvbGxlcnMuZXNtLmpzP2Q5NGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBTYWZlRXZlbnRFbWl0dGVyLCBjcmVhdGVBc3luY01pZGRsZXdhcmUsIG1lcmdlTWlkZGxld2FyZSwgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlLCBKUlBDRW5naW5lLCBwcm92aWRlckZyb21FbmdpbmUsIHJwY0Vycm9ycyB9IGZyb20gJ0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMnO1xuaW1wb3J0IHsgcG9zdCwgZ2V0LCBwdXQsIHBhdGNoLCByZW1vdmUgfSBmcm9tICdAdG9ydXNsYWJzL2h0dHAtaGVscGVycyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IGZyb21TaWduZWQsIGJ5dGVzVG9CaWdJbnQsIHRvVW5zaWduZWQsIHN0cmlwSGV4UHJlZml4LCBiaWdJbnRUb0hleCwgYWRkSGV4UHJlZml4LCBoYXNoUGVyc29uYWxNZXNzYWdlLCBlY3NpZ24sIGJpZ0ludFRvQnl0ZXMgfSBmcm9tICdAZXRoZXJldW1qcy91dGlsJztcbmltcG9ydCB7IHNhZmVhdG9iIH0gZnJvbSAnQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQnJvYWRjYXN0Q2hhbm5lbCB9IGZyb20gJ0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwnO1xuaW1wb3J0IGJvd3NlciBmcm9tICdib3dzZXInO1xuaW1wb3J0IHsgand0RGVjb2RlIH0gZnJvbSAnand0LWRlY29kZSc7XG5cbi8qKlxuICogQ29udHJvbGxlciBjbGFzcyB0aGF0IHByb3ZpZGVzIGNvbmZpZ3VyYXRpb24sIHN0YXRlIG1hbmFnZW1lbnQsIGFuZCBzdWJzY3JpcHRpb25zXG4gKi9cbmNsYXNzIEJhc2VDb250cm9sbGVyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmFzZUNvbnRyb2xsZXIgaW5zdGFuY2UuIEJvdGggaW5pdGlhbCBzdGF0ZSBhbmQgaW5pdGlhbFxuICAgKiBjb25maWd1cmF0aW9uIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGRlZmF1bHRzIHVwb24gaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyA9IHt9LFxuICAgIHN0YXRlID0ge31cbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgLy8gVXNlIGFzc2lnbiBzaW5jZSBnZW5lcmljcyBjYW4ndCBiZSBzcHJlYWQ6IGh0dHBzOi8vZ2l0LmlvL3ZwUmhZXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRDb25maWdcIiwge30pO1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RhdGUgc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRTdGF0ZVwiLCB7fSk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBsaXN0ZW5lcnMgYXJlIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIFwiQmFzZUNvbnRyb2xsZXJcIik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5pdGlhbENvbmZpZ1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRpYWxTdGF0ZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludGVybmFsQ29uZmlnXCIsIHRoaXMuZGVmYXVsdENvbmZpZyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZXJuYWxTdGF0ZVwiLCB0aGlzLmRlZmF1bHRTdGF0ZSk7XG4gICAgdGhpcy5pbml0aWFsU3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMgLSBDdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyAtIEN1cnJlbnQgc3RhdGVcbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29udHJvbGxlciBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgLSBOZXcgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBPdmVyd3JpdGUgY29uZmlnIGluc3RlYWQgb2YgbWVyZ2luZ1xuICAgKiBAcGFyYW0gZnVsbFVwZGF0ZSAtIEJvb2xlYW4gdGhhdCBkZWZpbmVzIGlmIHRoZSB1cGRhdGUgaXMgcGFydGlhbCBvciBub3RcbiAgICovXG4gIGNvbmZpZ3VyZShjb25maWcsIG92ZXJ3cml0ZSA9IGZhbHNlLCBmdWxsVXBkYXRlID0gdHJ1ZSkge1xuICAgIGlmIChmdWxsVXBkYXRlKSB7XG4gICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gb3ZlcndyaXRlID8gY29uZmlnIDogT2JqZWN0LmFzc2lnbih0aGlzLmludGVybmFsQ29uZmlnLCBjb25maWcpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pbnRlcm5hbENvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgdGhpc1trZXldID0gdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSA9IGNvbmZpZ1trZXldO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgdGhpc1trZXldID0gY29uZmlnW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBjb250cm9sbGVyIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIE5ldyBzdGF0ZVxuICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIHN0YXRlIGluc3RlYWQgb2YgbWVyZ2luZ1xuICAgKi9cbiAgdXBkYXRlKHN0YXRlLCBvdmVyd3JpdGUgPSBmYWxzZSkge1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IG92ZXJ3cml0ZSA/IF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSA6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5pbnRlcm5hbFN0YXRlKSwgc3RhdGUpO1xuICAgIHRoaXMuZW1pdChcInN0b3JlXCIsIHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgY29udHJvbGxlci4gVGhpcyBzZXRzIGVhY2ggY29uZmlnIG9wdGlvbiBhcyBhIG1lbWJlclxuICAgKiB2YXJpYWJsZSBvbiB0aGlzIGluc3RhbmNlIGFuZCB0cmlnZ2VycyBhbnkgZGVmaW5lZCBzZXR0ZXJzLiBUaGlzXG4gICAqIGFsc28gc2V0cyBpbml0aWFsIHN0YXRlIGFuZCB0cmlnZ2VycyBhbnkgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyAtIFRoaXMgY29udHJvbGxlciBpbnN0YW5jZVxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLmludGVybmFsQ29uZmlnID0gdGhpcy5kZWZhdWx0Q29uZmlnO1xuICAgIHRoaXMuY29uZmlndXJlKHRoaXMuaW5pdGlhbENvbmZpZyk7XG4gICAgdGhpcy51cGRhdGUodGhpcy5pbml0aWFsU3RhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmNvbnN0IHNlYyA9IDEwMDA7XG5jb25zdCBjYWxjdWxhdGVTdW0gPSAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWU7XG5jb25zdCBibG9ja1RyYWNrZXJFdmVudHMgPSBbXCJzeW5jXCIsIFwibGF0ZXN0XCJdO1xuY2xhc3MgQmFzZUJsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyA9IHt9LFxuICAgIHN0YXRlID0ge31cbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG5cbiAgICAvLyBjb25maWdcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIFwiQmFzZUJsb2NrVHJhY2tlclwiKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYmxvY2tSZXNldFRpbWVvdXRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIF9jdXJyZW50QmxvY2s6IHtcbiAgICAgICAgaWRlbXBvdGVuY3lLZXk6IFwiXCJcbiAgICAgIH0sXG4gICAgICBfaXNSdW5uaW5nOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgYmxvY2tSZXNldER1cmF0aW9uOiAyMCAqIHNlY1xuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG5cbiAgICAvLyBiaW5kIGZ1bmN0aW9ucyBmb3IgaW50ZXJuYWwgdXNlXG4gICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IHRoaXMuX29uTmV3TGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrID0gdGhpcy5fcmVzZXRDdXJyZW50QmxvY2suYmluZCh0aGlzKTtcblxuICAgIC8vIGxpc3RlbiBmb3IgaGFuZGxlciBjaGFuZ2VzXG4gICAgdGhpcy5fc2V0dXBJbnRlcm5hbEV2ZW50cygpO1xuICB9XG4gIGlzUnVubmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5faXNSdW5uaW5nO1xuICB9XG4gIGdldEN1cnJlbnRCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrO1xuICB9XG4gIGFzeW5jIGdldExhdGVzdEJsb2NrKCkge1xuICAgIC8vIHJldHVybiBpZiBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrLmlkZW1wb3RlbmN5S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrO1xuICAgIH1cbiAgICAvLyB3YWl0IGZvciBhIG5ldyBsYXRlc3QgYmxvY2tcbiAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5vbmNlKFwibGF0ZXN0XCIsIGJsb2NrID0+IHtcbiAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgcmVzb2x2ZShibG9jayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIHJldHVybiBuZXdseSBzZXQgY3VycmVudCBibG9ja1xuICAgIHJldHVybiBsYXRlc3RCbG9jaztcbiAgfVxuXG4gIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8vIHJlLWFkZCBpbnRlcm5hbCBldmVudHNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gICAgLy8gdHJpZ2dlciBzdG9wIGNoZWNrIGp1c3QgaW4gY2FzZVxuICAgIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cbiAgICovXG4gIF9zdGFydCgpIHtcbiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cbiAgICovXG4gIF9lbmQoKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gIH1cbiAgX25ld1BvdGVudGlhbExhdGVzdChuZXdCbG9jaykge1xuICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcbiAgICAvLyBvbmx5IHVwZGF0ZSBpZiBibG9jayBudW1iZXIgaXMgaGlnaGVyXG4gICAgaWYgKGN1cnJlbnRCbG9jayAmJiBuZXdCbG9jay5pZGVtcG90ZW5jeUtleSA9PT0gY3VycmVudEJsb2NrLmlkZW1wb3RlbmN5S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3NldEN1cnJlbnRCbG9jayhuZXdCbG9jayk7XG4gIH1cbiAgX3NldHVwSW50ZXJuYWxFdmVudHMoKSB7XG4gICAgLy8gZmlyc3QgcmVtb3ZlIGxpc3RlbmVycyBmb3IgaWRlbXBvdGVuY3lcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwibmV3TGlzdGVuZXJcIiwgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcInJlbW92ZUxpc3RlbmVyXCIsIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICB0aGlzLm9uKFwicmVtb3ZlTGlzdGVuZXJcIiwgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgdGhpcy5vbihcIm5ld0xpc3RlbmVyXCIsIHRoaXMuX29uTmV3TGlzdGVuZXIpO1xuICB9XG4gIF9vbk5ld0xpc3RlbmVyKCkge1xuICAgIHRoaXMuX21heWJlU3RhcnQoKTtcbiAgfVxuICBfb25SZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAvLyBgcmVtb3ZlTGlzdGVuZXJgIGlzIGNhbGxlZCAqYWZ0ZXIqIHRoZSBsaXN0ZW5lciBpcyByZW1vdmVkXG4gICAgaWYgKHRoaXMuX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQoKSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbWF5YmVFbmQoKTtcbiAgfVxuICBfbWF5YmVTdGFydCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuX2lzUnVubmluZyA9IHRydWU7XG4gICAgLy8gY2FuY2VsIHNldHRpbmcgbGF0ZXN0IGJsb2NrIHRvIHN0YWxlXG4gICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICB0aGlzLl9zdGFydCgpO1xuICB9XG4gIF9tYXliZUVuZCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgdGhpcy5fZW5kKCk7XG4gIH1cbiAgX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQoKSB7XG4gICAgcmV0dXJuIGJsb2NrVHJhY2tlckV2ZW50cy5tYXAoZXZlbnROYW1lID0+IHRoaXMubGlzdGVuZXJDb3VudChldmVudE5hbWUpKS5yZWR1Y2UoY2FsY3VsYXRlU3VtKTtcbiAgfVxuICBfc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKSB7XG4gICAgY29uc3Qgb2xkQmxvY2sgPSB0aGlzLnN0YXRlLl9jdXJyZW50QmxvY2s7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgX2N1cnJlbnRCbG9jazogbmV3QmxvY2tcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoXCJsYXRlc3RcIiwgbmV3QmxvY2spO1xuICAgIHRoaXMuZW1pdChcInN5bmNcIiwge1xuICAgICAgb2xkQmxvY2ssXG4gICAgICBuZXdCbG9ja1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KCkge1xuICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKTtcbiAgICAvLyBjbGVhciBsYXRlc3QgYmxvY2sgd2hlbiBzdGFsZVxuICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9yZXNldEN1cnJlbnRCbG9jaywgdGhpcy5jb25maWcuYmxvY2tSZXNldER1cmF0aW9uKTtcblxuICAgIC8vIG5vZGVqcyAtIGRvbnQgaG9sZCBwcm9jZXNzIG9wZW5cbiAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYpIHtcbiAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0LnVucmVmKCk7XG4gICAgfVxuICB9XG4gIF9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCk7XG4gICAgfVxuICB9XG4gIF9yZXNldEN1cnJlbnRCbG9jaygpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBfY3VycmVudEJsb2NrOiB7XG4gICAgICAgIGlkZW1wb3RlbmN5S2V5OiBcIlwiXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZmlsdGVyTm9vcCA9ICgpID0+IHRydWU7XG5jb25zdCBpbnRlcm5hbEV2ZW50cyA9IFtcIm5ld0xpc3RlbmVyXCIsIFwicmVtb3ZlTGlzdGVuZXJcIl07XG5jb25zdCBleHRlcm5hbEV2ZW50RmlsdGVyID0gbmFtZSA9PiAhaW50ZXJuYWxFdmVudHMuaW5jbHVkZXMobmFtZSk7XG5mdW5jdGlvbiBnZXRSYXdMaXN0ZW5lcnMoZXZlbnRFbWl0dGVyLCBuYW1lKSB7XG4gIC8vIHByZWZlciBuYXRpdmVcbiAgcmV0dXJuIHR5cGVvZiBldmVudEVtaXR0ZXIucmF3TGlzdGVuZXJzICE9PSBcInVuZGVmaW5lZFwiID8gZXZlbnRFbWl0dGVyLnJhd0xpc3RlbmVycyhuYW1lKSA6IGV2ZW50RW1pdHRlci5saXN0ZW5lcnMobmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudEVtaXR0ZXJQcm94eShpbml0aWFsVGFyZ2V0LCBvcHRzKSB7XG4gIC8vIHBhcnNlIG9wdGlvbnNcbiAgY29uc3QgZmluYWxPcHRzID0gb3B0cyB8fCB7fTtcbiAgbGV0IGV2ZW50RmlsdGVyID0gZmluYWxPcHRzLmV2ZW50RmlsdGVyIHx8IGZpbHRlck5vb3A7XG4gIGlmICh0eXBlb2YgZXZlbnRGaWx0ZXIgPT09IFwic3RyaW5nXCIgJiYgZXZlbnRGaWx0ZXIgPT09IFwic2tpcEludGVybmFsXCIpIGV2ZW50RmlsdGVyID0gZXh0ZXJuYWxFdmVudEZpbHRlcjtcbiAgaWYgKHR5cGVvZiBldmVudEZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJjcmVhdGVFdmVudEVtaXR0ZXJQcm94eSAtIEludmFsaWQgZXZlbnRGaWx0ZXJcIik7XG4gIGxldCB0YXJnZXQgPSBpbml0aWFsVGFyZ2V0O1xuICBsZXQgc2V0VGFyZ2V0ID0gbmV3VGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvbGRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0O1xuICAgIG9sZFRhcmdldC5ldmVudE5hbWVzKCkuZmlsdGVyKGV2ZW50RmlsdGVyKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgZ2V0UmF3TGlzdGVuZXJzKG9sZFRhcmdldCwgbmFtZSkuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgICAgbmV3VGFyZ2V0Lm9uKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgb2xkIGxpc3RlbmVyc1xuICAgIG9sZFRhcmdldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICBnZXQ6IChfLCBuYW1lKSA9PiB7XG4gICAgICAvLyBvdmVycmlkZSBgc2V0VGFyZ2V0YCBhY2Nlc3NcbiAgICAgIGlmIChuYW1lID09PSBcInNldFRhcmdldFwiKSByZXR1cm4gc2V0VGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSBcInNldFRhcmdldFwiKSB7XG4gICAgICAgIHNldFRhcmdldCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTd2FwcGFibGVQcm94eShpbml0aWFsVGFyZ2V0KSB7XG4gIGxldCB0YXJnZXQgPSBpbml0aWFsVGFyZ2V0O1xuICBsZXQgc2V0VGFyZ2V0ID0gbmV3VGFyZ2V0ID0+IHtcbiAgICB0YXJnZXQgPSBuZXdUYXJnZXQ7XG4gIH07XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikgcmV0dXJuIHNldFRhcmdldDtcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV07XG4gICAgfSxcbiAgICBzZXQ6IChfLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgLy8gYWxsb3cgYHNldFRhcmdldGAgb3ZlcnJpZGVzXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm94eTtcbn1cblxuLy8gZXZlcnkgdGVuIG1pbnV0ZXNcbmNvbnN0IFBPTExJTkdfSU5URVJWQUwgPSA2MDAwMDA7XG5jbGFzcyBCYXNlQ3VycmVuY3lDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnID0ge30sXG4gICAgc3RhdGVcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICBjdXJyZW50Q3VycmVuY3k6IFwidXNkXCIsXG4gICAgICBjb252ZXJzaW9uUmF0ZTogMCxcbiAgICAgIGNvbnZlcnNpb25EYXRlOiBcIk4vQVwiLFxuICAgICAgbmF0aXZlQ3VycmVuY3k6IFwiRVRIXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIHBvbGxJbnRlcnZhbDogUE9MTElOR19JTlRFUlZBTFxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvL1xuICAvLyBQVUJMSUMgTUVUSE9EU1xuICAvL1xuXG4gIGdldE5hdGl2ZUN1cnJlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm5hdGl2ZUN1cnJlbmN5O1xuICB9XG4gIHNldE5hdGl2ZUN1cnJlbmN5KG5hdGl2ZUN1cnJlbmN5KSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgbmF0aXZlQ3VycmVuY3ksXG4gICAgICB0aWNrZXI6IG5hdGl2ZUN1cnJlbmN5XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q3VycmVudEN1cnJlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRDdXJyZW5jeTtcbiAgfVxuICBzZXRDdXJyZW50Q3VycmVuY3koY3VycmVudEN1cnJlbmN5KSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgY3VycmVudEN1cnJlbmN5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBjb252ZXJzaW9uUmF0ZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgY29udmVyc2lvbiByYXRlIGZyb20gRVRIIHRvIHRoZSBzZWxlY3RlZCBjdXJyZW5jeS5cbiAgICpcbiAgICovXG4gIGdldENvbnZlcnNpb25SYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnZlcnNpb25SYXRlO1xuICB9XG4gIHNldENvbnZlcnNpb25SYXRlKGNvbnZlcnNpb25SYXRlKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgY29udmVyc2lvblJhdGVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlIGNvbnZlcnNpb25EYXRlIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBkYXRlIGF0IHdoaWNoIHRoZSBjb252ZXJzaW9uIHJhdGUgd2FzIHNldC4gRXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcyBzaW5jZSBtaWRuaWdodCBvZlxuICAgKiBKYW51YXJ5IDEsIDE5NzBcbiAgICpcbiAgICovXG4gIGdldENvbnZlcnNpb25EYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnZlcnNpb25EYXRlO1xuICB9XG4gIHNldENvbnZlcnNpb25EYXRlKGNvbnZlcnNpb25EYXRlKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgY29udmVyc2lvbkRhdGVcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XID0ge1xuICBoZWlnaHQ6IDY2MCxcbiAgd2lkdGg6IDM3NVxufTtcbmNvbnN0IEZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA3NDAsXG4gIHdpZHRoOiAxMzE1XG59O1xuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cgPSB7XG4gIGhlaWdodDogNzAwLFxuICB3aWR0aDogMTIwMFxufTtcbmNvbnN0IEZFQVRVUkVTX0NPTkZJUk1fV0lORE9XID0ge1xuICBoZWlnaHQ6IDcwMCxcbiAgd2lkdGg6IDQ1MFxufTtcbmNvbnN0IFBPUFVQX0xPQURFRCA9IFwicG9wdXBfbG9hZGVkXCI7XG5jb25zdCBQT1BVUF9SRVNVTFQgPSBcInBvcHVwX3Jlc3VsdFwiO1xuY29uc3QgU0VUVVBfQ09NUExFVEUgPSBcInNldHVwX2NvbXBsZXRlXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQUxMID0gXCJ3YWxsZXRBY3Rpdml0eS5hbGxUcmFuc2FjdGlvbnNcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9TRU5EID0gXCJ3YWxsZXRBY3Rpdml0eS5zZW5kXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQlVSTiA9IFwid2FsbGV0QWN0aXZpdHkuYnVyblwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX1JFQ0VJVkUgPSBcIndhbGxldEFjdGl2aXR5LnJlY2VpdmVcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9UT1BVUCA9IFwid2FsbGV0QWN0aXZpdHkudG9wdXBcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9DUkVBVEVfVFJVU1RMSU5FID0gXCJ3YWxsZXRBY3Rpdml0eS5jcmVhdGVUcnVzdGxpbmVcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9SRU1PVkVfVFJVU1RMSU5FID0gXCJ3YWxsZXRBY3Rpdml0eS5yZW1vdmVUcnVzdGxpbmVcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9DUkVBVEVfTkZUX09GRkVSID0gXCJ3YWxsZXRBY3Rpdml0eS5jcmVhdGVOZnRPZmZlclwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX0FDQ0VQVF9ORlRfT0ZGRVIgPSBcIndhbGxldEFjdGl2aXR5LmFjY2VwdE5mdE9mZmVyXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQ0FOQ0VMX05GVF9PRkZFUiA9IFwid2FsbGV0QWN0aXZpdHkuY2FuY2VsTmZ0T2ZmZXJcIjtcbmNvbnN0IEFDVElWSVRZX1BFUklPRF9BTEwgPSBcIndhbGxldEFjdGl2aXR5LmFsbFwiO1xuY29uc3QgQUNUSVZJVFlfUEVSSU9EX1dFRUtfT05FID0gXCJ3YWxsZXRBY3Rpdml0eS5sYXN0T25lV2Vla1wiO1xuY29uc3QgQUNUSVZJVFlfUEVSSU9EX01PTlRIX09ORSA9IFwid2FsbGV0QWN0aXZpdHkubGFzdE9uZU1vbnRoXCI7XG5jb25zdCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfU0lYID0gXCJ3YWxsZXRBY3Rpdml0eS5sYXN0U2l4TW9udHNcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19TVUNDRVNTRlVMID0gXCJ3YWxsZXRBY3Rpdml0eS5zdWNjZXNzZnVsXCI7XG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfVU5TVUNDRVNTRlVMID0gXCJ3YWxsZXRBY3Rpdml0eS51bnN1Y2Nlc3NmdWxcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19QRU5ESU5HID0gXCJ3YWxsZXRBY3Rpdml0eS5wZW5kaW5nXCI7XG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTEVEID0gXCJ3YWxsZXRBY3Rpdml0eS5jYW5jZWxsZWRcIjtcbmNvbnN0IEFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HID0gXCJ3YWxsZXRBY3Rpdml0eS5jYW5jZWxsaW5nXCI7XG5jb25zdCBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMgPSB7XG4gIElGUkFNRV9TVEFUVVM6IFwiaWZyYW1lX3N0YXR1c1wiLFxuICAvLyBUZWxsIGVtYmVkIHRvIGNsb3NlIHRoZSB3aW5kb3dcbiAgQ0xPU0VfV0lORE9XOiBcImNsb3NlX3dpbmRvd1wiLFxuICBVU0VSX0xPR0dFRF9JTjogXCJ1c2VyX2xvZ2dlZF9pblwiLFxuICBVU0VSX0xPR0dFRF9PVVQ6IFwidXNlcl9sb2dnZWRfb3V0XCJcbn07XG5jb25zdCBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUyA9IHtcbiAgTE9HT1VUOiBcImxvZ291dFwiLFxuICBXQUxMRVRfSU5TVEFOQ0VfSUQ6IFwid2FsbGV0X2luc3RhbmNlX2lkXCIsXG4gIFVTRVJfSU5GTzogXCJ1c2VyX2luZm9cIixcbiAgU0VUX1BST1ZJREVSOiBcInNldF9wcm92aWRlclwiLFxuICBUT1BVUDogXCJ0b3B1cFwiLFxuICBJRlJBTUVfU1RBVFVTOiBcImlmcmFtZV9zdGF0dXNcIixcbiAgLy8gdXNlciBoYXMgY2xvc2VkIHRoZSB3aW5kb3cgZnJvbSBlbWJlZCdzIHNpZGVcbiAgQ0xPU0VEX1dJTkRPVzogXCJjbG9zZWRfd2luZG93XCIsXG4gIFdJTkRPV19CTE9DS0VEOiBcIndpbmRvd19ibG9ja2VkXCIsXG4gIEdFVF9QUk9WSURFUl9TVEFURTogXCJnZXRfcHJvdmlkZXJfc3RhdGVcIixcbiAgTE9HSU5fV0lUSF9QUklWQVRFX0tFWTogXCJsb2dpbl93aXRoX3ByaXZhdGVfa2V5XCIsXG4gIFNIT1dfV0FMTEVUX0NPTk5FQ1Q6IFwic2hvd193YWxsZXRfY29ubmVjdFwiLFxuICBTSE9XX0NIRUNLT1VUOiBcInNob3dfY2hlY2tvdXRcIixcbiAgU0hPV19XQUxMRVRfVUk6IFwic2hvd193YWxsZXRfdWlcIixcbiAgTE9HSU5fV0lUSF9TRVNTSU9OX0lEOiBcImxvZ2luX3dpdGhfc2Vzc2lvbl9pZFwiXG59O1xuY29uc3QgUFJPVklERVJfSlJQQ19NRVRIT0RTID0ge1xuICBHRVRfUFJPVklERVJfU1RBVEU6IFwid2FsbGV0X2dldF9wcm92aWRlcl9zdGF0ZVwiXG59O1xuY29uc3QgUFJPVklERVJfTk9USUZJQ0FUSU9OUyA9IHtcbiAgQUNDT1VOVFNfQ0hBTkdFRDogXCJ3YWxsZXRfYWNjb3VudHNfY2hhbmdlZFwiLFxuICBDSEFJTl9DSEFOR0VEOiBcIndhbGxldF9jaGFpbl9jaGFuZ2VkXCIsXG4gIFVOTE9DS19TVEFURV9DSEFOR0VEOiBcIndhbGxldF91bmxvY2tfc3RhdGVfY2hhbmdlZFwiXG59O1xuY29uc3QgQlJPQURDQVNUX0NIQU5ORUxTID0ge1xuICBSRURJUkVDVF9DSEFOTkVMOiBcInJlZGlyZWN0X2NoYW5uZWxcIixcbiAgUFJPVklERVJfQ0hBTkdFX0NIQU5ORUw6IFwidG9ydXNfcHJvdmlkZXJfY2hhbmdlX2NoYW5uZWxcIixcbiAgVFJBTlNBQ1RJT05fQ0hBTk5FTDogXCJ0b3J1c19jaGFubmVsXCIsXG4gIE1FU1NBR0VfQ0hBTk5FTDogXCJ0b3J1c19tZXNzYWdlX2NoYW5uZWxcIixcbiAgV0FMTEVUX0xPR09VVF9DSEFOTkVMOiBcIndhbGxldF9sb2dvdXRfY2hhbm5lbFwiLFxuICBXQUxMRVRfU0VMRUNURURfQUREUkVTU19DSEFOTkVMOiBcIndhbGxldF9zZWxlY3RlZF9hZGRyZXNzX2NoYW5uZWxcIixcbiAgV0FMTEVUX05FVFdPUktfQ0hBTkdFX0NIQU5ORUw6IFwid2FsbGV0X25ldHdvcmtfY2hhbmdlX2NoYW5uZWxcIixcbiAgV0FMTEVUX0FDQ09VTlRfSU1QT1JUX0NIQU5ORUw6IFwid2FsbGV0X2FjY291bnRfaW1wb3J0X2NoYW5uZWxcIixcbiAgVEhFTUVfQ0hBTkdFOiBcInRoZW1lX2NoYW5nZV9jaGFubmVsXCIsXG4gIFRPUF9VUF9DSEFOTkVMOiBcInRvcF91cF9jaGFubmVsXCJcbn07XG5jb25zdCBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUyA9IHtcbiAgTE9HT1VUOiBcImxvZ291dFwiLFxuICBBQ0NPVU5UX0lNUE9SVEVEOiBcImFjY291bnRfaW1wb3J0ZWRcIixcbiAgU0VMRUNURURfQUREUkVTU19DSEFOR0U6IFwic2VsZWN0ZWRfYWRkcmVzc19jaGFuZ2VcIixcbiAgTkVUV09SS19DSEFOR0U6IFwibmV0d29ya19jaGFuZ2VcIixcbiAgU0VUX1RIRU1FOiBcInNldF90aGVtZVwiXG59O1xubGV0IENvbnRyb2xsZXJFdmVudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKENvbnRyb2xsZXJFdmVudHMpIHtcbiAgQ29udHJvbGxlckV2ZW50c1tcIlVzZXJVbmF1dGhvcml6ZWRcIl0gPSBcInVzZXIudW5hdXRob3JpemVkXCI7XG4gIHJldHVybiBDb250cm9sbGVyRXZlbnRzO1xufSh7fSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYW5nZVByb3ZpZGVyTWlkZGxld2FyZU1pZGRsZXdhcmUoe1xuICBjaGFuZ2VQcm92aWRlclxufSkge1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGhvZFxuICAgIH0gPSByZXF1ZXN0O1xuICAgIGlmIChtZXRob2QgIT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNFVF9QUk9WSURFUikgcmV0dXJuIG5leHQoKTtcbiAgICBpZiAoIWNoYW5nZVByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDb21tdW5pY2F0aW9uTWlkZGxld2FyZSAtIG9wdHMuY2hhbmdlUHJvdmlkZXIgbm90IHByb3ZpZGVkXCIpO1xuICAgIHJlc3BvbnNlLnJlc3VsdCA9IGF3YWl0IGNoYW5nZVByb3ZpZGVyKHJlcXVlc3QpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvcHVwTWlkZGxld2FyZSh7XG4gIHRvcHVwXG59KSB7XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbWV0aG9kXG4gICAgfSA9IHJlcXVlc3Q7XG4gICAgaWYgKG1ldGhvZCAhPT0gQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuVE9QVVApIHJldHVybiBuZXh0KCk7XG4gICAgaWYgKCF0b3B1cCkgdGhyb3cgbmV3IEVycm9yKFwiQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUgLSBvcHRzLnRvcHVwIG5vdCBwcm92aWRlZFwiKTtcbiAgICByZXNwb25zZS5yZXN1bHQgPSBhd2FpdCB0b3B1cChyZXF1ZXN0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVHZW5lcmljSlJQQ01pZGRsZXdhcmUodGFyZ2V0TWV0aG9kLCBoYW5kbGVyKSB7XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbWV0aG9kXG4gICAgfSA9IHJlcXVlc3Q7XG4gICAgaWYgKG1ldGhvZCAhPT0gdGFyZ2V0TWV0aG9kKSByZXR1cm4gbmV4dCgpO1xuICAgIGlmICghaGFuZGxlcikgdGhyb3cgbmV3IEVycm9yKGBDb21tdW5pY2F0aW9uTWlkZGxld2FyZSAtICR7dGFyZ2V0TWV0aG9kfSBub3QgcHJvdmlkZWRgKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKHJlcXVlc3QpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgICByZXNwb25zZS5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZShwcm92aWRlckhhbmRsZXJzKSB7XG4gIGNvbnN0IHtcbiAgICBnZXRVc2VySW5mbyxcbiAgICBnZXRXYWxsZXRJbnN0YW5jZUlkLFxuICAgIHRvcHVwLFxuICAgIGxvZ291dCxcbiAgICBjaGFuZ2VQcm92aWRlcixcbiAgICBzZXRJRnJhbWVTdGF0dXMsXG4gICAgaGFuZGxlV2luZG93UnBjLFxuICAgIGdldFByb3ZpZGVyU3RhdGUsXG4gICAgbG9naW5XaXRoUHJpdmF0ZUtleSxcbiAgICBzaG93V2FsbGV0Q29ubmVjdCxcbiAgICBzaG93Q2hlY2tvdXQsXG4gICAgc2hvd1dhbGxldFVpLFxuICAgIHNob3dXaW5kb3dCbG9ja0FsZXJ0LFxuICAgIGxvZ2luV2l0aFNlc3Npb25JZFxuICB9ID0gcHJvdmlkZXJIYW5kbGVycztcbiAgcmV0dXJuIG1lcmdlTWlkZGxld2FyZShbY3JlYXRlQ2hhbmdlUHJvdmlkZXJNaWRkbGV3YXJlTWlkZGxld2FyZSh7XG4gICAgY2hhbmdlUHJvdmlkZXJcbiAgfSksIGNyZWF0ZVRvcHVwTWlkZGxld2FyZSh7XG4gICAgdG9wdXBcbiAgfSksIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSh7XG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkxPR09VVF06IGxvZ291dCxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuV0FMTEVUX0lOU1RBTkNFX0lEXTogZ2V0V2FsbGV0SW5zdGFuY2VJZCxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuVVNFUl9JTkZPXTogZ2V0VXNlckluZm8sXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLklGUkFNRV9TVEFUVVNdOiBzZXRJRnJhbWVTdGF0dXMsXG4gICAgLy8gRG8gdGhpcyBpbiB0aGUgb3JjaGVzdHJhdG9yIGJlY2F1c2UgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIgbmVlZHMgdG8gYmUgcGFzc2VkIGludG8gUG9wdXBIYW5kbGVyc1xuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5DTE9TRURfV0lORE9XXTogaGFuZGxlV2luZG93UnBjLFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5HRVRfUFJPVklERVJfU1RBVEVdOiBnZXRQcm92aWRlclN0YXRlLFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5TSE9XX1dBTExFVF9DT05ORUNUXTogc2hvd1dhbGxldENvbm5lY3QsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNIT1dfQ0hFQ0tPVVRdOiBzaG93Q2hlY2tvdXQsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNIT1dfV0FMTEVUX1VJXTogc2hvd1dhbGxldFVpLFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5XSU5ET1dfQkxPQ0tFRF06IHNob3dXaW5kb3dCbG9ja0FsZXJ0XG4gIH0pLCBjcmVhdGVHZW5lcmljSlJQQ01pZGRsZXdhcmUoQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuTE9HSU5fV0lUSF9QUklWQVRFX0tFWSwgbG9naW5XaXRoUHJpdmF0ZUtleSksIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZShDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5MT0dJTl9XSVRIX1NFU1NJT05fSUQsIGxvZ2luV2l0aFNlc3Npb25JZCldKTtcbn1cblxuY2xhc3MgQmFzZUVtYmVkQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyA9IHt9LFxuICAgIHN0YXRlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eVwiLCB2b2lkIDApO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgaXNJRnJhbWVGdWxsU2NyZWVuOiB0cnVlLFxuICAgICAgb2F1dGhNb2RhbFZpc2liaWxpdHk6IGZhbHNlLFxuICAgICAgbG9naW5JblByb2dyZXNzOiBmYWxzZSxcbiAgICAgIGRhcHBNZXRhZGF0YToge1xuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICBpY29uOiBcIlwiXG4gICAgICB9LFxuICAgICAgd2ViM0F1dGhDbGllbnRJZDogXCJcIixcbiAgICAgIHdlYjNBdXRoTmV0d29yazogXCJtYWlubmV0XCIsXG4gICAgICB3aGl0ZUxhYmVsOiBudWxsLFxuICAgICAgY29uZmlybWF0aW9uU3RyYXRlZ3k6IFwicG9wdXBcIlxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGJ5IG9yY2hlc3RyYXRvciBvbmNlIHdoaWxlIGluaXRpYWxpemluZyB0aGUgY2xhc3NcbiAgICogQHBhcmFtIGhhbmRsZXJzIC0gSlJQQyBoYW5kbGVycyBmb3IgcHJvdmlkZXJcbiAgICogQHJldHVybnMgLSBwcm92aWRlciAtIFJldHVybnMgdGhlIHByb3ZpZGVyUHJveHlcbiAgICovXG4gIGluaXRpYWxpemVQcm92aWRlcihoYW5kbGVycykge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gICAgY29uc3QgY29tbXVuaWNhdGlvbk1pZGRsZXdhcmUgPSBjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZShoYW5kbGVycyk7XG4gICAgZW5naW5lLnB1c2goY29tbXVuaWNhdGlvbk1pZGRsZXdhcmUpO1xuICAgIGNvbnN0IGNvbW11bmljYXRpb25Qcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICAgIHRoaXMuc2V0Q29tbXVuaWNhdGlvblByb3ZpZGVyKGNvbW11bmljYXRpb25Qcm92aWRlcik7XG4gIH1cbiAgc2V0Q29tbXVuaWNhdGlvblByb3ZpZGVyKGNvbW11bmljYXRpb25Qcm92aWRlcikge1xuICAgIGlmICh0aGlzLl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5fY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHkuc2V0VGFyZ2V0KGNvbW11bmljYXRpb25Qcm92aWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5ID0gY3JlYXRlU3dhcHBhYmxlUHJveHkoY29tbXVuaWNhdGlvblByb3ZpZGVyKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQ29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZVdpbmRvd1JwY1wiLCAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfSA9IHJlcXVlc3Q7XG4gICAgICBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5DTE9TRURfV0lORE9XKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICAvLyBJJ3ZlIGJlZW4gaW5mb3JtZWQgdGhhdCBhIHdpbmRvdyBoYXMgYmVlbiBjbG9zZWRcbiAgICAgICAgdGhpcy5lbWl0KGAke3dpbmRvd0lkfTpjbG9zZWRgKTtcbiAgICAgICAgcmVzcG9uc2UucmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgQlVUVE9OX1BPU0lUSU9OID0ge1xuICBCT1RUT01fTEVGVDogXCJib3R0b20tbGVmdFwiLFxuICBUT1BfTEVGVDogXCJ0b3AtbGVmdFwiLFxuICBCT1RUT01fUklHSFQ6IFwiYm90dG9tLXJpZ2h0XCIsXG4gIFRPUF9SSUdIVDogXCJ0b3AtcmlnaHRcIlxufTtcbmNvbnN0IENPTkZJUk1BVElPTl9TVFJBVEVHWSA9IHtcbiAgUE9QVVA6IFwicG9wdXBcIixcbiAgTU9EQUw6IFwibW9kYWxcIixcbiAgQVVUT19BUFBST1ZFOiBcImF1dG8tYXBwcm92ZVwiLFxuICBERUZBVUxUOiBcImRlZmF1bHRcIlxufTtcblxuLyoqXG4gKiBTdGF0ZSBjaGFuZ2UgY2FsbGJhY2tzXG4gKi9cblxuLyoqXG4gKiBCYXNlIGNvbnRyb2xsZXIgY29uZmlndXJhdGlvblxuICovXG5cbi8qKlxuICogQmFzZSBzdGF0ZSByZXByZXNlbnRhdGlvblxuICovXG5cbmNvbnN0IExPR0lOX1BST1ZJREVSID0ge1xuICBHT09HTEU6IFwiZ29vZ2xlXCIsXG4gIEZBQ0VCT09LOiBcImZhY2Vib29rXCIsXG4gIFJFRERJVDogXCJyZWRkaXRcIixcbiAgRElTQ09SRDogXCJkaXNjb3JkXCIsXG4gIFRXSVRDSDogXCJ0d2l0Y2hcIixcbiAgQVBQTEU6IFwiYXBwbGVcIixcbiAgTElORTogXCJsaW5lXCIsXG4gIEdJVEhVQjogXCJnaXRodWJcIixcbiAgS0FLQU86IFwia2FrYW9cIixcbiAgTElOS0VESU46IFwibGlua2VkaW5cIixcbiAgVFdJVFRFUjogXCJ0d2l0dGVyXCIsXG4gIFdFSUJPOiBcIndlaWJvXCIsXG4gIFdFQ0hBVDogXCJ3ZWNoYXRcIixcbiAgRU1BSUxfUEFTU1dPUkRMRVNTOiBcImVtYWlsX3Bhc3N3b3JkbGVzc1wiLFxuICBTTVNfUEFTU1dPUkRMRVNTOiBcInNtc19wYXNzd29yZGxlc3NcIlxufTtcbi8qKlxuICoge0BsYWJlbCBsb2dpblByb3ZpZGVyVHlwZX1cbiAqL1xuXG5jb25zdCBQQVlNRU5UX1BST1ZJREVSID0ge1xuICBNT09OUEFZOiBcIm1vb25wYXlcIixcbiAgV1lSRTogXCJ3eXJlXCIsXG4gIFJBTVBORVRXT1JLOiBcInJhbXBuZXR3b3JrXCIsXG4gIFhBTlBPT0w6IFwieGFucG9vbFwiLFxuICBNRVJDVVJZTzogXCJtZXJjdXJ5b1wiLFxuICBUUkFOU0FLOiBcInRyYW5zYWtcIlxufTtcblxuZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgdG8gc3RvcmUgdGhlIHJlc3VsdHNcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBvd24gcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICBpZiAoIXByZWRpY2F0ZSh2YWx1ZSwga2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHRzXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNsb25lRGVlcChvYmplY3QpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG4gIH1cbn1cblxuY29uc3QgYXV0aFNlcnZlciA9IFwiaHR0cHM6Ly9hdXRoanMud2ViM2F1dGguaW9cIjtcbmNvbnN0IHNpZ25DaGFsbGVuZ2UgPSBhc3luYyAocGF5bG9hZCwgY2hhaW5OYW1lc3BhY2UpID0+IHtcbiAgY29uc3QgdCA9IGNoYWluTmFtZXNwYWNlID09PSBcInNvbGFuYVwiID8gXCJzaXA5OVwiIDogXCJlaXAxOTFcIjtcbiAgY29uc3QgaGVhZGVyID0ge1xuICAgIHRcbiAgfTtcbiAgY29uc3QgbmV0d29yayA9IGNoYWluTmFtZXNwYWNlID09PSBcInNvbGFuYVwiID8gXCJzb2xhbmFcIiA6IFwiZXRoZXJldW1cIjtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBwYXlsb2FkLFxuICAgIGhlYWRlcixcbiAgICBuZXR3b3JrXG4gIH07XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHBvc3QoYCR7YXV0aFNlcnZlcn0vc2l3dy9nZXRgLCBkYXRhKTtcbiAgaWYgKCFyZXMuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhdXRoZW50aWNhdGUgdXNlciwgUGxlYXNlIHJlYWNoIG91dCB0byBXZWIzQXV0aCBTdXBwb3J0IHRlYW1cIik7XG4gIH1cbiAgcmV0dXJuIHJlcy5jaGFsbGVuZ2U7XG59O1xuY29uc3QgdmVyaWZ5U2lnbmVkQ2hhbGxlbmdlID0gYXN5bmMgKGNoYWluTmFtZXNwYWNlLCBzaWduZWRNZXNzYWdlLCBjaGFsbGVuZ2UsIGlzc3Vlciwgc2Vzc2lvblRpbWUsIGNsaWVudElkLCB3ZWIzQXV0aE5ldHdvcmssIGF1ZGllbmNlLCBhZGRpdGlvbmFsTWV0YWRhdGEpID0+IHtcbiAgdmFyIF93aW5kb3ckbG9jYXRpb247XG4gIGNvbnN0IHQgPSBjaGFpbk5hbWVzcGFjZSA9PT0gXCJzb2xhbmFcIiA/IFwic2lwOTlcIiA6IFwiZWlwMTkxXCI7XG4gIGNvbnN0IHNpZ0RhdGEgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBzaWduYXR1cmU6IHtcbiAgICAgIHM6IHNpZ25lZE1lc3NhZ2UsXG4gICAgICB0XG4gICAgfSxcbiAgICBtZXNzYWdlOiBjaGFsbGVuZ2UsXG4gICAgaXNzdWVyLFxuICAgIGF1ZGllbmNlOiBhdWRpZW5jZSB8fCAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/ICgoX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbikgPT09IG51bGwgfHwgX3dpbmRvdyRsb2NhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdyRsb2NhdGlvbi5ob3N0bmFtZSkgfHwgXCJjb206Ly9yZWFjdG5hdGl2ZVwiIDogXCJjb206Ly9yZWFjdG5hdGl2ZVwiKSxcbiAgICB0aW1lb3V0OiBzZXNzaW9uVGltZVxuICB9LCBhZGRpdGlvbmFsTWV0YWRhdGEgfHwge30pO1xuICBjb25zdCBpZFRva2VuUmVzID0gYXdhaXQgcG9zdChgJHthdXRoU2VydmVyfS9zaXd3L3ZlcmlmeWAsIHNpZ0RhdGEsIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgd2FsbGV0X3Byb3ZpZGVyOiBpc3N1ZXIsXG4gICAgICB3ZWIzYXV0aF9uZXR3b3JrOiB3ZWIzQXV0aE5ldHdvcmtcbiAgICB9XG4gIH0pO1xuICBpZiAoIWlkVG9rZW5SZXMuc3VjY2Vzcykge1xuICAgIGxvZy5lcnJvcihcIkZhaWxlZCB0byBhdXRoZW50aWNhdGUgdXNlciwgLG1lc3NhZ2UgdmVyaWZpY2F0aW9uIGZhaWxlZFwiLCBpZFRva2VuUmVzLmVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gYXV0aGVudGljYXRlIHVzZXIsICxtZXNzYWdlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIik7XG4gIH1cbiAgcmV0dXJuIGlkVG9rZW5SZXMudG9rZW47XG59O1xuXG5jb25zdCBnZXRUeFN0YXR1c1RleHQgPSB0eFN0YXR1cyA9PiB7XG4gIHN3aXRjaCAodHhTdGF0dXMpIHtcbiAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICBjYXNlIFwidW5hcHByb3ZlZFwiOlxuICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgIHJldHVybiBBQ1RJVklUWV9TVEFUVVNfVU5TVUNDRVNTRlVMO1xuICAgIGNhc2UgXCJjb25maXJtZWRcIjpcbiAgICAgIHJldHVybiBBQ1RJVklUWV9TVEFUVVNfU1VDQ0VTU0ZVTDtcbiAgICBjYXNlIFwic3VibWl0dGVkXCI6XG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkc7XG4gICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgcmV0dXJuIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMRUQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0eSBmdW5jdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIGNvbnN0IGhleCA9IGkudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gYDB4JHtoZXh9YDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci4gRG9uJ3QgdXNlIGZvciBjcnlwdG9ncmFwaGljIHB1cnBvc2VzLlxuICogQHJldHVybnMgYSByYW5kb20gbnVtYmVyXG4gKi9cbmNvbnN0IHJhbmRvbUlkID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbi8qKlxuICogUGFkcyB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIGhleCBzdHJpbmcgd2l0aCB6ZXJvZXMgdW50aWwgaXQgcmVhY2hlcyB0aGVcbiAqIHRhcmdldCBsZW5ndGguIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgYWxyZWFkeSBsb25nZXIgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAqIHRhcmdldCBsZW5ndGgsIGl0IGlzIHJldHVybmVkIHVubW9kaWZpZWQuXG4gKlxuICogSWYgdGhlIGlucHV0IHN0cmluZyBpcyBcIjB4XCItcHJlZml4ZWQgb3Igbm90IGEgaGV4IHN0cmluZywgYW4gZXJyb3Igd2lsbCBiZVxuICogdGhyb3duLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHBhZCB3aXRoIHplcm9lcy5cbiAqIEBwYXJhbSB0YXJnZXRMZW5ndGggLSBUaGUgdGFyZ2V0IGxlbmd0aCBvZiB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGlucHV0IHN0cmluZyBmcm9udC1wYWRkZWQgd2l0aCB6ZXJvZXMsIG9yIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIGlmIGl0IHdhcyBhbHJlYWR5IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0byB0aGUgdGFyZ2V0IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gcGFkV2l0aFplcm9lcyhoZXhTdHJpbmcsIHRhcmdldExlbmd0aCkge1xuICBpZiAoaGV4U3RyaW5nICE9PSBcIlwiICYmICEvXlthLWYwLTldKyQvaXUudGVzdChoZXhTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiB1bnByZWZpeGVkIGhleCBzdHJpbmcuIFJlY2VpdmVkOiAke2hleFN0cmluZ31gKTtcbiAgfVxuICBpZiAodGFyZ2V0TGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBub24tbmVnYXRpdmUgaW50ZWdlciB0YXJnZXQgbGVuZ3RoLiBSZWNlaXZlZDogJHt0YXJnZXRMZW5ndGh9YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQuY2FsbChoZXhTdHJpbmcsIHRhcmdldExlbmd0aCwgXCIwXCIpO1xufVxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBleHRlbmRlZCBFQ0RTQSBzaWduYXR1cmUgaW50byBhIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgJ3YnIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSByIC0gVGhlICdyJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gcyAtIFRoZSAncycgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBFQ0RTQSBzaWduYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdFNpZyh2LCByLCBzKSB7XG4gIGNvbnN0IHJTaWcgPSBmcm9tU2lnbmVkKHIpO1xuICBjb25zdCBzU2lnID0gZnJvbVNpZ25lZChzKTtcbiAgY29uc3QgdlNpZyA9IGJ5dGVzVG9CaWdJbnQodik7XG4gIGNvbnN0IHJTdHIgPSBwYWRXaXRoWmVyb2VzKEJ1ZmZlci5mcm9tKHRvVW5zaWduZWQoclNpZykpLnRvU3RyaW5nKFwiaGV4XCIpLCA2NCk7XG4gIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKEJ1ZmZlci5mcm9tKHRvVW5zaWduZWQoc1NpZykpLnRvU3RyaW5nKFwiaGV4XCIpLCA2NCk7XG4gIGNvbnN0IHZTdHIgPSBzdHJpcEhleFByZWZpeChiaWdJbnRUb0hleCh2U2lnKSk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpO1xufVxuZnVuY3Rpb24gdGltZW91dCQxKGR1cmF0aW9uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjb25zdCB0aW1lb3V0UmVmID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0UmVmKTtcbiAgICB9LCBkdXJhdGlvbik7XG4gIH0pO1xufVxuY29uc3QgZ2V0SGVhZGVycyA9IChqd3QsIHB1YmxpY0FkZHJlc3MpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7and0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIFwicHVibGljLWFkZHJlc3NcIjogcHVibGljQWRkcmVzc1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogVGV4dC9udW1iZXIgZm9ybWF0dGluZyB1dGlsaXRpZXNcbiAqL1xuY29uc3QgZm9ybWF0U21hbGxOdW1iZXJzID0gKG51bWJlciwgY3VycmVuY3kgPSBcInVzZFwiLCBub1RpbGRlID0gZmFsc2UpID0+IHtcbiAgY29uc3QgZmluYWxOdW1iZXIgPSBCaWdOdW1iZXIuaXNCaWdOdW1iZXIobnVtYmVyKSA/IG51bWJlci50b051bWJlcigpIDogbnVtYmVyO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmaW5hbE51bWJlcikpIHJldHVybiBcIlwiO1xuICBjb25zdCB2YWx1ZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlKCkgPT09IFwidXNkXCIgPyBwYXJzZUZsb2F0KE51bWJlcihmaW5hbE51bWJlcikudG9GaXhlZCgyKSkgOiBwYXJzZUZsb2F0KE51bWJlcihmaW5hbE51bWJlcikudG9GaXhlZCg1KSk7XG4gIGNvbnN0IHRpbGRlID0gdmFsdWUgPiAwID8gXCJ+IFwiIDogXCJcIjtcbiAgcmV0dXJuIGAke2N1cnJlbmN5LnRvTG93ZXJDYXNlKCkgPT09IFwidXNkXCIgfHwgbm9UaWxkZSA/IFwiXCIgOiB0aWxkZX0ke051bWJlcih2YWx1ZSl9ICR7Y3VycmVuY3kudG9VcHBlckNhc2UoKX1gO1xufTtcbmNvbnN0IGFkZHJlc3NTbGljZXIgPSAoYWRkcmVzcywgc2xpY2VMZW5ndGggPSA1KSA9PiB7XG4gIGlmICghYWRkcmVzcykgcmV0dXJuIFwiXCI7XG4gIGlmIChhZGRyZXNzLmxlbmd0aCA8IDExKSB7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cbiAgaWYgKHR5cGVvZiBhZGRyZXNzICE9PSBcInN0cmluZ1wiKSByZXR1cm4gXCJcIjtcbiAgcmV0dXJuIGAke2FkZHJlc3Muc2xpY2UoMCwgc2xpY2VMZW5ndGgpfS4uLiR7YWRkcmVzcy5zbGljZSgtc2xpY2VMZW5ndGgpfWA7XG59O1xuY29uc3Qgc2lnbmlmaWNhbnREaWdpdHMgPSAobnVtYmVyLCBwZXJjID0gZmFsc2UsIGxlbmd0aF8gPSAyKSA9PiB7XG4gIGxldCBpbnB1dCA9ICFCaWdOdW1iZXIuaXNCaWdOdW1iZXIobnVtYmVyKSA/IG5ldyBCaWdOdW1iZXIobnVtYmVyKSA6IG51bWJlcjtcbiAgaWYgKGlucHV0LmlzWmVybygpKSByZXR1cm4gaW5wdXQ7XG4gIGlmIChwZXJjKSB7XG4gICAgaW5wdXQgPSBpbnB1dC50aW1lcyhuZXcgQmlnTnVtYmVyKDEwMCkpO1xuICB9XG4gIGxldCBkZXB0aDtcbiAgaWYgKGlucHV0Lmd0ZShuZXcgQmlnTnVtYmVyKDEpKSkge1xuICAgIGRlcHRoID0gbGVuZ3RoXztcbiAgfSBlbHNlIHtcbiAgICBkZXB0aCA9IGxlbmd0aF8gLSAxICsgTWF0aC5jZWlsKE1hdGgubG9nMTAobmV3IEJpZ051bWJlcihcIjFcIikuZGl2KGlucHV0KS50b051bWJlcigpKSk7XG4gIH1cbiAgY29uc3Qgc2hpZnQgPSBuZXcgQmlnTnVtYmVyKDEwKS5wb3cobmV3IEJpZ051bWJlcihkZXB0aCkpO1xuICBjb25zdCByb3VuZGVkTnVtYmVyID0gTWF0aC5yb3VuZChzaGlmdC50aW1lcyhpbnB1dCkudG9OdW1iZXIoKSkgLyBzaGlmdC50b051bWJlcigpO1xuICByZXR1cm4gcm91bmRlZE51bWJlcjtcbn07XG5jb25zdCBmb3JtYXREYXRlID0gaW5wdXREYXRlID0+IHtcbiAgY29uc3QgbW9udGhMaXN0ID0gW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdO1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoaW5wdXREYXRlKTtcbiAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG4gIGNvbnN0IG1vbnRoID0gbW9udGhMaXN0W2RhdGUuZ2V0TW9udGgoKV07XG4gIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIHJldHVybiBgJHtkYXl9ICR7bW9udGh9ICR7eWVhcn1gO1xufTtcbmNvbnN0IGZvcm1hdFRpbWUgPSB0aW1lID0+IHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWUpLnRvVGltZVN0cmluZygpLnNsaWNlKDAsIDgpO1xufTtcblxuLyoqXG4gKiBOZXR3b3JrIHV0aWxpdGllc1xuICovXG5jb25zdCB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrID0gKHRyYW5zYWN0aW9uLCBjaGFpbklkKSA9PiB7XG4gIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uY2hhaW5JZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5jaGFpbklkID09PSBjaGFpbklkO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2lnbmluZyB1dGlsc1xuICovXG5jb25zdCBoYXNoTWVzc2FnZSA9IG1lc3NhZ2UgPT4ge1xuICBjb25zdCBidWZmZXJlZE1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCBcInV0ZjhcIik7XG4gIGNvbnN0IGVsID0gaGFzaFBlcnNvbmFsTWVzc2FnZShidWZmZXJlZE1lc3NhZ2UpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZWwpO1xufTtcbmNvbnN0IHNpZ25NZXNzYWdlID0gYXN5bmMgKHByaXZhdGVLZXksIGRhdGEpID0+IHtcbiAgY29uc3QgcHJpdktleSA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksIFwiaGV4XCIpO1xuICBjb25zdCBtZXNzYWdlID0gc3RyaXBIZXhQcmVmaXgoZGF0YSk7XG4gIGNvbnN0IG1zZ1NpZyA9IGVjc2lnbihCdWZmZXIuZnJvbShtZXNzYWdlLCBcImhleFwiKSwgcHJpdktleSk7XG4gIGNvbnN0IHJhd01zZ1NpZyA9IGNvbmNhdFNpZyhCdWZmZXIuZnJvbShiaWdJbnRUb0J5dGVzKG1zZ1NpZy52KSksIEJ1ZmZlci5mcm9tKG1zZ1NpZy5yKSwgQnVmZmVyLmZyb20obXNnU2lnLnMpKTtcbiAgcmV0dXJuIHJhd01zZ1NpZztcbn07XG5cbi8qKlxuICogcG9wdXAgaGFuZGxlciB1dGlsc1xuICovXG5mdW5jdGlvbiBnZXRQb3B1cEZlYXR1cmVzKHtcbiAgd2lkdGg6IHcsXG4gIGhlaWdodDogaFxufSkge1xuICAvLyBGaXhlcyBkdWFsLXNjcmVlbiBwb3NpdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9zdCBicm93c2VycyAgICAgIEZpcmVmb3hcbiAgY29uc3QgZHVhbFNjcmVlbkxlZnQgPSB3aW5kb3cuc2NyZWVuTGVmdCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlbkxlZnQgOiB3aW5kb3cuc2NyZWVuWDtcbiAgY29uc3QgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5Ub3AgOiB3aW5kb3cuc2NyZWVuWTtcbiAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA/IHdpbmRvdy5pbm5lcldpZHRoIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIDogd2luZG93LnNjcmVlbi53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiB3aW5kb3cuc2NyZWVuLmhlaWdodDtcbiAgY29uc3Qgc3lzdGVtWm9vbSA9IDE7IC8vIE5vIHJlbGlhYmxlIGVzdGltYXRlXG5cbiAgY29uc3QgbGVmdCA9IE1hdGguYWJzKCh3aWR0aCAtIHcpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuTGVmdCk7XG4gIGNvbnN0IHRvcCA9IE1hdGguYWJzKChoZWlnaHQgLSBoKSAvIDIgLyBzeXN0ZW1ab29tICsgZHVhbFNjcmVlblRvcCk7XG4gIGNvbnN0IGZlYXR1cmVzID0gYHRpdGxlYmFyPTAsdG9vbGJhcj0wLHN0YXR1cz0wLGxvY2F0aW9uPTAsbWVudWJhcj0wLGhlaWdodD0ke2ggLyBzeXN0ZW1ab29tfSx3aWR0aD0ke3cgLyBzeXN0ZW1ab29tfSx0b3A9JHt0b3B9LGxlZnQ9JHtsZWZ0fWA7XG4gIHJldHVybiBmZWF0dXJlcztcbn1cbmNvbnN0IGJyb2FkY2FzdENoYW5uZWxPcHRpb25zID0ge1xuICB0eXBlOiBcInNlcnZlclwiLFxuICAvLyB0eXBlOiAnbG9jYWxzdG9yYWdlJywgLy8gKG9wdGlvbmFsKSBlbmZvcmNlIGEgdHlwZSwgb25lT2ZbJ25hdGl2ZScsICdpZGInLCAnbG9jYWxzdG9yYWdlJywgJ25vZGUnXVxuICB3ZWJXb3JrZXJTdXBwb3J0OiBmYWxzZSAvLyAob3B0aW9uYWwpIHNldCB0aGlzIHRvIGZhbHNlIGlmIHlvdSBrbm93IHRoYXQgeW91ciBjaGFubmVsIHdpbGwgbmV2ZXIgYmUgdXNlZCBpbiBhIFdlYldvcmtlciAoaW5jcmVhc2VzIHBlcmZvcm1hbmNlKVxufTtcbmZ1bmN0aW9uIGdldEN1c3RvbURldmljZUluZm8oKSB7XG4gIHZhciBfbmF2aWdhdG9yO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBpZiAoKF9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3IpICE9PSBudWxsICYmIF9uYXZpZ2F0b3IgIT09IHZvaWQgMCAmJiBfbmF2aWdhdG9yLmJyYXZlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXI6IFwiQnJhdmVcIlxuICAgIH07XG4gIH1cbn1cbmNsYXNzIFVzZXJFcnJvciBleHRlbmRzIEVycm9yIHt9XG5jb25zdCBoYW5kbGVSZWRpcmVjdFBhcmFtZXRlcnMgPSAoaGFzaCwgcXVlcnlQYXJhbWV0ZXJzKSA9PiB7XG4gIGNvbnN0IGhhc2hQYXJhbWV0ZXJzID0ge307XG4gIGNvbnN0IGhhc2hVcmwgPSBuZXcgVVJMKGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59Lz8ke2hhc2guc2xpY2UoMSl9YCk7XG4gIGhhc2hVcmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBoYXNoUGFyYW1ldGVyc1trZXldID0gdmFsdWU7XG4gIH0pO1xuICBsZXQgaW5zdGFuY2VQYXJhbWV0ZXJzID0ge307XG4gIGxldCBlcnJvciA9IFwiXCI7XG4gIGlmICghcXVlcnlQYXJhbWV0ZXJzLndpbmRvd0lkKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKGhhc2hQYXJhbWV0ZXJzKS5sZW5ndGggPiAwICYmIGhhc2hQYXJhbWV0ZXJzLnN0YXRlKSB7XG4gICAgICBpbnN0YW5jZVBhcmFtZXRlcnMgPSBKU09OLnBhcnNlKHNhZmVhdG9iKGRlY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQoaGFzaFBhcmFtZXRlcnMuc3RhdGUpKSkpIHx8IHt9O1xuICAgICAgZXJyb3IgPSBoYXNoUGFyYW1ldGVycy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBoYXNoUGFyYW1ldGVycy5lcnJvciB8fCBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1ldGVycykubGVuZ3RoID4gMCAmJiBxdWVyeVBhcmFtZXRlcnMuc3RhdGUpIHtcbiAgICAgIGluc3RhbmNlUGFyYW1ldGVycyA9IEpTT04ucGFyc2Uoc2FmZWF0b2IoZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudChxdWVyeVBhcmFtZXRlcnMuc3RhdGUpKSkpIHx8IHt9O1xuICAgICAgaWYgKHF1ZXJ5UGFyYW1ldGVycy5lcnJvcikgZXJyb3IgPSBxdWVyeVBhcmFtZXRlcnMuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXJyb3IsXG4gICAgaW5zdGFuY2VQYXJhbWV0ZXJzLFxuICAgIGhhc2hQYXJhbWV0ZXJzXG4gIH07XG59O1xuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICB9KTtcbn1cbmNvbnN0IGlzVW5hdXRob3JpemVkRXJyb3IgPSBlcnJvciA9PiB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIGVycm9yLnN0YXR1cyA9PT0gNDAxO1xufTtcblxuY2xhc3MgQmFzZUtleXJpbmdDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnID0ge30sXG4gICAgc3RhdGVcbiAgfSkge1xuICAgIHZhciBfc3RhdGUkd2FsbGV0cztcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgd2FsbGV0czogKF9zdGF0ZSR3YWxsZXRzID0gc3RhdGUud2FsbGV0cykgIT09IG51bGwgJiYgX3N0YXRlJHdhbGxldHMgIT09IHZvaWQgMCA/IF9zdGF0ZSR3YWxsZXRzIDogW11cbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLy8gZm9yIHNpZ25pbmcgYXV0aCBtZXNzYWdlXG4gIGFzeW5jIHNpZ25BdXRoTWVzc2FnZShhZGRyZXNzLCBtZXNzYWdlKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IHRoaXMuc3RhdGUud2FsbGV0cy5maW5kKHggPT4geC5hZGRyZXNzID09PSBhZGRyZXNzKTtcbiAgICBpZiAoIWtleXJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImtleSBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkTWVzc2FnZSA9IGhhc2hNZXNzYWdlKG1lc3NhZ2UpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IHJhd01lc3NhZ2VTaWcgPSBhd2FpdCBzaWduTWVzc2FnZShrZXlyaW5nLnByaXZhdGVLZXksIGhhc2hlZE1lc3NhZ2UpO1xuICAgIHJldHVybiByYXdNZXNzYWdlU2lnO1xuICB9XG59XG5cbmNvbnN0IFJFVFJJQUJMRV9FUlJPUlMgPSBbXG4vLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuXCJHYXRld2F5IHRpbWVvdXRcIiwgXCJFVElNRURPVVRcIixcbi8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4vLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcblwiZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHlcIixcbi8vIGlnbm9yZSBlcnJvcnMgd2hlcmUgaHR0cCByZXEgZmFpbGVkIHRvIGVzdGFibGlzaFxuXCJGYWlsZWQgdG8gZmV0Y2hcIl07XG5mdW5jdGlvbiBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICBzd2l0Y2ggKGZldGNoUmVzLnN0YXR1cykge1xuICAgIGNhc2UgNDA1OlxuICAgICAgdGhyb3cgcnBjRXJyb3JzLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgY2FzZSA0MTg6XG4gICAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoe1xuICAgICAgICBtZXNzYWdlOiBgUmVxdWVzdCBpcyBiZWluZyByYXRlIGxpbWl0ZWQuYCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNhdXNlOiBmZXRjaFJlc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBjYXNlIDUwMzpcbiAgICBjYXNlIDUwNDpcbiAgICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbCh7XG4gICAgICAgIG1lc3NhZ2U6IGBHYXRld2F5IHRpbWVvdXQuIFRoZSByZXF1ZXN0IHRvb2sgdG9vIGxvbmcgdG8gcHJvY2Vzcy5gICsgYFRoaXMgY2FuIGhhcHBlbiB3aGVuIHF1ZXJ5aW5nIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gXG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgYm9keSkge1xuICAvLyBjaGVjayBmb3IgZXJyb3IgY29kZVxuICBpZiAoZmV0Y2hSZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoe1xuICAgICAgbWVzc2FnZTogYE5vbi0yMDAgc3RhdHVzIGNvZGU6ICcke2ZldGNoUmVzLnN0YXR1c30nYCxcbiAgICAgIGRhdGE6IGJvZHlcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgcnBjIGVycm9yXG4gIGlmIChib2R5LmVycm9yKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKHtcbiAgICAgIGRhdGE6IGJvZHkuZXJyb3JcbiAgICB9KTtcbiAgfVxuICAvLyByZXR1cm4gc3VjY2Vzc2Z1bCByZXN1bHRcbiAgcmV0dXJuIGJvZHkucmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHtcbiAgcmVxLFxuICBycGNUYXJnZXQsXG4gIG9yaWdpbkh0dHBIZWFkZXJLZXlcbn0pIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChycGNUYXJnZXQpO1xuXG4gIC8vIHByZXBhcmUgcGF5bG9hZFxuICAvLyBjb3B5IG9ubHkgY2Fub25pY2FsIGpzb24gcnBjIHByb3BlcnRpZXNcbiAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICBpZDogcmVxLmlkLFxuICAgIGpzb25ycGM6IHJlcS5qc29ucnBjLFxuICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICBwYXJhbXM6IHJlcS5wYXJhbXNcbiAgfTtcblxuICAvLyBleHRyYWN0ICdvcmlnaW4nIHBhcmFtZXRlciBmcm9tIHJlcXVlc3RcbiAgY29uc3Qgb3JpZ2luRG9tYWluID0gcmVxLm9yaWdpbjtcblxuICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG5cbiAgLy8gY29uZmlndXJlIGZldGNoIHBhcmFtc1xuICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogc2VyaWFsaXplZFBheWxvYWRcbiAgfTtcblxuICAvLyBvcHRpb25hbDogYWRkIHJlcXVlc3Qgb3JpZ2luIGFzIGhlYWRlclxuICBpZiAob3JpZ2luSHR0cEhlYWRlcktleSAmJiBvcmlnaW5Eb21haW4pIHtcbiAgICBmZXRjaFBhcmFtcy5oZWFkZXJzW29yaWdpbkh0dHBIZWFkZXJLZXldID0gb3JpZ2luRG9tYWluO1xuICB9XG4gIHJldHVybiB7XG4gICAgZmV0Y2hVcmw6IHBhcnNlZFVybC5ocmVmLFxuICAgIGZldGNoUGFyYW1zXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaE1pZGRsZXdhcmUoe1xuICBycGNUYXJnZXQsXG4gIG9yaWdpbkh0dHBIZWFkZXJLZXlcbn0pIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIF9uZXh0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZmV0Y2hVcmwsXG4gICAgICBmZXRjaFBhcmFtc1xuICAgIH0gPSBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoe1xuICAgICAgcmVxLFxuICAgICAgcnBjVGFyZ2V0LFxuICAgICAgb3JpZ2luSHR0cEhlYWRlcktleVxuICAgIH0pO1xuXG4gICAgLy8gYXR0ZW1wdCByZXF1ZXN0IG11bHRpcGxlIHRpbWVzXG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1O1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSAxMDAwO1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmV0Y2hSZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwgZmV0Y2hQYXJhbXMpO1xuICAgICAgICAvLyBjaGVjayBmb3IgaHR0cCBlcnJyb3JzXG4gICAgICAgIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcyk7XG4gICAgICAgIC8vIHBhcnNlIHJlc3BvbnNlIGJvZHlcbiAgICAgICAgY29uc3QgZmV0Y2hCb2R5ID0gYXdhaXQgZmV0Y2hSZXMuanNvbigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBmZXRjaEJvZHkpO1xuICAgICAgICAvLyBzZXQgcmVzdWx0IGFuZCBleGl0IHJldHJ5IGxvb3BcbiAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IChlcnIubWVzc2FnZSB8fCBlcnIpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGlzUmV0cmlhYmxlID0gUkVUUklBQkxFX0VSUk9SUy5zb21lKHBocmFzZSA9PiBlcnJNc2cuaW5jbHVkZXMocGhyYXNlKSk7XG4gICAgICAgIC8vIHJlLXRocm93IGVycm9yIGlmIG5vdCByZXRyaWFibGVcbiAgICAgICAgaWYgKCFpc1JldHJpYWJsZSkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZGVsYXkgYmVmb3JlIHJldHJ5aW5nXG4gICAgICBhd2FpdCB0aW1lb3V0KHJldHJ5SW50ZXJ2YWwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmVycmVkUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShfcmVzb2x2ZSA9PiB7XG4gICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByZXNvbHZlLFxuICAgIHByb21pc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlKHtcbiAgY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdFxufSkge1xuICBjb25zdCBpbmZsaWdodFJlcXVlc3RzID0ge307XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHByb21pc2VcbiAgICB9ID0gZGVmZXJyZWRQcm9taXNlKCk7XG4gICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLnB1c2goaGFuZGxlZFJlcyA9PiB7XG4gICAgICAvLyBhcHBlbmQgYSBjb3B5IG9mIHRoZSByZXN1bHQgYW5kIGVycm9yIHRvIHRoZSByZXNwb25zZVxuICAgICAgcmVzLnJlc3VsdCA9IGNsb25lRGVlcChoYW5kbGVkUmVzLnJlc3VsdCk7XG4gICAgICByZXMuZXJyb3IgPSBjbG9uZURlZXAoaGFuZGxlZFJlcy5lcnJvcik7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgIC8vIHVzZSBzZXRUaW1lb3V0IHNvIHdlIGNhbiByZXNvbHZlIG91ciBvcmlnaW5hbCByZXF1ZXN0IGZpcnN0XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoYW5kbGVyKHJlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGNhdGNoIGVycm9yIHNvIGFsbCByZXF1ZXN0cyBhcmUgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgaWYgKHJlcS5za2lwQ2FjaGUpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICAgIC8vIGdldCBjYWNoZUlkLCBpZiBjYWNoZWFibGVcbiAgICBjb25zdCBjYWNoZUlkID0gY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdChyZXEpO1xuICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICBpZiAoIWNhY2hlSWQpIHtcbiAgICAgIGxvZy5pbmZvKFwiUmVxdWVzdCBpcyBub3QgY2FjaGVhYmxlLCBwcm9jZWVkaW5nLiByZXEgPSAlb1wiLCByZXEpO1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIG1hdGNoaW5nIHJlcXVlc3RzXG4gICAgbGV0IGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgLy8gaWYgZm91bmQsIHdhaXQgZm9yIHRoZSBhY3RpdmUgcmVxdWVzdCB0byBiZSBoYW5kbGVkXG4gICAgaWYgKGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgLy8gc2V0dXAgdGhlIHJlc3BvbnNlIGxpc3RlbmVyIGFuZCB3YWl0IGZvciBpdCB0byBiZSBjYWxsZWRcbiAgICAgIC8vIGl0IHdpbGwgaGFuZGxlIGNvcHlpbmcgdGhlIHJlc3VsdCBhbmQgcmVxdWVzdCBmaWVsZHNcbiAgICAgIGxvZy5pbmZvKFwiUnVubmluZyAlaSBoYW5kbGVyKHMpIGZvciByZXF1ZXN0ICVvXCIsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5sZW5ndGgsIHJlcSk7XG4gICAgICBhd2FpdCBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBzZXR1cCByZXNwb25zZSBoYW5kbGVyIGFycmF5IGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW107XG4gICAgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXSA9IGFjdGl2ZVJlcXVlc3RIYW5kbGVycztcbiAgICAvLyBhbGxvdyByZXF1ZXN0IHRvIGJlIGhhbmRsZWQgbm9ybWFsbHlcbiAgICBsb2cuaW5mbyhcIkNhcnJ5aW5nIG9yaWdpbmFsIHJlcXVlc3QgZm9yd2FyZCAlb1wiLCByZXEpO1xuICAgIGF3YWl0IG5leHQoKTtcbiAgICAvLyBjbGVhciBpbmZsaWdodCByZXF1ZXN0c1xuICAgIGRlbGV0ZSBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgIC8vIHNjaGVkdWxlIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyB0byBiZSBoYW5kbGVkXG4gICAgbG9nLmluZm8oXCJSdW5uaW5nICVpIGNvbGxlY3RlZCBoYW5kbGVyKHMpIGZvciByZXF1ZXN0ICVvXCIsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5sZW5ndGgsIHJlcSk7XG4gICAgaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgLy8gY29tcGxldGVcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyTWlkZGxld2FyZShvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsb2dnZXJNaWRkbGV3YXJlKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSB7XG4gICAgbmV4dChjYWxsYmFjayA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgbG9nLndhcm4oXCJFcnJvciBpbiBSUEMgcmVzcG9uc2U6XFxuXCIsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LmlzVG9ydXNJbnRlcm5hbCkgcmV0dXJuO1xuICAgICAgbG9nLmluZm8oYFJQQyAoJHtvcHRpb25zLm9yaWdpbn0pOmAsIHJlcXVlc3QsIFwiLT5cIiwgcmVzcG9uc2UpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JpZ2luTWlkZGxld2FyZShvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcmlnaW5NaWRkbGV3YXJlKHJlcXVlc3QsIF8sIG5leHQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJlcXVlc3Qub3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG4gICAgbmV4dCgpO1xuICB9O1xufVxuXG5jb25zdCBjcmVhdGVSYW5kb21JZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbmNvbnN0IENIQUlOX05BTUVTUEFDRVMgPSB7XG4gIEVJUDE1NTogXCJlaXAxNTVcIixcbiAgU09MQU5BOiBcInNvbGFuYVwiLFxuICBDQVNQRVI6IFwiY2FzcGVyXCIsXG4gIFhSUEw6IFwieHJwbFwiLFxuICBPVEhFUjogXCJvdGhlclwiXG59O1xuLy8gZWlwMTU1IGZvciBhbGwgZXZtIGNoYWluc1xuXG4vKipcbiAqIEN1c3RvbSBuZXR3b3JrIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlIGlzRUlQMTU1OUNvbXBhdGlibGU6IHRydWUgZXRjLlxuICovXG5cbi8qKlxuICpcbiAqL1xuXG5jbGFzcyBCcm9hZGNhc3RDaGFubmVsSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxQcmVmaXgsIGluc3RhbmNlSWQpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJiY1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxcIiwgdm9pZCAwKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIGNvbnN0IHdpbmRvd0lkID0gcXVlcnlQYXJhbWV0ZXJzLmdldChcIndpbmRvd0lkXCIpO1xuICAgIHRoaXMuY2hhbm5lbCA9IGAke2NoYW5uZWxQcmVmaXh9XyR7aW5zdGFuY2VJZH1fJHt3aW5kb3dJZH1gO1xuICAgIHRoaXMuYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCh0aGlzLmNoYW5uZWwsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgfVxuICBnZXRNZXNzYWdlRnJvbUNoYW5uZWwoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICB0aGlzLmJjLmNsb3NlKCk7XG4gICAgICAgIGlmIChldi5lcnJvcikge1xuICAgICAgICAgIHJlamVjdChldi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShldi5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJjLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHR5cGU6IFBPUFVQX0xPQURFRFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBTdHJlYW1XaW5kb3cgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcsXG4gICAgc3RhdGUgPSB7fVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICAvLyBpZiB3aW5kb3cgaGFzIGJlZW4gY2xvc2VkIGJ5IHVzZXJzXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xvc2VkXCIsIGZhbHNlKTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBhc3luYyBvcGVuKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbW11bmljYXRpb25FbmdpbmUsXG4gICAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyXG4gICAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgICBsZXQgcG9wdXBTdWNjZXNzID0gZmFsc2U7XG4gICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlci5vbmNlKGAke3RoaXMuc3RhdGUud2luZG93SWR9OmNsb3NlZGAsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFdpbmRvdyBpcyBub3Qgb3BlbiB5ZXRcbiAgICAgIGlmICghdGhpcy5zdGF0ZS53aW5kb3dJZCkge1xuICAgICAgICAvLyBzaW5jZSwgd2UncmUgb3BlbmluZyB3aW5kb3cgbm93LCBubyBuZWVkIHRvIHRlbGwgd2luZG93IGFueXRoaW5nXG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICB3aW5kb3dJZDogcmFuZG9tSWQoKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5oYW5kbGVXaW5kb3dCbG9ja0FsZXJ0ICE9PSBcImZ1bmN0aW9uXCIpIHJlamVjdChuZXcgRXJyb3IoXCJoYW5kbGVXaW5kb3dCbG9ja0FsZXJ0IGlzIG5vdCBhIGZ1bmN0aW9uXCIpKTtcbiAgICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIub25jZShgJHt0aGlzLnN0YXRlLndpbmRvd0lkfTppZnJhbWUtb3BlbmVkYCwgKCkgPT4ge1xuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaWZyYW1lIGlzIGZ1bGwgc2NyZWVuIG5vd1xuICAgICAgICAgIC8vIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGJsb2NrIGFsZXJ0cyBhdCBhIHRpbWUuIHNvLCB3ZSBkb24ndCBzZXQgaWZyYW1lIHRvIGNsb3NlIGFmdGVyIGhhbmRsaW5nIHRoaXMgaGVyZVxuICAgICAgICAgIHRoaXMuY29uZmlnLmhhbmRsZVdpbmRvd0Jsb2NrQWxlcnQoe1xuICAgICAgICAgICAgd2luZG93SWQ6IHRoaXMuc3RhdGUud2luZG93SWQsXG4gICAgICAgICAgICBmaW5hbFVybDogdGhpcy5zdGF0ZS51cmwuaHJlZlxuICAgICAgICAgIH0pLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGVsbCB0aGUgb3RoZXIgcGFydHkgdG8gbWF4aW1pemUgdGhlIGlmcmFtZVxuICAgICAgICBjb21tdW5pY2F0aW9uRW5naW5lLmVtaXQoXCJub3RpZmljYXRpb25cIiwge1xuICAgICAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLklGUkFNRV9TVEFUVVMsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBpc0Z1bGxTY3JlZW46IHRydWUsXG4gICAgICAgICAgICByaWQ6IHRoaXMuc3RhdGUud2luZG93SWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHByZS1vcGVuZWQgd2luZG93LiBzbywgd2UgbmVlZCB0byB0ZWxsIGl0IHRvIHJlZGlyZWN0IHRvIGNvcnJlY3QgdXJsLiBpdCdzIGN1cnJlbnRseSB3YWl0aW5nIG9uIC9yZWRpcmVjdCBhbmQgdXNlcyBgUmVkaXJlY3RIYW5kbGVyYCBjb2RlXG4gICAgICAgIC8vIFNlbmQgdGhpcyB3aW5kb3cgd2l0aCBgd2luZG93SWRgIHRoZSB1cmwgdG8gb3BlbiB2aWEgYmNcbiAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgJHtCUk9BRENBU1RfQ0hBTk5FTFMuUkVESVJFQ1RfQ0hBTk5FTH1fJHt0aGlzLmNvbmZpZy5pbnN0YW5jZUlkfV8ke3RoaXMuc3RhdGUud2luZG93SWR9YDtcbiAgICAgICAgY29uc3QgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChjaGFubmVsTmFtZSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICBiYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGV2LCBgcmVjZWl2aW5nIGRhdGEgb24gY2hhbm5lbDogJHtiYy5uYW1lfWApO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSA9IGV2O1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFBvcHVwIHNheXMgc29tZSBlcnJvci4gc28sIHdlIHNheSBpdCdzIG5vdCByZWFsbHkgb3BlbmVkXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICB9ID0gZXYuZGF0YTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBQT1BVUF9MT0FERUQpIHtcbiAgICAgICAgICAgICAgcG9wdXBTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYXdhaXQgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5zdGF0ZS51cmwuaHJlZixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiXCIgLy8gTm8gbmVlZCBvZiBhIG1zZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcuIHNvLCB3ZSBjbG9zZSB0aGF0IHdpbmRvd1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyBpZiB0aGUgb3RoZXIgZW5kIGlzIHJlYWR5IHRvIHJlY2VpdmUgdGhpcyBtc2cuIFNvLCB3ZSBrZWVwIHdyaXRpbmcgdW50aWwgaXQgcmVjZWl2ZXMgYW5kIHNlbmRzIGJhY2sgc29tZXRoaW5nXG4gICAgICAgIC8vIHdlIG5lZWQgYmFja29mZiBzdHJhdGVneVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIGZpcnN0IGF0dGVtcHQgdG8gc3VjY2VlZC9mYWlsIHVudGlsIHRoZSBzZWNvbmQgYXR0ZW1wdFxuICAgICAgICAvLyBJZiB3ZSBnZXQgNDI5LCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGEgd2hpbGUgYW5kIHRoZW4gdHJ5IGFnYWluXG5cbiAgICAgICAgY29uc3QgcG9zdE1zZyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyB0aGlzIG5ldmVyIHRocm93c1xuICAgICAgICAgIGNvbnN0IGxvY2FsUmVzcG9uc2UgPSBhd2FpdCBiYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFNFVFVQX0NPTVBMRVRFXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsUmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50RGVsYXkgPSBiYy50eXBlID09PSBcInNlcnZlclwiID8gMTAwMCA6IDIwMDtcbiAgICAgICAgY29uc3QgcmVjdXJzaXZlRm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFwb3B1cFN1Y2Nlc3MgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFJlc3BvbnNlID0gYXdhaXQgcG9zdE1zZygpO1xuICAgICAgICAgICAgaWYgKGJjLnR5cGUgPT09IFwic2VydmVyXCIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSBsb2NhbFJlc3BvbnNlO1xuICAgICAgICAgICAgICBpZiAoc2VydmVyUmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgYSB3aGlsZSBhbmQgdGhlbiB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICBjdXJyZW50RGVsYXkgPSBNYXRoLnJvdW5kKGN1cnJlbnREZWxheSAqIDEuNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKGN1cnJlbnREZWxheSk7XG4gICAgICAgICAgICBhd2FpdCByZWN1cnNpdmVGbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVjdXJzaXZlRm4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tdW5pY2F0aW9uRW5naW5lXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbW11bmljYXRpb25FbmdpbmUuZW1pdChcIm5vdGlmaWNhdGlvblwiLCB7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5DTE9TRV9XSU5ET1csXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgd2luZG93SWQ6IHRoaXMuc3RhdGUud2luZG93SWRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKlxuU2NlbmFyaW9zOlxuMS4gT3BlbiBhIG5vcm1hbCBwb3B1cCB3aW5kb3cgYW5kIG5vIGNvbW11bmljYXRpb24gd2l0aCBpdCAtIFVzZSBQb3B1cEhhbmRsZXJcbjIuIE9wZW4gYSBwb3B1cCB3aW5kb3cgYW5kIGNvbW11bmljYXRlIHdpdGggaXQgLSBVc2UgUG9wdXBXaXRoQmNIYW5kbGVyIChjYW4gaW5pdGlhdGUgY29tbXVuaWNhdGlvbiBieSB3YWl0aW5nIGZvciB3aW5kb3cgdG8gb3BlbiBvciBub3QpXG5cbjMuIElmIHdpbmRvdyBpcyBhbHJlYWR5IG9wZW5lZCwgcGFzcyBpbiB3aW5kb3dJZCB0byB0aGUgcG9wdXAgaGFuZGxlci4gXG4gICBUaGlzIHdpbGwgZXN0YWJsaXNoIGNvbW11bmljYXRpb24gd2l0aCB0aGUgcG9wdXAgd2luZG93IGFuZCBzZW5kcyBpdCBhIG5ldyB1cmwgdG8gcmVkaXJlY3QgdG9cblxuXG5JZiB5b3UncmUgdHJ5aW5nIHRvIG9wZW4gYSB3aW5kb3cgYW5kIGl0IGdldHMgYmxvY2tlZCAoaGFwcGVucyBpZiB5b3UncmUgaW4gaWZyYW1lIG9yIGRlbGF5IGIvdyBjbGljayBhbmQgb3BlbmluZyB3aW5kb3cpLFxuICBTdHJlYW1XaW5kb3cgaXMgaW52b2tlZCBhbmQgaXQgd3JpdGVzIGluIGEgY2hhbm5lbCB0byBkaXNwbGF5IGEgbWVzc2FnZSB0byB0aGUgdXNlclxuXG5PbmNlIHVzZXIgY2xpY2tzIG9uIHRoYXQgbW9kYWwvZGlhbG9nLCB3ZSBwcmUtb3BlbiB0aGUgd2luZG93IGFuZCBwYXNzIGluIHRoZSB3aW5kb3dJZCAoZ29lcyB0byAzKVxuKi9cblxuLyoqXG4gKiBIYW5kbGVzIHBvcHVwIHdpbmRvdyBtYW5hZ2VtZW50LlxuICogRm9yIGJyb2FkY2FzdCBjaGFubmVsIGNvbW11bmljYXRpb24sIHVzZSB1cmwgd2l0aCBgaW5zdGFuY2VJZGAgY29kZWQgaW50byBzdGF0ZSBwYXJhbWV0ZXIuXG4gKiBUaGlzIHN0YXRlIHBhcmFtZXRlciB3aWxsIGJlIHBhc3NlZCBhY3Jvc3MgcmVkaXJlY3RzIGFjY29yZGluZyB0byBPQXV0aCBzcGVjLlxuICovXG5jbGFzcyBQb3B1cEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcsXG4gICAgc3RhdGVcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgLy8gdGhpcy5pZCA9IHJhbmRvbUlkKClcbiAgICAvLyBBZGQgaW4gZGFwcCBzdG9yYWdlIGtleSB0byBhbGwgcG9wdXBzIGFzIGEgaGFzaCBwYXJhbWV0ZXJcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyksXG4gICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICBjb21tdW5pY2F0aW9uRW5naW5lOiBudWxsLFxuICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXI6IG51bGwsXG4gICAgICB0aW1lb3V0OiAzMDAwMCxcbiAgICAgIGluc3RhbmNlSWQ6IFwiXCIsXG4gICAgICBoYW5kbGVXaW5kb3dCbG9ja0FsZXJ0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIHdpbmRvd1RpbWVyOiBudWxsLFxuICAgICAgd2luZG93OiBudWxsLFxuICAgICAgaUNsb3NlZFdpbmRvdzogZmFsc2UsXG4gICAgICB3aW5kb3dJZDogXCJcIixcbiAgICAgIHVybDogc3RhdGUudXJsXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLl9zZXR1cFRpbWVyKCk7XG4gIH1cbiAgYXN5bmMgb3BlbigpIHtcbiAgICAvLyBpZiB3aW5kb3cgaXMgYWxyZWFkeSBvcGVuXG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBjb21tdW5pY2F0aW9uRW5naW5lLFxuICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXJcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qge1xuICAgICAgd2luZG93SWQsXG4gICAgICB1cmxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBObyB3aW5kb3cgaGFzIGJlZW4gcHJlLW9wZW5lZFxuICAgIGlmICghd2luZG93SWQpIHtcbiAgICAgIC8vIHRyeSB0byBvcGVuIGEgd2luZG93IGZpcnN0XG4gICAgICBsZXQgbG9jYWxXaW5kb3cgPSB3aW5kb3cub3Blbih1cmwuaHJlZiwgdGFyZ2V0LCBmZWF0dXJlcyk7XG4gICAgICBsZXQgZmluYWxXaW5kb3dJZCA9IFwiXCI7XG4gICAgICBpZiAoIWxvY2FsV2luZG93KSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYmxvY2tlZCwgb3BlbiBTdHJlYW1XaW5kb3dcbiAgICAgICAgY29uc3Qgc3RyZWFtV2luZG93ID0gbmV3IFN0cmVhbVdpbmRvdyh7XG4gICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICBjb21tdW5pY2F0aW9uRW5naW5lLFxuICAgICAgICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIsXG4gICAgICAgICAgICBpbnN0YW5jZUlkOiB0aGlzLmNvbmZpZy5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgaGFuZGxlV2luZG93QmxvY2tBbGVydDogdGhpcy5jb25maWcuaGFuZGxlV2luZG93QmxvY2tBbGVydFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIHVybFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbVdpbmRvdy5vcGVuKCk7XG4gICAgICAgIGZpbmFsV2luZG93SWQgPSBzdHJlYW1XaW5kb3cuc3RhdGUud2luZG93SWQ7XG4gICAgICAgIGxvY2FsV2luZG93ID0gc3RyZWFtV2luZG93O1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICB3aW5kb3c6IGxvY2FsV2luZG93LFxuICAgICAgICB3aW5kb3dJZDogZmluYWxXaW5kb3dJZCB8fCByYW5kb21JZCgpXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQSB3aW5kb3cgaGFzIGJlZW4gcHJlLW9wZW5lZCB3aXRoIGEgcXVlcnkgcGFyYW1ldGVyIGB3aW5kb3dJZGBcbiAgICBjb25zdCBsb2NhbFdpbmRvdyA9IG5ldyBTdHJlYW1XaW5kb3coe1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGNvbW11bmljYXRpb25FbmdpbmUsXG4gICAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLFxuICAgICAgICBpbnN0YW5jZUlkOiB0aGlzLmNvbmZpZy5pbnN0YW5jZUlkLFxuICAgICAgICBoYW5kbGVXaW5kb3dCbG9ja0FsZXJ0OiB0aGlzLmNvbmZpZy5oYW5kbGVXaW5kb3dCbG9ja0FsZXJ0XG4gICAgICB9LFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgdXJsLFxuICAgICAgICB3aW5kb3dJZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHdpbmRvdzogbG9jYWxXaW5kb3csXG4gICAgICB3aW5kb3dJZDogbG9jYWxXaW5kb3cuc3RhdGUud2luZG93SWRcbiAgICB9KTtcbiAgICBhd2FpdCBsb2NhbFdpbmRvdy5vcGVuKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgaUNsb3NlZFdpbmRvdzogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpbmRvd1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh3aW5kb3cpIHdpbmRvdy5jbG9zZSgpO1xuICB9XG4gIF9zZXR1cFRpbWVyKCkge1xuICAgIGNvbnN0IHRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2luZG93LFxuICAgICAgICB3aW5kb3dUaW1lcixcbiAgICAgICAgaUNsb3NlZFdpbmRvd1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgaWYgKHdpbmRvd1RpbWVyKSBjbGVhckludGVydmFsKHdpbmRvd1RpbWVyKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFpQ2xvc2VkV2luZG93KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgaUNsb3NlZFdpbmRvdzogZmFsc2UsXG4gICAgICAgICAgICB3aW5kb3c6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcy5jb25maWcudGltZW91dCk7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93ID09PSBudWxsICYmIHdpbmRvd1RpbWVyKSBjbGVhckludGVydmFsKHdpbmRvd1RpbWVyKTtcbiAgICB9LCA1MDApO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHdpbmRvd1RpbWVyOiB0aW1lclxuICAgIH0pO1xuICB9XG59XG5cbi8vIEFsd2F5cyBsaXN0ZW5pbmcgY2hhbm5lbHMuIEhlbmNlLCBubyB3aW5kb3cgaWRcbmNsYXNzIFBvcHVwU3RvcmVDaGFubmVsIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGluc3RhbmNlSWQsXG4gICAgaGFuZGxlTG9nb3V0LFxuICAgIGhhbmRsZUFjY291bnRJbXBvcnQsXG4gICAgaGFuZGxlTmV0d29ya0NoYW5nZSxcbiAgICBoYW5kbGVTZWxlY3RlZEFkZHJlc3NDaGFuZ2UsXG4gICAgaGFuZGxlVGhlbWVDaGFuZ2VcbiAgfSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZUxvZ291dFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZUFjY291bnRJbXBvcnRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVOZXR3b3JrQ2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlVGhlbWVDaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVTZWxlY3RlZEFkZHJlc3NDaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnN0YW5jZUlkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZDtcbiAgICB0aGlzLmhhbmRsZUxvZ291dCA9IGhhbmRsZUxvZ291dDtcbiAgICB0aGlzLmhhbmRsZUFjY291bnRJbXBvcnQgPSBoYW5kbGVBY2NvdW50SW1wb3J0O1xuICAgIHRoaXMuaGFuZGxlTmV0d29ya0NoYW5nZSA9IGhhbmRsZU5ldHdvcmtDaGFuZ2U7XG4gICAgdGhpcy5oYW5kbGVTZWxlY3RlZEFkZHJlc3NDaGFuZ2UgPSBoYW5kbGVTZWxlY3RlZEFkZHJlc3NDaGFuZ2U7XG4gICAgdGhpcy5oYW5kbGVUaGVtZUNoYW5nZSA9IGhhbmRsZVRoZW1lQ2hhbmdlO1xuICB9XG4gIHNldHVwU3RvcmVDaGFubmVscygpIHtcbiAgICB0aGlzLmxvZ291dENoYW5uZWwoKTtcbiAgICB0aGlzLmltcG9ydEFjY291bnRDaGFubmVsKCk7XG4gICAgdGhpcy5uZXR3b3JrQ2hhbmdlQ2hhbm5lbCgpO1xuICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzQ2hhbmdlQ2hhbm5lbCgpO1xuICAgIHRoaXMudGhlbWVDaGFuZ2VkQ2hhbm5lbCgpO1xuICB9XG4gIGxvZ291dENoYW5uZWwoKSB7XG4gICAgY29uc3QgbG9nb3V0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGAke0JST0FEQ0FTVF9DSEFOTkVMUy5XQUxMRVRfTE9HT1VUX0NIQU5ORUx9XyR7dGhpcy5pbnN0YW5jZUlkfWAsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICBsb2dvdXRDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ID0+IHtcbiAgICAgIHZhciBfZXYkZGF0YTtcbiAgICAgIGxvZy5pbmZvKFwicmVjZWl2ZWQgbG9nb3V0IG1lc3NhZ2VcIiwgZXYpO1xuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhLnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5MT0dPVVQpIHtcbiAgICAgICAgbG9nLmluZm8oXCJMb2dnaW5nIE91dFwiKTtcbiAgICAgICAgdGhpcy5oYW5kbGVMb2dvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpbXBvcnRBY2NvdW50Q2hhbm5lbCgpIHtcbiAgICBjb25zdCB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGAke0JST0FEQ0FTVF9DSEFOTkVMUy5XQUxMRVRfQUNDT1VOVF9JTVBPUlRfQ0hBTk5FTH1fJHt0aGlzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ID0+IHtcbiAgICAgIHZhciBfZXYkZGF0YTI7XG4gICAgICBpZiAoIWV2LmVycm9yICYmICgoX2V2JGRhdGEyID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTIudHlwZSkgPT09IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLkFDQ09VTlRfSU1QT1JURUQpIHtcbiAgICAgICAgdmFyIF9ldiRkYXRhMztcbiAgICAgICAgdGhpcy5oYW5kbGVBY2NvdW50SW1wb3J0KChfZXYkZGF0YTMgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhMy5wcml2S2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuZXR3b3JrQ2hhbmdlQ2hhbm5lbCgpIHtcbiAgICBjb25zdCB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGAke0JST0FEQ0FTVF9DSEFOTkVMUy5XQUxMRVRfTkVUV09SS19DSEFOR0VfQ0hBTk5FTH1fJHt0aGlzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ID0+IHtcbiAgICAgIHZhciBfZXYkZGF0YTQ7XG4gICAgICBpZiAoIWV2LmVycm9yICYmICgoX2V2JGRhdGE0ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTQudHlwZSkgPT09IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLk5FVFdPUktfQ0hBTkdFKSB7XG4gICAgICAgIHZhciBfZXYkZGF0YTU7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0NoYW5nZSgoX2V2JGRhdGE1ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTUubmV0d29yayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdGhlbWVDaGFuZ2VkQ2hhbm5lbCgpIHtcbiAgICBjb25zdCB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGAke0JST0FEQ0FTVF9DSEFOTkVMUy5USEVNRV9DSEFOR0V9XyR7dGhpcy5pbnN0YW5jZUlkfWAsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XG4gICAgICB2YXIgX2V2JGRhdGE2O1xuICAgICAgbG9nLmluZm8oe1xuICAgICAgICBldlxuICAgICAgfSk7XG4gICAgICBpZiAoIWV2LmVycm9yICYmICgoX2V2JGRhdGE2ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTYudHlwZSkgPT09IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLlNFVF9USEVNRSkge1xuICAgICAgICB2YXIgX2V2JGRhdGE3O1xuICAgICAgICB0aGlzLmhhbmRsZVRoZW1lQ2hhbmdlKChfZXYkZGF0YTcgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhNy50aGVtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0ZWRBZGRyZXNzQ2hhbmdlQ2hhbm5lbCgpIHtcbiAgICBjb25zdCB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGAke0JST0FEQ0FTVF9DSEFOTkVMUy5XQUxMRVRfU0VMRUNURURfQUREUkVTU19DSEFOTkVMfV8ke3RoaXMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhODtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YTggPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhOC50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuU0VMRUNURURfQUREUkVTU19DSEFOR0UpIHtcbiAgICAgICAgdmFyIF9ldiRkYXRhOTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RlZEFkZHJlc3NDaGFuZ2UoKF9ldiRkYXRhOSA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhOSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE5LnNlbGVjdGVkQWRkcmVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQb3B1cFdpdGhCY0hhbmRsZXIgaXMgYSBQb3B1cEhhbmRsZXIgd2hpY2ggdXNlcyBicm9hZGNhc3QgY2hhbm5lbCB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBwb3B1cCB3aW5kb3cuXG4gKi9cbmNsYXNzIFBvcHVwV2l0aEJjSGFuZGxlciBleHRlbmRzIFBvcHVwSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcsXG4gICAgc3RhdGUsXG4gICAgY2hhbm5lbFByZWZpeFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsUHJlZml4XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jaGFubmVsUHJlZml4ID0gY2hhbm5lbFByZWZpeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyB0aGUgZGF0YSBmcm9tIHBvcHVwIHdpbmRvdyBhbmQgY2xvc2VzIHRoZSB3aW5kb3dcbiAgICogQHBhcmFtIHN1Y2Nlc3NFeHRyYUZuIC0gRXh0cmEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBkYXRhIGlzIHJlY2VpdmVkXG4gICAqIEByZXR1cm5zIFRoZSBkYXRhIHRvIGJlIHJlY2VpdmVkXG4gICAqL1xuICBoYW5kbGUoc3VjY2Vzc0V4dHJhRm4pIHtcbiAgICBjb25zdCBjaGFubmVsTmFtZSA9IGAke3RoaXMuY2hhbm5lbFByZWZpeH1fJHt0aGlzLmNvbmZpZy5pbnN0YW5jZUlkfV8ke3RoaXMuc3RhdGUud2luZG93SWR9YDtcbiAgICBjb25zdCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGNoYW5uZWxOYW1lLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNsb3NlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgIHJlamVjdChuZXcgVXNlckVycm9yKFwidXNlciBjbG9zZWQgcG9wdXBcIikpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY2xvc2VMaXN0ZW5lcik7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICBsb2cuaW5mbyhldiwgYHJlY2VpdmluZyBkYXRhIG9uIGNoYW5uZWw6ICR7YmMubmFtZX1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9ID0gZXY7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWNjZXNzRXh0cmFGbikgYXdhaXQgc3VjY2Vzc0V4dHJhRm4uY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcGVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvZy5pbmZvKGBvcGVuZWQgd2luZG93ICR7YmMubmFtZX1gKTtcbiAgICAgICAgLy8gT3BlbmVkIHdpbmRvdy4geWF5LiAgbGV0IHRoZSBiYyBldmVudHMgZG8gdGhlaXIgam9iXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoZXJyLCBcInNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIG9wZW5pbmcgd2luZG93XCIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIGlmIHdlIGhhdmUgdG8gc2VuZCBsYXJnZSBwYXlsb2FkcyB3aGljaCBkb24ndCBmaXQgaW4gcXVlcnkvaGFzaCBwYXJhbXMuXG4gICAqIFdhaXRzIGZvciBhY2sgdGhhdCBwb3B1cCB3aW5kb3cgaXMgcmVhZHkgdG8gcmVjZWl2ZSBkYXRhLlxuICAgKiBSZWNlaXZlcyB0aGUgZGF0YSBmcm9tIHBvcHVwIHdpbmRvdyBhbmQgY2xvc2VzIHRoZSB3aW5kb3dcbiAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgZGF0YSB0byBiZSBzZW50IHRvIHRoZSBwb3B1cCB3aW5kb3cgb25jZSB3ZSBoYXZlIGFjayB0aGF0IHdpbmRvdyBpcyByZWFkeSB0byByZWNlaXZlIGRhdGFcbiAgICogQHBhcmFtIHN1Y2Nlc3NFeHRyYUZuIC0gRXh0cmEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBkYXRhIGlzIHJlY2VpdmVkXG4gICAqIEByZXR1cm5zIFRoZSBkYXRhIHRvIGJlIHJlY2VpdmVkXG4gICAqL1xuICBoYW5kbGVXaXRoSGFuZHNoYWtlKHBheWxvYWQsIHN1Y2Nlc3NFeHRyYUZuKSB7XG4gICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgJHt0aGlzLmNoYW5uZWxQcmVmaXh9XyR7dGhpcy5jb25maWcuaW5zdGFuY2VJZH1fJHt0aGlzLnN0YXRlLndpbmRvd0lkfWA7XG4gICAgY29uc3QgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChjaGFubmVsTmFtZSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjbG9zZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICByZWplY3QobmV3IFVzZXJFcnJvcihcInVzZXIgY2xvc2VkIHBvcHVwXCIpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgIGJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2cuaW5mbyhldiwgYHJlY2VpdmluZyBkYXRhIG9uIGNoYW5uZWw6ICR7YmMubmFtZX1gKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9ID0gZXY7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERvIGhhbmRzaGFrZVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHR5cGUgPSBcIlwiXG4gICAgICAgICAgfSA9IGRhdGE7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFBPUFVQX0xPQURFRCkge1xuICAgICAgICAgICAgLy8gSGFjayB3aXRoIGdlbmVyaWMgdG8gdXNlIHRoZSBzYW1lIHR5cGUgZm9yIGJvdGggc2VuZCBhbmQgcmVjZWl2ZVxuICAgICAgICAgICAgYXdhaXQgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFBPUFVQX1JFU1VMVCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NFeHRyYUZuKSBhd2FpdCBzdWNjZXNzRXh0cmFGbi5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIC8vIE11c3Qgb25seSBjbG9zZSB0aGUgYmMgYWZ0ZXIgcmVzdWx0IGlzIGRvbmVcbiAgICAgICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcGVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvZy5pbmZvKGBvcGVuZWQgd2luZG93ICR7YmMubmFtZX1gKTtcbiAgICAgICAgLy8gT3BlbmVkIHdpbmRvdy4geWF5LiAgbGV0IHRoZSBiYyBldmVudHMgZG8gdGhlaXIgam9iXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoZXJyLCBcInNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIG9wZW5pbmcgd2luZG93XCIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFJlZGlyZWN0SGFuZGxlciB7XG4gIC8vIHByaXZhdGUgaGFzaFBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgY29uc3RydWN0b3IoaW5zdGFuY2VJZCkge1xuICAgIC8vIHByaXZhdGUgZXJyb3I6IHN0cmluZztcbiAgICAvLyB0aGlzIGlzIHNlc3Npb25pZCBwb3N0IGxvZ2luXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5zdGFuY2VJZFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbmFsUXVlcnlQYXJhbXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluc3RhbmNlUGFyYW1ldGVyc1wiLCB2b2lkIDApO1xuICAgIGNvbnN0IHtcbiAgICAgIGhhc2hcbiAgICB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgcXVlcnlQYXJhbWV0ZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRoaXMuZmluYWxRdWVyeVBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzXG4gICAgfSA9IGhhbmRsZVJlZGlyZWN0UGFyYW1ldGVycyhoYXNoLCB0aGlzLmZpbmFsUXVlcnlQYXJhbXMpO1xuICAgIC8vIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLmluc3RhbmNlUGFyYW1ldGVycyA9IGluc3RhbmNlUGFyYW1ldGVycztcbiAgICAvLyB0aGlzLmhhc2hQYXJhbWV0ZXJzID0gaGFzaFBhcmFtZXRlcnM7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZDtcbiAgfVxuICBhc3luYyBoYW5kbGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmluYWxRdWVyeVBhcmFtcyxcbiAgICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGxldCBiYztcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHVzZWQgZm9yIGxvZ2luIGNhc2UuIHRoZXJlJ3Mgbm8gd2luZG93SWQgaGVyZVxuICAgICAgICAvLyBpZiAoIWZpbmFsUXVlcnlQYXJhbXMud2luZG93SWQpIHtcbiAgICAgICAgLy8gICBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGAke0JST0FEQ0FTVF9DSEFOTkVMUy5SRURJUkVDVF9DSEFOTkVMfV8ke2luc3RhbmNlUGFyYW1ldGVycy5pbnN0YW5jZUlkfWAsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgLy8gICBiYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyAoZXYpID0+IHtcbiAgICAgICAgLy8gICAgIGlmIChldi5lcnJvcikge1xuICAgICAgICAvLyAgICAgICByZWplY3QoZXYuZXJyb3IpO1xuICAgICAgICAvLyAgICAgICB3aW5kb3cuY2xvc2UoKTtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgLy8gICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgLy8gICAgICAgbG9nLmluZm8oXCJwb3N0ZWRcIiwgeyBmaW5hbFF1ZXJ5UGFyYW1zLCBoYXNoUGFyYW1ldGVycywgaW5zdGFuY2VQYXJhbWV0ZXJzIH0pO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgIH0pO1xuICAgICAgICAvLyAgIGJjLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgLy8gICAgIGRhdGE6IHtcbiAgICAgICAgLy8gICAgICAgaW5zdGFuY2VQYXJhbXM6IGluc3RhbmNlUGFyYW1ldGVycyxcbiAgICAgICAgLy8gICAgICAgaGFzaFBhcmFtczogaGFzaFBhcmFtZXRlcnMsXG4gICAgICAgIC8vICAgICAgIHF1ZXJ5UGFyYW1zOiBmaW5hbFF1ZXJ5UGFyYW1zLFxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gICAgIGVycm9yLFxuICAgICAgICAvLyAgIH0pO1xuXG4gICAgICAgIC8vICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vICAgICByZXNvbHZlKCk7XG4gICAgICAgIC8vICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gICAgICAgIC8vICAgfSwgNTAwMCk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYCR7QlJPQURDQVNUX0NIQU5ORUxTLlJFRElSRUNUX0NIQU5ORUx9XyR7dGhpcy5pbnN0YW5jZUlkIHx8IGluc3RhbmNlUGFyYW1ldGVycy5pbnN0YW5jZUlkfV8ke2ZpbmFsUXVlcnlQYXJhbXMud2luZG93SWQgfHwgaW5zdGFuY2VQYXJhbWV0ZXJzLndpbmRvd0lkfWA7XG4gICAgICAgIGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoY2hhbm5lbE5hbWUsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICB9ID0gZXYuZGF0YTtcbiAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT09IFNFVFVQX0NPTVBMRVRFKSB7XG4gICAgICAgICAgICBhd2FpdCBiYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dJZDogZmluYWxRdWVyeVBhcmFtcy53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBQT1BVUF9MT0FERURcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldi5lcnJvciAmJiBldi5lcnJvciAhPT0gXCJcIikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGV2LmVycm9yKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5pbmZvKGVyciwgXCJzb21ldGhpbmcgd2VudCB3cm9uZ1wiKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGlmIChiYykgYmMuY2xvc2UoKTtcbiAgICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIEhUVFBfTUVUSE9EID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChIVFRQX01FVEhPRCkge1xuICBIVFRQX01FVEhPRFtIVFRQX01FVEhPRFtcIkdFVFwiXSA9IDBdID0gXCJHRVRcIjtcbiAgSFRUUF9NRVRIT0RbSFRUUF9NRVRIT0RbXCJQT1NUXCJdID0gMV0gPSBcIlBPU1RcIjtcbiAgSFRUUF9NRVRIT0RbSFRUUF9NRVRIT0RbXCJQVVRcIl0gPSAyXSA9IFwiUFVUXCI7XG4gIEhUVFBfTUVUSE9EW0hUVFBfTUVUSE9EW1wiUEFUQ0hcIl0gPSAzXSA9IFwiUEFUQ0hcIjtcbiAgSFRUUF9NRVRIT0RbSFRUUF9NRVRIT0RbXCJERUxFVEVcIl0gPSA0XSA9IFwiREVMRVRFXCI7XG4gIHJldHVybiBIVFRQX01FVEhPRDtcbn0oSFRUUF9NRVRIT0QgfHwge30pO1xuY29uc3QgY29uc3RydWN0QXV0aEhlYWRlcnMgPSAoe1xuICBqd3RUb2tlbixcbiAgcHVibGljQWRkcmVzc1xufSkgPT4ge1xuICByZXR1cm4ge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtqd3RUb2tlbn1gLFxuICAgICAgXCJwdWJsaWMtYWRkcmVzc1wiOiBwdWJsaWNBZGRyZXNzXG4gICAgfVxuICB9O1xufTtcbmNvbnN0IHdpdGhVbmF1dGhvcml6ZWRIYW5kbGVyID0gYXN5bmMgKGZuLCBlbWl0dGVyKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmbigpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChpc1VuYXV0aG9yaXplZEVycm9yKGUpKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoQ29udHJvbGxlckV2ZW50cy5Vc2VyVW5hdXRob3JpemVkKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbmNvbnN0IGp3dFRva2VuRXhwaXJlZCA9IGp3dCA9PiB7XG4gIGNvbnN0IGRlY29kZWQgPSBqd3REZWNvZGUoand0KTtcbiAgY29uc3Qgand0RXhwaXJ5ID0gZGVjb2RlZC5leHAgKiAxMDAwO1xuICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICByZXR1cm4gY3VycmVudFRpbWUgPj0gand0RXhwaXJ5O1xufTtcbmNvbnN0IFdTQXBpQ2xpZW50ID0gKGJhc2VBcGlVcmwsIGVtaXR0ZXIpID0+IHtcbiAgY29uc3QgYXV0aFJlcXVlc3QgPSAobWV0aG9kLCB1cmwsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucykgPT4ge1xuICAgIGlmIChqd3RUb2tlbkV4cGlyZWQoYXV0aENyZWRlbnRpYWxzLmp3dFRva2VuKSkge1xuICAgICAgZW1pdHRlci5lbWl0KENvbnRyb2xsZXJFdmVudHMuVXNlclVuYXV0aG9yaXplZCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRocm93LWxpdGVyYWxcbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNDAxLFxuICAgICAgICBzdGF0dXNUZXh0OiBcIlVuYXV0aG9yaXplZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9LCBjb25zdHJ1Y3RBdXRoSGVhZGVycyhhdXRoQ3JlZGVudGlhbHMpKTtcbiAgICBpZiAobWV0aG9kID09PSBIVFRQX01FVEhPRC5HRVQpIHtcbiAgICAgIHJldHVybiB3aXRoVW5hdXRob3JpemVkSGFuZGxlcigoKSA9PiBnZXQodXJsLCBoZWFkZXJzLCBjdXN0b21PcHRpb25zKSwgZW1pdHRlcik7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT09IEhUVFBfTUVUSE9ELlBPU1QpIHtcbiAgICAgIHJldHVybiB3aXRoVW5hdXRob3JpemVkSGFuZGxlcigoKSA9PiBwb3N0KHVybCwgZGF0YSwgaGVhZGVycywgY3VzdG9tT3B0aW9ucyksIGVtaXR0ZXIpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBIVFRQX01FVEhPRC5QVVQpIHtcbiAgICAgIHJldHVybiB3aXRoVW5hdXRob3JpemVkSGFuZGxlcigoKSA9PiBwdXQodXJsLCBkYXRhLCBoZWFkZXJzLCBjdXN0b21PcHRpb25zKSwgZW1pdHRlcik7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT09IEhUVFBfTUVUSE9ELlBBVENIKSB7XG4gICAgICByZXR1cm4gd2l0aFVuYXV0aG9yaXplZEhhbmRsZXIoKCkgPT4gcGF0Y2godXJsLCBkYXRhLCBoZWFkZXJzLCBjdXN0b21PcHRpb25zKSwgZW1pdHRlcik7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT09IEhUVFBfTUVUSE9ELkRFTEVURSkge1xuICAgICAgcmV0dXJuIHdpdGhVbmF1dGhvcml6ZWRIYW5kbGVyKCgpID0+IHJlbW92ZSh1cmwsIGRhdGEsIGhlYWRlcnMsIGN1c3RvbU9wdGlvbnMpLCBlbWl0dGVyKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgYXV0aEdldDogKHVybCwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSA9PiBhdXRoUmVxdWVzdChIVFRQX01FVEhPRC5HRVQsIGAke2Jhc2VBcGlVcmx9LyR7dXJsfWAsIHt9LCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpLFxuICAgIGF1dGhQb3N0OiAodXJsLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpID0+IGF1dGhSZXF1ZXN0KEhUVFBfTUVUSE9ELlBPU1QsIGAke2Jhc2VBcGlVcmx9LyR7dXJsfWAsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucyksXG4gICAgYXV0aFB1dDogKHVybCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSA9PiBhdXRoUmVxdWVzdChIVFRQX01FVEhPRC5QVVQsIGAke2Jhc2VBcGlVcmx9LyR7dXJsfWAsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucyksXG4gICAgYXV0aFBhdGNoOiAodXJsLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpID0+IGF1dGhSZXF1ZXN0KEhUVFBfTUVUSE9ELlBBVENILCBgJHtiYXNlQXBpVXJsfS8ke3VybH1gLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpLFxuICAgIGF1dGhSZW1vdmU6ICh1cmwsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucykgPT4gYXV0aFJlcXVlc3QoSFRUUF9NRVRIT0QuREVMRVRFLCBgJHtiYXNlQXBpVXJsfS8ke3VybH1gLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpXG4gIH07XG59O1xuXG5jb25zdCBBQ1RJVklUWV9BQ1RJT04gPSB7XG4gIEFDVElWSVRZX0FDVElPTl9BTEw6IFwid2FsbGV0QWN0aXZpdHkuYWxsVHJhbnNhY3Rpb25zXCIsXG4gIEFDVElWSVRZX0FDVElPTl9TRU5EOiBcIndhbGxldEFjdGl2aXR5LnNlbmRcIixcbiAgQUNUSVZJVFlfQUNUSU9OX1JFQ0VJVkU6IFwid2FsbGV0QWN0aXZpdHkucmVjZWl2ZVwiLFxuICBBQ1RJVklUWV9BQ1RJT05fVE9QVVA6IFwid2FsbGV0QWN0aXZpdHkudG9wdXBcIlxufTtcbmNvbnN0IEFDQ09VTlRfQ0FURUdPUlkgPSB7XG4gIE5PUk1BTDogXCJub3JtYWxcIixcbiAgVEhSRVNIT0xEOiBcInRocmVzaG9sZFwiLFxuICBJTVBPUlRFRDogXCJpbXBvcnRlZFwiLFxuICAvLyB3ZSBoYXZlIHByaXZhdGUga2V5IGhlcmVcbiAgQVBQX1NDT1BFRDogXCJhcHBfc2NvcGVkXCIsXG4gIEFDQ09VTlRfQUJTVFJBQ1RJT046IFwiYWNjb3VudF9hYnN0cmFjdGlvblwiLFxuICBFWFRFUk5BTDogXCJleHRlcm5hbFwiLFxuICAvLyBsaWtlIG1ldGFtYXNrLCB3YWxsZXQgY29ubmVjdFxuICBNUEM6IFwibXBjXCIsXG4gIFNGQTogXCJzZmFcIlxufTtcblxuLyoqXG4gKiBQcmVmZXJlbmNlcyBjb250cm9sbGVyIHN0YXRlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIGFkZHJlc3Mgb2YgdGhlIHVzZXJcbiAqIEBwYXJhbSBqd3RUb2tlbiAtIGlmIGp3dCB0b2tlbiBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgZmV0Y2hpbmcgZnJvbSBiYWNrZW5kXG4gKiBAcGFyYW0gY2FsbGVkRnJvbUVtYmVkIC0gaWYgY2FsbGVkIGZyb20gZW1iZWRcbiAqIEBwYXJhbSB1c2VySW5mbyAtIG9wdGlvbmFsIHVzZXIgaW5mb1xuICogQHBhcmFtIHJlaHlkcmF0ZSAtIFJlaHlkcmF0ZSB0aGUgcHJlZmVyZW5jZXMgZnJvbSB0aGUgbG9jYWwgc3RvcmFnZVxuICovXG5cbi8vIEJ5IGRlZmF1bHQsIHBvbGwgZXZlcnkgMyBtaW51dGVzXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMTgwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfUFJFRkVSRU5DRVMgPSB7XG4gIHNlbGVjdGVkQ3VycmVuY3k6IFwiVVNEXCIsXG4gIHRoZW1lOiBcImRhcmtcIixcbiAgbG9jYWxlOiBcImVuXCIsXG4gIGFjY291bnRUeXBlOiBBQ0NPVU5UX0NBVEVHT1JZLk5PUk1BTCxcbiAgY29udGFjdHM6IFtdLFxuICBqd3RUb2tlbjogXCJcIixcbiAgZmV0Y2hlZFBhc3RUeDogW10sXG4gIHBhc3RUcmFuc2FjdGlvbnM6IFtdLFxuICBwYXltZW50VHg6IFtdLFxuICBkZWZhdWx0UHVibGljQWRkcmVzczogXCJcIixcbiAgY3VzdG9tVG9rZW5zOiBbXSxcbiAgY3VzdG9tTmZ0czogW10sXG4gIGNyYXNoUmVwb3J0OiB0cnVlLFxuICB1c2VySW5mbzoge1xuICAgIGFnZ3JlZ2F0ZVZlcmlmaWVyOiBcIlwiLFxuICAgIGVtYWlsOiBcIlwiLFxuICAgIG5hbWU6IFwiXCIsXG4gICAgcHJvZmlsZUltYWdlOiBcIlwiLFxuICAgIHR5cGVPZkxvZ2luOiBMT0dJTl9QUk9WSURFUi5HT09HTEUsXG4gICAgdmVyaWZpZXI6IFwiXCIsXG4gICAgdmVyaWZpZXJJZDogXCJcIlxuICB9XG59O1xuXG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBzdG9yZXMgc2hhcmVkIHNldHRpbmdzIGFuZCBleHBvc2VzIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqL1xuY2xhc3MgQmFzZVByZWZlcmVuY2VzQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnLFxuICAgIHN0YXRlLFxuICAgIGRlZmF1bHRQcmVmZXJlbmNlcyxcbiAgICBzaWduQXV0aE1lc3NhZ2UsXG4gICAgdmFsaWRhdGVTaWduTWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgXCJQcmVmZXJlbmNlc0NvbnRyb2xsZXJcIik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWZyYW1lT3JpZ2luXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid3NBcGlDbGllbnRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduQXV0aE1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWxpZGF0ZVNpZ25NZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFByZWZlcmVuY2VzXCIsIHZvaWQgMCk7XG4gICAgaWYgKCFjb25maWcuYXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcmVmZXJlbmNlc0NvbnRyb2xsZXIgLSBubyBhcGkgc3BlY2lmaWVkIGluIGNvbmZpZy5cIik7XG4gICAgfVxuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgaWRlbnRpdGllczoge30sXG4gICAgICBzZWxlY3RlZEFkZHJlc3M6IFwiXCIsXG4gICAgICBsYXN0RXJyb3JNZXNzYWdlOiBcIlwiLFxuICAgICAgbGFzdFN1Y2Nlc3NNZXNzYWdlOiBcIlwiXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICBhcGk6IGNvbmZpZy5hcGksXG4gICAgICBwb2xsSW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUxcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuZGVmYXVsdFByZWZlcmVuY2VzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBERUZBVUxUX1BSRUZFUkVOQ0VTKSwgZGVmYXVsdFByZWZlcmVuY2VzKTtcbiAgICB0aGlzLnNpZ25BdXRoTWVzc2FnZSA9IHNpZ25BdXRoTWVzc2FnZTtcbiAgICB0aGlzLnZhbGlkYXRlU2lnbk1lc3NhZ2UgPSB2YWxpZGF0ZVNpZ25NZXNzYWdlO1xuICAgIHRoaXMud3NBcGlDbGllbnQgPSBXU0FwaUNsaWVudCh0aGlzLmNvbmZpZy5hcGksIHRoaXMpO1xuICB9XG4gIHNldElmcmFtZU9yaWdpbihvcmlnaW4pIHtcbiAgICB0aGlzLmlmcmFtZU9yaWdpbiA9IG9yaWdpbjtcbiAgfVxuICBnZXRBZGRyZXNzU3RhdGUoYWRkcmVzcykge1xuICAgIGNvbnN0IHNlbGVjdGVkQWRkcmVzcyA9IGFkZHJlc3MgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaWRlbnRpdGllc1tzZWxlY3RlZEFkZHJlc3NdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgc2VsZWN0ZWQgYWRkcmVzc1xuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gY2FzcGVyIGFjY291bnQgaGFzaFxuICAgKi9cbiAgc2V0U2VsZWN0ZWRBZGRyZXNzKHNlbGVjdGVkQWRkcmVzcykge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHNlbGVjdGVkQWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFVzZXIoYWRkcmVzcykge1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhHZXQoXCJ1c2VyP2ZldGNoVHg9ZmFsc2VcIiwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoYWRkcmVzcyksIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB1c2VyLmRhdGE7XG4gIH1cbiAgYXN5bmMgY3JlYXRlVXNlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZWxlY3RlZEN1cnJlbmN5LFxuICAgICAgdGhlbWUsXG4gICAgICB2ZXJpZmllcixcbiAgICAgIHZlcmlmaWVySWQsXG4gICAgICBsb2NhbGUsXG4gICAgICBhZGRyZXNzLFxuICAgICAgaWRUb2tlbixcbiAgICAgIHR5cGUsXG4gICAgICB3ZWIzQXV0aE5ldHdvcmtcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHVzZXJQYXlsb2FkID0ge1xuICAgICAgZGVmYXVsdF9jdXJyZW5jeTogc2VsZWN0ZWRDdXJyZW5jeSxcbiAgICAgIHRoZW1lLFxuICAgICAgdmVyaWZpZXIsXG4gICAgICB2ZXJpZmllcl9pZDogdmVyaWZpZXJJZCxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGlkVG9rZW4sXG4gICAgICBhY2NvdW50X3R5cGU6IHR5cGUsXG4gICAgICB3ZWIzYXV0aF9uZXR3b3JrOiB3ZWIzQXV0aE5ldHdvcmtcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBvc3QoXCJ1c2VyXCIsIHVzZXJQYXlsb2FkLCB0aGlzLmF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICB0aGVtZSxcbiAgICAgIGRlZmF1bHRQdWJsaWNBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgc2VsZWN0ZWRDdXJyZW5jeSxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGFjY291bnRUeXBlOiB0eXBlXG4gICAgfSwgYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgc3RvcmVVc2VyTG9naW4ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmVyaWZpZXJJZCxcbiAgICAgIHZlcmlmaWVyLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBpZFRva2VuLFxuICAgICAgd2ViM0F1dGhDbGllbnRJZCxcbiAgICAgIHdlYjNBdXRoTmV0d29yayxcbiAgICAgIHNlc3Npb25QdWJLZXksXG4gICAgICBsb2dpbk1vZGVcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmICghb3B0aW9ucy5yZWh5ZHJhdGUpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBib3dzZXIuZ2V0UGFyc2VyKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIGNvbnN0IHNwZWNpYWxCcm93c2VyID0gZ2V0Q3VzdG9tRGV2aWNlSW5mbygpO1xuICAgICAgY29uc3QgcmVjb3JkTG9naW5QYXlsb2FkID0ge1xuICAgICAgICBvczogYnJvd3Nlci5nZXRPU05hbWUoKSxcbiAgICAgICAgb3NfdmVyc2lvbjogYnJvd3Nlci5nZXRPU1ZlcnNpb24oKSB8fCBcInVuaWRlbnRpZmllZFwiLFxuICAgICAgICBicm93c2VyOiAoc3BlY2lhbEJyb3dzZXIgPT09IG51bGwgfHwgc3BlY2lhbEJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwZWNpYWxCcm93c2VyLmJyb3dzZXIpIHx8IGJyb3dzZXIuZ2V0QnJvd3Nlck5hbWUoKSB8fCBcInVuaWRlbnRpZmllZFwiLFxuICAgICAgICBicm93c2VyX3ZlcnNpb246IGJyb3dzZXIuZ2V0QnJvd3NlclZlcnNpb24oKSB8fCBcInVuaWRlbnRpZmllZFwiLFxuICAgICAgICBwbGF0Zm9ybTogYnJvd3Nlci5nZXRQbGF0Zm9ybSgpLnR5cGUgfHwgXCJkZXNrdG9wXCIsXG4gICAgICAgIGhvc3RuYW1lOiB0aGlzLmlmcmFtZU9yaWdpbixcbiAgICAgICAgdmVyaWZpZXIsXG4gICAgICAgIHZlcmlmaWVyX2lkOiB2ZXJpZmllcklkLFxuICAgICAgICBpZFRva2VuLFxuICAgICAgICB3ZWIzYXV0aF9jbGllbnRfaWQ6IHdlYjNBdXRoQ2xpZW50SWQsXG4gICAgICAgIHdlYjNhdXRoX25ldHdvcms6IHdlYjNBdXRoTmV0d29yayxcbiAgICAgICAgc2Vzc2lvbl9wdWJfa2V5OiBzZXNzaW9uUHViS2V5LFxuICAgICAgICBsb2dpbl9tb2RlOiBsb2dpbk1vZGVcbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQb3N0KFwidXNlci9yZWNvcmRMb2dpblwiLCByZWNvcmRMb2dpblBheWxvYWQsIHRoaXMuYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldENyYXNoUmVwb3J0KGlzRW5hYmxlZCkge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU7XG4gICAgaWYgKGlzRW5hYmxlZCA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGUgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZS5jcmFzaFJlcG9ydCkpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQYXRjaChcInVzZXJcIiwge1xuICAgICAgICBlbmFibGVfY3Jhc2hfcmVwb3J0ZXI6IGlzRW5hYmxlZFxuICAgICAgfSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGNyYXNoUmVwb3J0OiBpc0VuYWJsZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldFVzZXJUaGVtZSh0aGVtZSkge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGUyO1xuICAgIGlmICh0aGVtZSA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGUyID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMi50aGVtZSkpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQYXRjaChcInVzZXJcIiwge1xuICAgICAgICB0aGVtZVxuICAgICAgfSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIHRoZW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXRVc2VyTG9jYWxlKGxvY2FsZSkge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGUzO1xuICAgIGlmIChsb2NhbGUgPT09ICgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMyA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKCkpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTMubG9jYWxlKSkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQYXRjaChcInVzZXJcIiwge1xuICAgICAgICBsb2NhbGVcbiAgICAgIH0sIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBsb2NhbGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBzZXQgbG9jYWxlXCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0U2VsZWN0ZWRDdXJyZW5jeShwYXlsb2FkKSB7XG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTQ7XG4gICAgaWYgKHBheWxvYWQuc2VsZWN0ZWRDdXJyZW5jeSA9PT0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGU0ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNC5zZWxlY3RlZEN1cnJlbmN5KSkgcmV0dXJuIHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBhdGNoKFwidXNlclwiLCB7XG4gICAgICAgIGRlZmF1bHRfY3VycmVuY3k6IHBheWxvYWQuc2VsZWN0ZWRDdXJyZW5jeVxuICAgICAgfSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIHNlbGVjdGVkQ3VycmVuY3k6IHBheWxvYWQuc2VsZWN0ZWRDdXJyZW5jeVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYWRkQ29udGFjdChjb250YWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU1O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQb3N0KFwiY29udGFjdFwiLCBjb250YWN0LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgY29udGFjdHM6IFsuLi4oKChfdGhpcyRnZXRBZGRyZXNzU3RhdGU1ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNS5jb250YWN0cykgfHwgW10pLCByZXNwb25zZS5kYXRhXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGFkZCBjb250YWN0XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVsZXRlQ29udGFjdChjb250YWN0SWQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTY7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFJlbW92ZShgY29udGFjdC8ke2NvbnRhY3RJZH1gLCB7fSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmluYWxDb250YWN0cyA9IChfdGhpcyRnZXRBZGRyZXNzU3RhdGU2ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNi5jb250YWN0cy5maWx0ZXIoY29udGFjdCA9PiBjb250YWN0LmlkICE9PSByZXNwb25zZS5kYXRhLmlkKTtcbiAgICAgIGlmIChmaW5hbENvbnRhY3RzKSB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgY29udGFjdHM6IFsuLi5maW5hbENvbnRhY3RzXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGRlbGV0ZSBjb250YWN0XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmV2b2tlRGlzY29yZChpZFRva2VuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQb3N0KFwicmV2b2tlL2Rpc2NvcmRcIiwge1xuICAgICAgICB0b2tlbjogaWRUb2tlblxuICAgICAgfSwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbG9nLmluZm8ocmVzcCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHBhdGNoUGFzdFR4KGJvZHksIGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQYXRjaChcInRyYW5zYWN0aW9uXCIsIGJvZHksIHRoaXMuYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhcInN1Y2Nlc3NmdWxseSBwYXRjaGVkXCIsIHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIHBhdGNoIHR4XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcG9zdFBhc3RUeCh0eCwgYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aFBvc3QoXCJ0cmFuc2FjdGlvblwiLCB0eCwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoYWRkcmVzcyksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxvZy5pbmZvKFwic3VjY2Vzc2Z1bGx5IHBvc3RlZCB0eFwiLCByZXNwb25zZSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvciwgXCJ1bmFibGUgdG8gaW5zZXJ0IHRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRXYWxsZXRPcmRlcnMoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aEdldChcInRyYW5zYWN0aW9uXCIsIHRoaXMuYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uuc3VjY2VzcyA/IHJlc3BvbnNlLmRhdGEgPyByZXNwb25zZS5kYXRhIDogW10gOiBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGdldCB3YWxsZXQgb3JkZXJzIHR4XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0VG9wVXBPcmRlcnMoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aEdldChcInRyYW5zYWN0aW9uXCIsIHRoaXMuYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YSB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGZldGNoIHBhc3QgVG9wIHVwIG9yZGVyc1wiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldEJpbGxCb2FyZERhdGEoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoR2V0KFwiYmlsbGJvYXJkXCIsIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5zdWNjZXNzID8gcmVzcG9uc2UuZGF0YSA6IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gZ2V0IGJpbGxib2FyZCBkYXRhXCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0TWVzc2FnZUZvclNpZ25pbmcocHVibGljQWRkcmVzcywgd2ViM0F1dGhJZFRva2VuKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vYXV0aC9tZXNzYWdlYCwge1xuICAgICAgcHVibGljX2FkZHJlc3M6IHB1YmxpY0FkZHJlc3MsXG4gICAgICBpZF90b2tlbjogd2ViM0F1dGhJZFRva2VuXG4gICAgfSwge30sIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5tZXNzYWdlO1xuICB9XG4gIGFzeW5jIGdldFR3aXR0ZXJJZChwYXlsb2FkKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoR2V0KGB0d2l0dGVyP3NjcmVlbl9uYW1lPSR7cGF5bG9hZC5uaWNrfWAsIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBgJHtwYXlsb2FkLnR5cGVPZkxvZ2luLnRvTG93ZXJDYXNlKCl9fCR7cmVzLmRhdGEudG9TdHJpbmcoKX1gO1xuICB9XG4gIGFzeW5jIHNlbmRFbWFpbChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHRoaXMud3NBcGlDbGllbnQuYXV0aFBvc3QoXCJ0cmFuc2FjdGlvbi9zZW5kZW1haWxcIiwgcGF5bG9hZC5lbWFpbE9iamVjdCwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVmcmVzaEp3dCgpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgY29uc3QgbWVzc2FnZVRvU2lnbiA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnZUZvclNpZ25pbmcoYWRkcmVzcyk7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZVNpZ25NZXNzYWdlKG1lc3NhZ2VUb1NpZ24pO1xuICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLnNpZ25BdXRoTWVzc2FnZShhZGRyZXNzLCBtZXNzYWdlVG9TaWduKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS9hdXRoL3ZlcmlmeWAsIHtcbiAgICAgIGNoYWxsZW5nZTogbWVzc2FnZVRvU2lnbixcbiAgICAgIHB1YmxpY19hZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgc2lnbmVkX21lc3NhZ2U6IHNpZ25lZE1lc3NhZ2VcbiAgICB9LCB7fSwge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBqd3RUb2tlbjogcmVzcG9uc2UudG9rZW5cbiAgICB9LCBhZGRyZXNzKTtcbiAgfVxuICBhc3luYyBnZXREYXBwTGlzdCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhHZXQoXCJkYXBwc1wiLCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uuc3VjY2VzcyA/IHJlc3BvbnNlLmRhdGEgOiBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGdldCBkYXBwcyBsaXN0XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RyYXRlZ3lcbiAgICogRm9yIGFjY291bnQgdHlwZTogdGhyZXNob2xkLCBub3JtYWwgKHdlYjNhdXRoIGxvZ2luKVxuICAgKiBpZFRva2VuIGZyb20gd2ViM2F1dGggbG9naW4gbXVzdCBiZSBwcmVzZW50LiBXZSB1c2UgaXQgZGlyZWN0bHlcbiAgICpcbiAgICogRm9yIGFjY291bnQgdHlwZTogYXBwX3Njb3BlZCwgSU1QT1JURURcbiAgICogaWRUb2tlbiBmcm9tIHdlYjNhdXRoIGxvZ2luIG11c3QgYmUgcHJlc2VudC4gV2UgcmVxdWVzdCBhIG1lc3NhZ2UgZm9yIHNpZ25pbmcgdXNpbmcgdGhlIGlkVG9rZW5cbiAgICogYW5kIHNpZ24gaXQgdXNpbmcgdGhlIHByaXZhdGUga2V5IG9mIHRoZSBhY2NvdW50LiBXZSB0aGVuIHNlbmQgdGhlIHNpZ25lZCBtZXNzYWdlIHRvIHRoZSBiYWNrZW5kXG4gICAqIHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlIGFuZCByZXR1cm4gYSBuZXcgand0VG9rZW4gdGhhdCBpbmNsdWRlcyB0aGUgYXBwX3Njb3BlZCBhZGRyZXNzXG4gICAqXG4gICAqIEZvciBhY2NvdW50IHR5cGU6IEFjY291bnQgYWJzdHJhY3Rpb25cbiAgICogaWRUb2tlbiBmcm9tIHdlYjNhdXRoIGxvZ2luIG11c3QgYmUgcHJlc2VudC4gV2UgdXNlIGl0IHRvIGV4Y2hhbmdlIGZvciBhIG5ldyBqd3RUb2tlbi5cbiAgICogQmVjYXVzZSBiYWNrZW5kIGNhbiBkZXJpdmUgQUEgYWRkcmVzcyBmcm9tIHB1YmxpYyBhZGRyZXNzIGFuZCBpc3N1ZSB0aGlzIHRva2VuIGVhc2lseS5cbiAgICpcbiAgICogRm9yIGFjY291bnQgdHlwZTogZXh0ZXJuYWxcbiAgICogaWRUb2tlbiBmcm9tIHdlYjNhdXRoIGBhdXRoZW50aWNhdGVVc2VyYCAoc2l3dykgbG9naW4gbXVzdCBiZSBwcmVzZW50LiBXZSB1c2UgaXQgZGlyZWN0bHlcbiAgICovXG4gIGFzeW5jIGluaXQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzcyxcbiAgICAgIHVzZXJJbmZvLFxuICAgICAgaWRUb2tlbixcbiAgICAgIG1ldGFkYXRhID0ge30sXG4gICAgICB0eXBlXG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAodGhpcy5nZXRBZGRyZXNzU3RhdGUoYWRkcmVzcykpIHJldHVybjtcbiAgICBsZXQgand0VG9rZW47XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuSU1QT1JURUQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWlkVG9rZW4pIHRocm93IG5ldyBFcnJvcihcIldlYjNBdXRoIGlkVG9rZW4gbXVzdCBiZSBwcmVzZW50XCIpO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSBhd2FpdCB0aGlzLmdldE1lc3NhZ2VGb3JTaWduaW5nKGFkZHJlc3MsIGlkVG9rZW4pO1xuICAgICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTaWduTWVzc2FnZShtZXNzYWdlVG9TaWduKTtcbiAgICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5zaWduQXV0aE1lc3NhZ2UoYWRkcmVzcywgbWVzc2FnZVRvU2lnbik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vYXV0aC92ZXJpZnlgLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIGNoYWxsZW5nZTogbWVzc2FnZVRvU2lnbixcbiAgICAgICAgICAgIGFjY291bnRfdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHB1YmxpY19hZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgc2lnbmVkX21lc3NhZ2U6IHNpZ25lZE1lc3NhZ2UsXG4gICAgICAgICAgICB2ZXJpZmllcjogdXNlckluZm8uYWdncmVnYXRlVmVyaWZpZXIgfHwgdXNlckluZm8udmVyaWZpZXIsXG4gICAgICAgICAgICB2ZXJpZmllcl9pZDogdXNlckluZm8udmVyaWZpZXJJZFxuICAgICAgICAgIH0sIG1ldGFkYXRhKSwge30sIHtcbiAgICAgICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGp3dFRva2VuID0gcmVzcG9uc2UudG9rZW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5FWFRFUk5BTDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaWRUb2tlbikgdGhyb3cgbmV3IEVycm9yKFwiU0lXVyBpZFRva2VuIG11c3QgYmUgcHJlc2VudFwiKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS9hdXRoL3ZlcmlmeWAsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgYWNjb3VudF90eXBlOiB0eXBlLFxuICAgICAgICAgICAgcHVibGljX2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBpZF90b2tlbjogaWRUb2tlbixcbiAgICAgICAgICAgIHZlcmlmaWVyOiB1c2VySW5mby5hZ2dyZWdhdGVWZXJpZmllciB8fCB1c2VySW5mby52ZXJpZmllcixcbiAgICAgICAgICAgIHZlcmlmaWVyX2lkOiB1c2VySW5mby52ZXJpZmllcklkXG4gICAgICAgICAgfSwgbWV0YWRhdGEpLCB7fSwge1xuICAgICAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgand0VG9rZW4gPSByZXNwb25zZS50b2tlbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLkFDQ09VTlRfQUJTVFJBQ1RJT046XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWlkVG9rZW4pIHRocm93IG5ldyBFcnJvcihcIldlYjNBdXRoIGlkVG9rZW4gbXVzdCBiZSBwcmVzZW50XCIpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvdmVyaWZ5YCwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICBwdWJsaWNfYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIGlkX3Rva2VuOiBpZFRva2VuLFxuICAgICAgICAgICAgdmVyaWZpZXI6IHVzZXJJbmZvLmFnZ3JlZ2F0ZVZlcmlmaWVyIHx8IHVzZXJJbmZvLnZlcmlmaWVyLFxuICAgICAgICAgICAgdmVyaWZpZXJfaWQ6IHVzZXJJbmZvLnZlcmlmaWVySWQsXG4gICAgICAgICAgICBhY2NvdW50X3R5cGU6IHR5cGVcbiAgICAgICAgICB9LCBtZXRhZGF0YSksIHt9LCB7XG4gICAgICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBqd3RUb2tlbiA9IHJlc3BvbnNlLnRva2VuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuTVBDOlxuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLlNGQTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbWV0YWRhdGEuc2lnbmF0dXJlcykgdGhyb3cgbmV3IEVycm9yKFwiTVBDIHNpZ25hdHVyZXMgbXVzdCBiZSBwcmVzZW50XCIpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvdmVyaWZ5YCwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICBwdWJsaWNfYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIHZlcmlmaWVyOiB1c2VySW5mby5hZ2dyZWdhdGVWZXJpZmllciB8fCB1c2VySW5mby52ZXJpZmllcixcbiAgICAgICAgICAgIHZlcmlmaWVyX2lkOiB1c2VySW5mby52ZXJpZmllcklkLFxuICAgICAgICAgICAgYWNjb3VudF90eXBlOiB0eXBlXG4gICAgICAgICAgfSwgbWV0YWRhdGEpLCB7fSwge1xuICAgICAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgand0VG9rZW4gPSByZXNwb25zZS50b2tlbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLk5PUk1BTDpcbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5USFJFU0hPTEQ6XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuQVBQX1NDT1BFRDpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICghaWRUb2tlbikgdGhyb3cgbmV3IEVycm9yKFwiV2ViM0F1dGggaWRUb2tlbiBtdXN0IGJlIHByZXNlbnRcIik7XG4gICAgICAgIGp3dFRva2VuID0gaWRUb2tlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgand0VG9rZW4sXG4gICAgICB1c2VySW5mbyxcbiAgICAgIGFjY291bnRUeXBlOiB0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHZvaWQgMCA/IHR5cGUgOiB0aGlzLmRlZmF1bHRQcmVmZXJlbmNlcy5hY2NvdW50VHlwZVxuICAgIH0sIGFkZHJlc3MpO1xuICB9XG4gIHVwZGF0ZVN0YXRlKHByZWZlcmVuY2VzLCBhZGRyZXNzKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gYWRkcmVzcyB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZShzZWxlY3RlZEFkZHJlc3MpIHx8IGNsb25lRGVlcCh0aGlzLmRlZmF1bHRQcmVmZXJlbmNlcyk7XG4gICAgY29uc3QgbWVyZ2VkU3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJlbnRTdGF0ZSksIHByZWZlcmVuY2VzKTtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBpZGVudGl0aWVzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuc3RhdGUuaWRlbnRpdGllcyksIHt9LCB7XG4gICAgICAgIFtzZWxlY3RlZEFkZHJlc3NdOiBtZXJnZWRTdGF0ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gbWVyZ2VkU3RhdGU7XG4gIH1cbiAgYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNztcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIGNvbnN0IGp3dFRva2VuID0gKChfdGhpcyRnZXRBZGRyZXNzU3RhdGU3ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoc2VsZWN0ZWRBZGRyZXNzKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNy5qd3RUb2tlbikgfHwgXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgand0VG9rZW4sXG4gICAgICBwdWJsaWNBZGRyZXNzOiBzZWxlY3RlZEFkZHJlc3NcbiAgICB9O1xuICB9XG4gIGhlYWRlcnMoYWRkcmVzcykge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU4O1xuICAgIGNvbnN0IHNlbGVjdGVkQWRkcmVzcyA9IGFkZHJlc3MgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgcmV0dXJuIGdldEhlYWRlcnMoKChfdGhpcyRnZXRBZGRyZXNzU3RhdGU4ID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoc2VsZWN0ZWRBZGRyZXNzKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QWRkcmVzc1N0YXRlOC5qd3RUb2tlbikgfHwgXCJcIiwgc2VsZWN0ZWRBZGRyZXNzKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBzdGF0dXMgb2YgdGhlIHRyYW5zYWN0aW9uLiBFYWNoIHN0YXR1cyByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgdHJhbnNhY3Rpb24gaW50ZXJuYWxseVxuICogaW4gdGhlIHdhbGxldC4gU29tZSBvZiB0aGVzZSBjb3JyZXNwb25kIHdpdGggdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgbmV0d29yaywgYnV0XG4gKiBzb21lIGFyZSB3YWxsZXQtc3BlY2lmaWMuXG4gKi9cblxubGV0IFRyYW5zYWN0aW9uU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImFwcHJvdmVkXCJdID0gXCJhcHByb3ZlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImNhbmNlbGxlZFwiXSA9IFwiY2FuY2VsbGVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiY2FuY2VsbGluZ1wiXSA9IFwiY2FuY2VsbGluZ1wiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImNvbmZpcm1lZFwiXSA9IFwiY29uZmlybWVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiZmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJmaW5hbGl6ZWRcIl0gPSBcImZpbmFsaXplZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcInByb2Nlc3NlZFwiXSA9IFwicHJvY2Vzc2VkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wicmVqZWN0ZWRcIl0gPSBcInJlamVjdGVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wic2lnbmVkXCJdID0gXCJzaWduZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJzdWJtaXR0ZWRcIl0gPSBcInN1Ym1pdHRlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcInVuYXBwcm92ZWRcIl0gPSBcInVuYXBwcm92ZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJkcm9wcGVkXCJdID0gXCJkcm9wcGVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiZXhwaXJlZFwiXSA9IFwiZXhwaXJlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzO1xufSh7fSk7XG5jb25zdCBUUkFOU0FDVElPTl9UWVBFUyA9IHtcbiAgQ0FOQ0VMOiBcImNhbmNlbFwiLFxuICBSRVRSWTogXCJyZXRyeVwiLFxuICBDT05UUkFDVF9JTlRFUkFDVElPTjogXCJjb250cmFjdEludGVyYWN0aW9uXCIsXG4gIERFUExPWV9DT05UUkFDVDogXCJjb250cmFjdERlcGxveW1lbnRcIixcbiAgV0FTTV9CQVNFRF9ERVBMT1k6IFwid2FzbUJhc2VkRGVwbG95XCIsXG4gIFNUQU5EQVJEX1RSQU5TQUNUSU9OOiBcInRyYW5zYWN0aW9uXCIsXG4gIFNUQU5EQVJEX1BBWU1FTlRfVFJBTlNBQ1RJT046IFwicGF5bWVudF90cmFuc2FjdGlvblwiLFxuICAvLyBzcGVjaWZpYyB0byBjaGFpbnMgbGlrZSBzb2xhbmEgYW5kIGNhc3BlclxuICBTRU5UX0VUSEVSOiBcInNlbnRFdGhlclwiLFxuICBUT0tFTl9NRVRIT0RfVFJBTlNGRVI6IFwidHJhbnNmZXJcIixcbiAgVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST006IFwidHJhbnNmZXJGcm9tXCIsXG4gIFRPS0VOX01FVEhPRF9BUFBST1ZFOiBcImFwcHJvdmVcIixcbiAgQ09MTEVDVElCTEVfTUVUSE9EX1NBRkVfVFJBTlNGRVJfRlJPTTogXCJzYWZlVHJhbnNmZXJGcm9tXCIsXG4gIFNFVF9BUFBST1ZBTF9GT1JfQUxMOiBcInNldEFwcHJvdmFsRm9yQWxsXCJcbn07XG5jb25zdCBUWF9FVkVOVFMgPSB7XG4gIFRYX1dBUk5JTkc6IFwidHg6d2FybmluZ1wiLFxuICBUWF9FUlJPUjogXCJ0eDplcnJvclwiLFxuICBUWF9GQUlMRUQ6IFwidHg6ZmFpbGVkXCIsXG4gIFRYX0NPTkZJUk1FRDogXCJ0eDpjb25maXJtZWRcIixcbiAgVFhfRFJPUFBFRDogXCJ0eDpkcm9wcGVkXCIsXG4gIFRYX0VYUElSRUQ6IFwidHg6ZXhwaXJlZFwiLFxuICBUWF9TVEFUVVNfVVBEQVRFOiBcInR4OnN0YXR1c191cGRhdGVcIixcbiAgVFhfVU5BUFBST1ZFRDogXCJ0eDp1bmFwcHJvdmVkXCIsXG4gIFRYX1JFVFJZOiBcInR4OnJldHJ5XCIsXG4gIFRYX0JMT0NLX1VQREFURTogXCJ0eDpibG9ja191cGRhdGVcIlxufTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb25cbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNvbnRyb2xsZXIgc3RhdGVcbiAqL1xuXG4vKipcbiAqIFJlc3VsdFxuICpcbiAqIHJlc3VsdCAtIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgbmV3IHRyYW5zYWN0aW9uIGhhc2hcbiAqIHRyYW5zYWN0aW9uTWV0YSAtIE1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBuZXcgdHJhbnNhY3Rpb25cbiAqL1xuXG5jbGFzcyBCYXNlVHJhbnNhY3Rpb25TdGF0ZU1hbmFnZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcsXG4gICAgc3RhdGUsXG4gICAgZ2V0Q3VycmVudENoYWluSWRcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0Q3VycmVudENoYWluSWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICB0eEhpc3RvcnlMaW1pdDogNDBcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgdHJhbnNhY3Rpb25zOiB7fSxcbiAgICAgIHVuYXBwcm92ZWRUeHM6IHt9LFxuICAgICAgY3VycmVudE5ldHdvcmtUeHNMaXN0OiBbXVxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuICB9XG4gIGdldFVuYXBwcm92ZWRUeExpc3QoKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICByZXR1cm4gcGlja0J5KHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQgJiYgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayh0cmFuc2FjdGlvbiwgY2hhaW5JZCkpO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uKHR4SWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25zW3R4SWRdO1xuICB9XG4gIHVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSkge1xuICAgIC8vIGNvbW1pdCB0eE1ldGEgdG8gc3RhdGVcbiAgICBjb25zdCB0eElkID0gdHhNZXRhLmlkO1xuICAgIHR4TWV0YS51cGRhdGVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucyksIHt9LCB7XG4gICAgICAgIFt0eElkXTogdHhNZXRhXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNldFR4U3RhdHVzUmVqZWN0ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkKTtcbiAgICB0aGlzLl9kZWxldGVUcmFuc2FjdGlvbih0eElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW1wbGVtZW50aW5nIGNvbnRyb2xsZXIgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb25hbGl0eSBhbmQgYWRkIGN1c3RvbSBsb2dpYyArIGNhbGwgc3VwZXIuKClcbiAgICovXG4gIHNldFR4U3RhdHVzVW5hcHByb3ZlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNBcHByb3ZlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuYXBwcm92ZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzU2lnbmVkKHR4SWQsIGlzRmluYWxTdGVwKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuc2lnbmVkLCBpc0ZpbmFsU3RlcCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNTdWJtaXR0ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNEcm9wcGVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5kcm9wcGVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c0V4cGlyZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmV4cGlyZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzQ29uZmlybWVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzRmFpbGVkKHR4SWQsIGVycm9yXykge1xuICAgIGNvbnN0IGVycm9yID0gIWVycm9yXyA/IG5ldyBFcnJvcihcIkludGVybmFsIHRvcnVzIGZhaWx1cmVcIikgOiBlcnJvcl87XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy5nZXRUcmFuc2FjdGlvbih0eElkKTtcbiAgICB0eE1ldGEuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSk7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiBhIGZpbmFsIHN0YXRlXG4gICAqIEBwYXJhbSBzdGF0dXMgLSBUcmFuc2FjdGlvbiBzdGF0dXNcbiAgICogQHJldHVybnMgYm9vbGVhbiBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gYSBmaW5hbCBzdGF0ZVxuICAgKi9cbiAgaXNGaW5hbFN0YXRlKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkIHx8IHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZXhwaXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIG91dCB0aGUgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgZnJvbSBzdGF0ZVxuICAgKi9cbiAgY2xlYXJVbmFwcHJvdmVkVHhzKCkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczogb21pdEJ5KHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogd2lsbCBhcHBlbmQgbmV3IHRyYW5zYWN0aW9ucyB0byBvbGQgdHhucy5cbiAgICovXG4gIF9hZGRUcmFuc2FjdGlvbnNUb1N0YXRlKHRyYW5zYWN0aW9ucykge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLnJlZHVjZSgocmVzdWx0LCBuZXdUeCkgPT4ge1xuICAgICAgICByZXN1bHRbbmV3VHguaWRdID0gbmV3VHg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiB3aWxsIHNldCBuZXcgdHhucywgb3ZlcnJpZGUgZXhpc3RpbmcgaWYgYW55IGluIHN0YXRlLlxuICAgKi9cbiAgX3NldFRyYW5zYWN0aW9uc1RvU3RhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMucmVkdWNlKChyZXN1bHQsIG5ld1R4KSA9PiB7XG4gICAgICAgIHJlc3VsdFtuZXdUeC5pZF0gPSBuZXdUeDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KVxuICAgIH0pO1xuICB9XG4gIF9kZWxldGVUcmFuc2FjdGlvbih0YXJnZXRUcmFuc2FjdGlvbklkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgZGVsZXRlIHRyYW5zYWN0aW9uc1t0YXJnZXRUcmFuc2FjdGlvbklkXTtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBfZGVsZXRlVHJhbnNhY3Rpb25zKHRhcmdldFRyYW5zYWN0aW9uSWRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGFyZ2V0VHJhbnNhY3Rpb25JZHMuZm9yRWFjaCh0cmFuc2FjdGlvbklkID0+IHtcbiAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZF07XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIHN0YXR1cywgaXNGaW5hbFN0ZXApIHtcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIGlmICghdHhNZXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHR4TWV0YS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgLy8gb25seSB1cGRhdGluZyBzdGF0dXMgc28gbm8gdmFsaWRhdGlvbiByZXF1aXJlZCBvbiB0eG4uXG4gICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0eE1ldGEpO1xuICAgIHRoaXMuZW1pdChUWF9FVkVOVFMuVFhfU1RBVFVTX1VQREFURSwge1xuICAgICAgdHhJZCxcbiAgICAgIHN0YXR1c1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmlzRmluYWxTdGF0ZShzdGF0dXMpIHx8IGlzRmluYWxTdGVwKSB7XG4gICAgICB0aGlzLmVtaXQoYCR7dHhNZXRhLmlkfTpmaW5pc2hlZGAsIHR4TWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdChgJHt0eE1ldGEuaWR9OiR7c3RhdHVzfWAsIHR4SWQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBBQ0NPVU5UX0NBVEVHT1JZLCBBQ1RJVklUWV9BQ1RJT04sIEFDVElWSVRZX0FDVElPTl9BQ0NFUFRfTkZUX09GRkVSLCBBQ1RJVklUWV9BQ1RJT05fQUxMLCBBQ1RJVklUWV9BQ1RJT05fQlVSTiwgQUNUSVZJVFlfQUNUSU9OX0NBTkNFTF9ORlRfT0ZGRVIsIEFDVElWSVRZX0FDVElPTl9DUkVBVEVfTkZUX09GRkVSLCBBQ1RJVklUWV9BQ1RJT05fQ1JFQVRFX1RSVVNUTElORSwgQUNUSVZJVFlfQUNUSU9OX1JFQ0VJVkUsIEFDVElWSVRZX0FDVElPTl9SRU1PVkVfVFJVU1RMSU5FLCBBQ1RJVklUWV9BQ1RJT05fU0VORCwgQUNUSVZJVFlfQUNUSU9OX1RPUFVQLCBBQ1RJVklUWV9QRVJJT0RfQUxMLCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfT05FLCBBQ1RJVklUWV9QRVJJT0RfTU9OVEhfU0lYLCBBQ1RJVklUWV9QRVJJT0RfV0VFS19PTkUsIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMRUQsIEFDVElWSVRZX1NUQVRVU19DQU5DRUxMSU5HLCBBQ1RJVklUWV9TVEFUVVNfUEVORElORywgQUNUSVZJVFlfU1RBVFVTX1NVQ0NFU1NGVUwsIEFDVElWSVRZX1NUQVRVU19VTlNVQ0NFU1NGVUwsIEJST0FEQ0FTVF9DSEFOTkVMUywgQlJPQURDQVNUX0NIQU5ORUxTX01TR1MsIEJVVFRPTl9QT1NJVElPTiwgQmFzZUJsb2NrVHJhY2tlciwgQmFzZUNvbnRyb2xsZXIsIEJhc2VDdXJyZW5jeUNvbnRyb2xsZXIsIEJhc2VFbWJlZENvbnRyb2xsZXIsIEJhc2VLZXlyaW5nQ29udHJvbGxlciwgQmFzZVByZWZlcmVuY2VzQ29udHJvbGxlciwgQmFzZVRyYW5zYWN0aW9uU3RhdGVNYW5hZ2VyLCBCcm9hZGNhc3RDaGFubmVsSGFuZGxlciwgQ0hBSU5fTkFNRVNQQUNFUywgQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMsIENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUywgQ09ORklSTUFUSU9OX1NUUkFURUdZLCBDb21tdW5pY2F0aW9uV2luZG93TWFuYWdlciwgQ29udHJvbGxlckV2ZW50cywgREVGQVVMVF9QUkVGRVJFTkNFUywgRkVBVFVSRVNfQ09ORklSTV9XSU5ET1csIEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XLCBGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1csIEZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1csIExPR0lOX1BST1ZJREVSLCBQQVlNRU5UX1BST1ZJREVSLCBQT1BVUF9MT0FERUQsIFBPUFVQX1JFU1VMVCwgUFJPVklERVJfSlJQQ19NRVRIT0RTLCBQUk9WSURFUl9OT1RJRklDQVRJT05TLCBQb3B1cEhhbmRsZXIsIFBvcHVwU3RvcmVDaGFubmVsLCBQb3B1cFdpdGhCY0hhbmRsZXIsIFJlZGlyZWN0SGFuZGxlciwgU0VUVVBfQ09NUExFVEUsIFN0cmVhbVdpbmRvdywgVFJBTlNBQ1RJT05fVFlQRVMsIFRYX0VWRU5UUywgVHJhbnNhY3Rpb25TdGF0dXMsIFVzZXJFcnJvciwgV1NBcGlDbGllbnQsIGFkZHJlc3NTbGljZXIsIGF1dGhTZXJ2ZXIsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zLCBjbG9uZURlZXAsIGNvbmNhdFNpZywgY3JlYXRlQ2hhbmdlUHJvdmlkZXJNaWRkbGV3YXJlTWlkZGxld2FyZSwgY3JlYXRlQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUsIGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5LCBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEsIGNyZWF0ZUZldGNoTWlkZGxld2FyZSwgY3JlYXRlR2VuZXJpY0pSUENNaWRkbGV3YXJlLCBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSwgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSwgY3JlYXRlT3JpZ2luTWlkZGxld2FyZSwgY3JlYXRlUmFuZG9tSWQsIGNyZWF0ZVN3YXBwYWJsZVByb3h5LCBjcmVhdGVUb3B1cE1pZGRsZXdhcmUsIGZvcm1hdERhdGUsIGZvcm1hdFNtYWxsTnVtYmVycywgZm9ybWF0VGltZSwgZ2V0Q3VzdG9tRGV2aWNlSW5mbywgZ2V0SGVhZGVycywgZ2V0UG9wdXBGZWF0dXJlcywgZ2V0VHhTdGF0dXNUZXh0LCBoYW5kbGVSZWRpcmVjdFBhcmFtZXRlcnMsIGhhc2hNZXNzYWdlLCBpbnRUb0hleCwgaXNVbmF1dGhvcml6ZWRFcnJvciwgb21pdEJ5LCBwYWRXaXRoWmVyb2VzLCBwaWNrQnksIHJhbmRvbUlkLCBzaWduQ2hhbGxlbmdlLCBzaWduTWVzc2FnZSwgc2lnbmlmaWNhbnREaWdpdHMsIHNsZWVwLCB0aW1lb3V0JDEgYXMgdGltZW91dCwgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yaywgdmVyaWZ5U2lnbmVkQ2hhbGxlbmdlIH07XG4iXSwibmFtZXMiOlsiX29iamVjdFNwcmVhZCIsIl9kZWZpbmVQcm9wZXJ0eSIsIlNhZmVFdmVudEVtaXR0ZXIiLCJjcmVhdGVBc3luY01pZGRsZXdhcmUiLCJtZXJnZU1pZGRsZXdhcmUiLCJjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUiLCJKUlBDRW5naW5lIiwicHJvdmlkZXJGcm9tRW5naW5lIiwicnBjRXJyb3JzIiwicG9zdCIsImdldCIsInB1dCIsInBhdGNoIiwicmVtb3ZlIiwibG9nIiwiZnJvbVNpZ25lZCIsImJ5dGVzVG9CaWdJbnQiLCJ0b1Vuc2lnbmVkIiwic3RyaXBIZXhQcmVmaXgiLCJiaWdJbnRUb0hleCIsImFkZEhleFByZWZpeCIsImhhc2hQZXJzb25hbE1lc3NhZ2UiLCJlY3NpZ24iLCJiaWdJbnRUb0J5dGVzIiwic2FmZWF0b2IiLCJCaWdOdW1iZXIiLCJCcm9hZGNhc3RDaGFubmVsIiwiYm93c2VyIiwiand0RGVjb2RlIiwiQmFzZUNvbnRyb2xsZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsInN0YXRlIiwiZGVmYXVsdENvbmZpZyIsImRlZmF1bHRTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImluaXRpYWxDb25maWciLCJpbnRlcm5hbENvbmZpZyIsImludGVybmFsU3RhdGUiLCJjb25maWd1cmUiLCJvdmVyd3JpdGUiLCJmdWxsVXBkYXRlIiwiT2JqZWN0IiwiYXNzaWduIiwia2V5IiwidXBkYXRlIiwiZW1pdCIsImluaXRpYWxpemUiLCJzZWMiLCJjYWxjdWxhdGVTdW0iLCJhY2N1bXVsYXRvciIsImN1cnJlbnRWYWx1ZSIsImJsb2NrVHJhY2tlckV2ZW50cyIsIkJhc2VCbG9ja1RyYWNrZXIiLCJfY3VycmVudEJsb2NrIiwiaWRlbXBvdGVuY3lLZXkiLCJfaXNSdW5uaW5nIiwiYmxvY2tSZXNldER1cmF0aW9uIiwiX29uTmV3TGlzdGVuZXIiLCJiaW5kIiwiX29uUmVtb3ZlTGlzdGVuZXIiLCJfcmVzZXRDdXJyZW50QmxvY2siLCJfc2V0dXBJbnRlcm5hbEV2ZW50cyIsImlzUnVubmluZyIsImdldEN1cnJlbnRCbG9jayIsImdldExhdGVzdEJsb2NrIiwibGF0ZXN0QmxvY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9uY2UiLCJibG9jayIsInJlbW92ZUFsbExpc3RlbmVycyIsImV2ZW50TmFtZSIsIl9zdGFydCIsIl9lbmQiLCJfbmV3UG90ZW50aWFsTGF0ZXN0IiwibmV3QmxvY2siLCJjdXJyZW50QmxvY2siLCJfc2V0Q3VycmVudEJsb2NrIiwicmVtb3ZlTGlzdGVuZXIiLCJvbiIsIl9tYXliZVN0YXJ0IiwiX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQiLCJfbWF5YmVFbmQiLCJfY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQiLCJfc2V0dXBCbG9ja1Jlc2V0VGltZW91dCIsIm1hcCIsImxpc3RlbmVyQ291bnQiLCJyZWR1Y2UiLCJvbGRCbG9jayIsIl9ibG9ja1Jlc2V0VGltZW91dCIsInNldFRpbWVvdXQiLCJ1bnJlZiIsImNsZWFyVGltZW91dCIsImZpbHRlck5vb3AiLCJpbnRlcm5hbEV2ZW50cyIsImV4dGVybmFsRXZlbnRGaWx0ZXIiLCJuYW1lIiwiaW5jbHVkZXMiLCJnZXRSYXdMaXN0ZW5lcnMiLCJldmVudEVtaXR0ZXIiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJjcmVhdGVFdmVudEVtaXR0ZXJQcm94eSIsImluaXRpYWxUYXJnZXQiLCJvcHRzIiwiZmluYWxPcHRzIiwiZXZlbnRGaWx0ZXIiLCJFcnJvciIsInRhcmdldCIsInNldFRhcmdldCIsIm5ld1RhcmdldCIsIm9sZFRhcmdldCIsImV2ZW50TmFtZXMiLCJmaWx0ZXIiLCJmb3JFYWNoIiwiaGFuZGxlciIsInByb3h5IiwiUHJveHkiLCJfIiwic2V0IiwidmFsdWUiLCJjcmVhdGVTd2FwcGFibGVQcm94eSIsIlBPTExJTkdfSU5URVJWQUwiLCJCYXNlQ3VycmVuY3lDb250cm9sbGVyIiwiY3VycmVudEN1cnJlbmN5IiwiY29udmVyc2lvblJhdGUiLCJjb252ZXJzaW9uRGF0ZSIsIm5hdGl2ZUN1cnJlbmN5IiwicG9sbEludGVydmFsIiwiZ2V0TmF0aXZlQ3VycmVuY3kiLCJzZXROYXRpdmVDdXJyZW5jeSIsInRpY2tlciIsImdldEN1cnJlbnRDdXJyZW5jeSIsInNldEN1cnJlbnRDdXJyZW5jeSIsImdldENvbnZlcnNpb25SYXRlIiwic2V0Q29udmVyc2lvblJhdGUiLCJnZXRDb252ZXJzaW9uRGF0ZSIsInNldENvbnZlcnNpb25EYXRlIiwiRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVyIsImhlaWdodCIsIndpZHRoIiwiRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XIiwiRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1ciLCJGRUFUVVJFU19DT05GSVJNX1dJTkRPVyIsIlBPUFVQX0xPQURFRCIsIlBPUFVQX1JFU1VMVCIsIlNFVFVQX0NPTVBMRVRFIiwiQUNUSVZJVFlfQUNUSU9OX0FMTCIsIkFDVElWSVRZX0FDVElPTl9TRU5EIiwiQUNUSVZJVFlfQUNUSU9OX0JVUk4iLCJBQ1RJVklUWV9BQ1RJT05fUkVDRUlWRSIsIkFDVElWSVRZX0FDVElPTl9UT1BVUCIsIkFDVElWSVRZX0FDVElPTl9DUkVBVEVfVFJVU1RMSU5FIiwiQUNUSVZJVFlfQUNUSU9OX1JFTU9WRV9UUlVTVExJTkUiLCJBQ1RJVklUWV9BQ1RJT05fQ1JFQVRFX05GVF9PRkZFUiIsIkFDVElWSVRZX0FDVElPTl9BQ0NFUFRfTkZUX09GRkVSIiwiQUNUSVZJVFlfQUNUSU9OX0NBTkNFTF9ORlRfT0ZGRVIiLCJBQ1RJVklUWV9QRVJJT0RfQUxMIiwiQUNUSVZJVFlfUEVSSU9EX1dFRUtfT05FIiwiQUNUSVZJVFlfUEVSSU9EX01PTlRIX09ORSIsIkFDVElWSVRZX1BFUklPRF9NT05USF9TSVgiLCJBQ1RJVklUWV9TVEFUVVNfU1VDQ0VTU0ZVTCIsIkFDVElWSVRZX1NUQVRVU19VTlNVQ0NFU1NGVUwiLCJBQ1RJVklUWV9TVEFUVVNfUEVORElORyIsIkFDVElWSVRZX1NUQVRVU19DQU5DRUxMRUQiLCJBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTElORyIsIkNPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUyIsIklGUkFNRV9TVEFUVVMiLCJDTE9TRV9XSU5ET1ciLCJVU0VSX0xPR0dFRF9JTiIsIlVTRVJfTE9HR0VEX09VVCIsIkNPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTIiwiTE9HT1VUIiwiV0FMTEVUX0lOU1RBTkNFX0lEIiwiVVNFUl9JTkZPIiwiU0VUX1BST1ZJREVSIiwiVE9QVVAiLCJDTE9TRURfV0lORE9XIiwiV0lORE9XX0JMT0NLRUQiLCJHRVRfUFJPVklERVJfU1RBVEUiLCJMT0dJTl9XSVRIX1BSSVZBVEVfS0VZIiwiU0hPV19XQUxMRVRfQ09OTkVDVCIsIlNIT1dfQ0hFQ0tPVVQiLCJTSE9XX1dBTExFVF9VSSIsIkxPR0lOX1dJVEhfU0VTU0lPTl9JRCIsIlBST1ZJREVSX0pSUENfTUVUSE9EUyIsIlBST1ZJREVSX05PVElGSUNBVElPTlMiLCJBQ0NPVU5UU19DSEFOR0VEIiwiQ0hBSU5fQ0hBTkdFRCIsIlVOTE9DS19TVEFURV9DSEFOR0VEIiwiQlJPQURDQVNUX0NIQU5ORUxTIiwiUkVESVJFQ1RfQ0hBTk5FTCIsIlBST1ZJREVSX0NIQU5HRV9DSEFOTkVMIiwiVFJBTlNBQ1RJT05fQ0hBTk5FTCIsIk1FU1NBR0VfQ0hBTk5FTCIsIldBTExFVF9MT0dPVVRfQ0hBTk5FTCIsIldBTExFVF9TRUxFQ1RFRF9BRERSRVNTX0NIQU5ORUwiLCJXQUxMRVRfTkVUV09SS19DSEFOR0VfQ0hBTk5FTCIsIldBTExFVF9BQ0NPVU5UX0lNUE9SVF9DSEFOTkVMIiwiVEhFTUVfQ0hBTkdFIiwiVE9QX1VQX0NIQU5ORUwiLCJCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUyIsIkFDQ09VTlRfSU1QT1JURUQiLCJTRUxFQ1RFRF9BRERSRVNTX0NIQU5HRSIsIk5FVFdPUktfQ0hBTkdFIiwiU0VUX1RIRU1FIiwiQ29udHJvbGxlckV2ZW50cyIsImNyZWF0ZUNoYW5nZVByb3ZpZGVyTWlkZGxld2FyZU1pZGRsZXdhcmUiLCJjaGFuZ2VQcm92aWRlciIsInJlcXVlc3QiLCJyZXNwb25zZSIsIm5leHQiLCJtZXRob2QiLCJyZXN1bHQiLCJjcmVhdGVUb3B1cE1pZGRsZXdhcmUiLCJ0b3B1cCIsImNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZSIsInRhcmdldE1ldGhvZCIsInVuZGVmaW5lZCIsImNyZWF0ZUNvbW11bmljYXRpb25NaWRkbGV3YXJlIiwicHJvdmlkZXJIYW5kbGVycyIsImdldFVzZXJJbmZvIiwiZ2V0V2FsbGV0SW5zdGFuY2VJZCIsImxvZ291dCIsInNldElGcmFtZVN0YXR1cyIsImhhbmRsZVdpbmRvd1JwYyIsImdldFByb3ZpZGVyU3RhdGUiLCJsb2dpbldpdGhQcml2YXRlS2V5Iiwic2hvd1dhbGxldENvbm5lY3QiLCJzaG93Q2hlY2tvdXQiLCJzaG93V2FsbGV0VWkiLCJzaG93V2luZG93QmxvY2tBbGVydCIsImxvZ2luV2l0aFNlc3Npb25JZCIsIkJhc2VFbWJlZENvbnRyb2xsZXIiLCJpc0lGcmFtZUZ1bGxTY3JlZW4iLCJvYXV0aE1vZGFsVmlzaWJpbGl0eSIsImxvZ2luSW5Qcm9ncmVzcyIsImRhcHBNZXRhZGF0YSIsImljb24iLCJ3ZWIzQXV0aENsaWVudElkIiwid2ViM0F1dGhOZXR3b3JrIiwid2hpdGVMYWJlbCIsImNvbmZpcm1hdGlvblN0cmF0ZWd5IiwiaW5pdGlhbGl6ZVByb3ZpZGVyIiwiaGFuZGxlcnMiLCJlbmdpbmUiLCJjb21tdW5pY2F0aW9uTWlkZGxld2FyZSIsInB1c2giLCJjb21tdW5pY2F0aW9uUHJvdmlkZXIiLCJzZXRDb21tdW5pY2F0aW9uUHJvdmlkZXIiLCJfY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHkiLCJDb21tdW5pY2F0aW9uV2luZG93TWFuYWdlciIsImFyZ3MiLCJlbmQiLCJwYXJhbXMiLCJ3aW5kb3dJZCIsIkJVVFRPTl9QT1NJVElPTiIsIkJPVFRPTV9MRUZUIiwiVE9QX0xFRlQiLCJCT1RUT01fUklHSFQiLCJUT1BfUklHSFQiLCJDT05GSVJNQVRJT05fU1RSQVRFR1kiLCJQT1BVUCIsIk1PREFMIiwiQVVUT19BUFBST1ZFIiwiREVGQVVMVCIsIkxPR0lOX1BST1ZJREVSIiwiR09PR0xFIiwiRkFDRUJPT0siLCJSRURESVQiLCJESVNDT1JEIiwiVFdJVENIIiwiQVBQTEUiLCJMSU5FIiwiR0lUSFVCIiwiS0FLQU8iLCJMSU5LRURJTiIsIlRXSVRURVIiLCJXRUlCTyIsIldFQ0hBVCIsIkVNQUlMX1BBU1NXT1JETEVTUyIsIlNNU19QQVNTV09SRExFU1MiLCJQQVlNRU5UX1BST1ZJREVSIiwiTU9PTlBBWSIsIldZUkUiLCJSQU1QTkVUV09SSyIsIlhBTlBPT0wiLCJNRVJDVVJZTyIsIlRSQU5TQUsiLCJvbWl0QnkiLCJvYmplY3QiLCJwcmVkaWNhdGUiLCJlbnRyaWVzIiwicGlja0J5IiwiY2xvbmVEZWVwIiwic3RydWN0dXJlZENsb25lIiwiZXJyb3IiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJhdXRoU2VydmVyIiwic2lnbkNoYWxsZW5nZSIsInBheWxvYWQiLCJjaGFpbk5hbWVzcGFjZSIsInQiLCJoZWFkZXIiLCJuZXR3b3JrIiwiZGF0YSIsInJlcyIsInN1Y2Nlc3MiLCJjaGFsbGVuZ2UiLCJ2ZXJpZnlTaWduZWRDaGFsbGVuZ2UiLCJzaWduZWRNZXNzYWdlIiwiaXNzdWVyIiwic2Vzc2lvblRpbWUiLCJjbGllbnRJZCIsImF1ZGllbmNlIiwiYWRkaXRpb25hbE1ldGFkYXRhIiwiX3dpbmRvdyRsb2NhdGlvbiIsInNpZ0RhdGEiLCJzaWduYXR1cmUiLCJzIiwibWVzc2FnZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJ0aW1lb3V0IiwiaWRUb2tlblJlcyIsImhlYWRlcnMiLCJjbGllbnRfaWQiLCJ3YWxsZXRfcHJvdmlkZXIiLCJ3ZWIzYXV0aF9uZXR3b3JrIiwidG9rZW4iLCJnZXRUeFN0YXR1c1RleHQiLCJ0eFN0YXR1cyIsImludFRvSGV4IiwiaSIsImhleCIsInRvU3RyaW5nIiwicmFuZG9tSWQiLCJNYXRoIiwicmFuZG9tIiwic2xpY2UiLCJwYWRXaXRoWmVyb2VzIiwiaGV4U3RyaW5nIiwidGFyZ2V0TGVuZ3RoIiwidGVzdCIsIlN0cmluZyIsInByb3RvdHlwZSIsInBhZFN0YXJ0IiwiY2FsbCIsImNvbmNhdFNpZyIsInYiLCJyIiwiclNpZyIsInNTaWciLCJ2U2lnIiwiclN0ciIsIkJ1ZmZlciIsImZyb20iLCJzU3RyIiwidlN0ciIsImNvbmNhdCIsInRpbWVvdXQkMSIsImR1cmF0aW9uIiwidGltZW91dFJlZiIsImdldEhlYWRlcnMiLCJqd3QiLCJwdWJsaWNBZGRyZXNzIiwiQXV0aG9yaXphdGlvbiIsImZvcm1hdFNtYWxsTnVtYmVycyIsIm51bWJlciIsImN1cnJlbmN5Iiwibm9UaWxkZSIsImZpbmFsTnVtYmVyIiwiaXNCaWdOdW1iZXIiLCJ0b051bWJlciIsIk51bWJlciIsImlzRmluaXRlIiwidG9Mb3dlckNhc2UiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInRpbGRlIiwidG9VcHBlckNhc2UiLCJhZGRyZXNzU2xpY2VyIiwiYWRkcmVzcyIsInNsaWNlTGVuZ3RoIiwibGVuZ3RoIiwic2lnbmlmaWNhbnREaWdpdHMiLCJwZXJjIiwibGVuZ3RoXyIsImlucHV0IiwiaXNaZXJvIiwidGltZXMiLCJkZXB0aCIsImd0ZSIsImNlaWwiLCJsb2cxMCIsImRpdiIsInNoaWZ0IiwicG93Iiwicm91bmRlZE51bWJlciIsInJvdW5kIiwiZm9ybWF0RGF0ZSIsImlucHV0RGF0ZSIsIm1vbnRoTGlzdCIsImRhdGUiLCJEYXRlIiwiZGF5IiwiZ2V0RGF0ZSIsIm1vbnRoIiwiZ2V0TW9udGgiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJmb3JtYXRUaW1lIiwidGltZSIsInRvVGltZVN0cmluZyIsInRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsiLCJ0cmFuc2FjdGlvbiIsImNoYWluSWQiLCJoYXNoTWVzc2FnZSIsImJ1ZmZlcmVkTWVzc2FnZSIsImVsIiwic2lnbk1lc3NhZ2UiLCJwcml2YXRlS2V5IiwicHJpdktleSIsIm1zZ1NpZyIsInJhd01zZ1NpZyIsImdldFBvcHVwRmVhdHVyZXMiLCJ3IiwiaCIsImR1YWxTY3JlZW5MZWZ0Iiwic2NyZWVuTGVmdCIsInNjcmVlblgiLCJkdWFsU2NyZWVuVG9wIiwic2NyZWVuVG9wIiwic2NyZWVuWSIsImlubmVyV2lkdGgiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwic2NyZWVuIiwiaW5uZXJIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzeXN0ZW1ab29tIiwibGVmdCIsImFicyIsInRvcCIsImZlYXR1cmVzIiwiYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMiLCJ0eXBlIiwid2ViV29ya2VyU3VwcG9ydCIsImdldEN1c3RvbURldmljZUluZm8iLCJfbmF2aWdhdG9yIiwibmF2aWdhdG9yIiwiYnJhdmUiLCJicm93c2VyIiwiVXNlckVycm9yIiwiaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzIiwiaGFzaCIsInF1ZXJ5UGFyYW1ldGVycyIsImhhc2hQYXJhbWV0ZXJzIiwiaGFzaFVybCIsIlVSTCIsIm9yaWdpbiIsInNlYXJjaFBhcmFtcyIsImluc3RhbmNlUGFyYW1ldGVycyIsImtleXMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlcnJvcl9kZXNjcmlwdGlvbiIsInNsZWVwIiwibXMiLCJpc1VuYXV0aG9yaXplZEVycm9yIiwiUmVzcG9uc2UiLCJzdGF0dXMiLCJCYXNlS2V5cmluZ0NvbnRyb2xsZXIiLCJfc3RhdGUkd2FsbGV0cyIsIndhbGxldHMiLCJzaWduQXV0aE1lc3NhZ2UiLCJrZXlyaW5nIiwiZmluZCIsIngiLCJoYXNoZWRNZXNzYWdlIiwicmF3TWVzc2FnZVNpZyIsIlJFVFJJQUJMRV9FUlJPUlMiLCJjaGVja0Zvckh0dHBFcnJvcnMiLCJmZXRjaFJlcyIsIm1ldGhvZE5vdEZvdW5kIiwiaW50ZXJuYWwiLCJjYXVzZSIsInBhcnNlUmVzcG9uc2UiLCJib2R5IiwiY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxIiwicmVxIiwicnBjVGFyZ2V0Iiwib3JpZ2luSHR0cEhlYWRlcktleSIsInBhcnNlZFVybCIsImlkIiwianNvbnJwYyIsIm9yaWdpbkRvbWFpbiIsInNlcmlhbGl6ZWRQYXlsb2FkIiwiZmV0Y2hQYXJhbXMiLCJBY2NlcHQiLCJmZXRjaFVybCIsImhyZWYiLCJjcmVhdGVGZXRjaE1pZGRsZXdhcmUiLCJfbmV4dCIsIm1heEF0dGVtcHRzIiwicmV0cnlJbnRlcnZhbCIsImF0dGVtcHQiLCJmZXRjaCIsImZldGNoQm9keSIsImpzb24iLCJlcnIiLCJlcnJNc2ciLCJpc1JldHJpYWJsZSIsInNvbWUiLCJwaHJhc2UiLCJkZWZlcnJlZFByb21pc2UiLCJwcm9taXNlIiwiX3Jlc29sdmUiLCJjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSIsImNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QiLCJpbmZsaWdodFJlcXVlc3RzIiwiY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIiLCJhY3RpdmVSZXF1ZXN0SGFuZGxlcnMiLCJoYW5kbGVkUmVzIiwiaGFuZGxlQWN0aXZlUmVxdWVzdCIsInNraXBDYWNoZSIsImNhY2hlSWQiLCJpbmZvIiwiY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSIsIm9wdGlvbnMiLCJsb2dnZXJNaWRkbGV3YXJlIiwiY2FsbGJhY2siLCJ3YXJuIiwiaXNUb3J1c0ludGVybmFsIiwiY3JlYXRlT3JpZ2luTWlkZGxld2FyZSIsIm9yaWdpbk1pZGRsZXdhcmUiLCJjcmVhdGVSYW5kb21JZCIsInN1YnN0cmluZyIsIkNIQUlOX05BTUVTUEFDRVMiLCJFSVAxNTUiLCJTT0xBTkEiLCJDQVNQRVIiLCJYUlBMIiwiT1RIRVIiLCJCcm9hZGNhc3RDaGFubmVsSGFuZGxlciIsImNoYW5uZWxQcmVmaXgiLCJpbnN0YW5jZUlkIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiY2hhbm5lbCIsImJjIiwiZ2V0TWVzc2FnZUZyb21DaGFubmVsIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2IiwiY2xvc2UiLCJwb3N0TWVzc2FnZSIsIlN0cmVhbVdpbmRvdyIsIm9wZW4iLCJjb21tdW5pY2F0aW9uRW5naW5lIiwiY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIiLCJwb3B1cFN1Y2Nlc3MiLCJjbG9zZWQiLCJoYW5kbGVXaW5kb3dCbG9ja0FsZXJ0IiwiZmluYWxVcmwiLCJ1cmwiLCJ0aGVuIiwiY2F0Y2giLCJpc0Z1bGxTY3JlZW4iLCJyaWQiLCJjaGFubmVsTmFtZSIsInBvc3RNc2ciLCJsb2NhbFJlc3BvbnNlIiwiY3VycmVudERlbGF5IiwicmVjdXJzaXZlRm4iLCJzZXJ2ZXJSZXNwb25zZSIsIlBvcHVwSGFuZGxlciIsIndpbmRvd1RpbWVyIiwiaUNsb3NlZFdpbmRvdyIsIl9zZXR1cFRpbWVyIiwibG9jYWxXaW5kb3ciLCJmaW5hbFdpbmRvd0lkIiwic3RyZWFtV2luZG93IiwidGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJQb3B1cFN0b3JlQ2hhbm5lbCIsImhhbmRsZUxvZ291dCIsImhhbmRsZUFjY291bnRJbXBvcnQiLCJoYW5kbGVOZXR3b3JrQ2hhbmdlIiwiaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlIiwiaGFuZGxlVGhlbWVDaGFuZ2UiLCJzZXR1cFN0b3JlQ2hhbm5lbHMiLCJsb2dvdXRDaGFubmVsIiwiaW1wb3J0QWNjb3VudENoYW5uZWwiLCJuZXR3b3JrQ2hhbmdlQ2hhbm5lbCIsInNlbGVjdGVkQWRkcmVzc0NoYW5nZUNoYW5uZWwiLCJ0aGVtZUNoYW5nZWRDaGFubmVsIiwiX2V2JGRhdGEiLCJ3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbCIsIl9ldiRkYXRhMiIsIl9ldiRkYXRhMyIsIl9ldiRkYXRhNCIsIl9ldiRkYXRhNSIsIl9ldiRkYXRhNiIsIl9ldiRkYXRhNyIsInRoZW1lIiwiX2V2JGRhdGE4IiwiX2V2JGRhdGE5Iiwic2VsZWN0ZWRBZGRyZXNzIiwiUG9wdXBXaXRoQmNIYW5kbGVyIiwiaGFuZGxlIiwic3VjY2Vzc0V4dHJhRm4iLCJjbG9zZUxpc3RlbmVyIiwiaGFuZGxlV2l0aEhhbmRzaGFrZSIsIlJlZGlyZWN0SGFuZGxlciIsImZpbmFsUXVlcnlQYXJhbXMiLCJIVFRQX01FVEhPRCIsImNvbnN0cnVjdEF1dGhIZWFkZXJzIiwiand0VG9rZW4iLCJ3aXRoVW5hdXRob3JpemVkSGFuZGxlciIsImZuIiwiZW1pdHRlciIsImUiLCJVc2VyVW5hdXRob3JpemVkIiwiand0VG9rZW5FeHBpcmVkIiwiZGVjb2RlZCIsImp3dEV4cGlyeSIsImV4cCIsImN1cnJlbnRUaW1lIiwiZ2V0VGltZSIsIldTQXBpQ2xpZW50IiwiYmFzZUFwaVVybCIsImF1dGhSZXF1ZXN0IiwiYXV0aENyZWRlbnRpYWxzIiwiY3VzdG9tT3B0aW9ucyIsInN0YXR1c1RleHQiLCJHRVQiLCJQT1NUIiwiUFVUIiwiUEFUQ0giLCJERUxFVEUiLCJhdXRoR2V0IiwiYXV0aFBvc3QiLCJhdXRoUHV0IiwiYXV0aFBhdGNoIiwiYXV0aFJlbW92ZSIsIkFDVElWSVRZX0FDVElPTiIsIkFDQ09VTlRfQ0FURUdPUlkiLCJOT1JNQUwiLCJUSFJFU0hPTEQiLCJJTVBPUlRFRCIsIkFQUF9TQ09QRUQiLCJBQ0NPVU5UX0FCU1RSQUNUSU9OIiwiRVhURVJOQUwiLCJNUEMiLCJTRkEiLCJERUZBVUxUX0lOVEVSVkFMIiwiREVGQVVMVF9QUkVGRVJFTkNFUyIsInNlbGVjdGVkQ3VycmVuY3kiLCJsb2NhbGUiLCJhY2NvdW50VHlwZSIsImNvbnRhY3RzIiwiZmV0Y2hlZFBhc3RUeCIsInBhc3RUcmFuc2FjdGlvbnMiLCJwYXltZW50VHgiLCJkZWZhdWx0UHVibGljQWRkcmVzcyIsImN1c3RvbVRva2VucyIsImN1c3RvbU5mdHMiLCJjcmFzaFJlcG9ydCIsInVzZXJJbmZvIiwiYWdncmVnYXRlVmVyaWZpZXIiLCJlbWFpbCIsInByb2ZpbGVJbWFnZSIsInR5cGVPZkxvZ2luIiwidmVyaWZpZXIiLCJ2ZXJpZmllcklkIiwiQmFzZVByZWZlcmVuY2VzQ29udHJvbGxlciIsImRlZmF1bHRQcmVmZXJlbmNlcyIsInZhbGlkYXRlU2lnbk1lc3NhZ2UiLCJhcGkiLCJpZGVudGl0aWVzIiwibGFzdEVycm9yTWVzc2FnZSIsImxhc3RTdWNjZXNzTWVzc2FnZSIsIndzQXBpQ2xpZW50Iiwic2V0SWZyYW1lT3JpZ2luIiwiaWZyYW1lT3JpZ2luIiwiZ2V0QWRkcmVzc1N0YXRlIiwic2V0U2VsZWN0ZWRBZGRyZXNzIiwiZ2V0VXNlciIsInVzZXIiLCJ1c2VBUElLZXkiLCJjcmVhdGVVc2VyIiwiaWRUb2tlbiIsInVzZXJQYXlsb2FkIiwiZGVmYXVsdF9jdXJyZW5jeSIsInZlcmlmaWVyX2lkIiwiYWNjb3VudF90eXBlIiwidXBkYXRlU3RhdGUiLCJzdG9yZVVzZXJMb2dpbiIsInNlc3Npb25QdWJLZXkiLCJsb2dpbk1vZGUiLCJyZWh5ZHJhdGUiLCJnZXRQYXJzZXIiLCJ1c2VyQWdlbnQiLCJzcGVjaWFsQnJvd3NlciIsInJlY29yZExvZ2luUGF5bG9hZCIsIm9zIiwiZ2V0T1NOYW1lIiwib3NfdmVyc2lvbiIsImdldE9TVmVyc2lvbiIsImdldEJyb3dzZXJOYW1lIiwiYnJvd3Nlcl92ZXJzaW9uIiwiZ2V0QnJvd3NlclZlcnNpb24iLCJwbGF0Zm9ybSIsImdldFBsYXRmb3JtIiwid2ViM2F1dGhfY2xpZW50X2lkIiwic2Vzc2lvbl9wdWJfa2V5IiwibG9naW5fbW9kZSIsInNldENyYXNoUmVwb3J0IiwiaXNFbmFibGVkIiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlIiwiZW5hYmxlX2NyYXNoX3JlcG9ydGVyIiwic2V0VXNlclRoZW1lIiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMiIsInNldFVzZXJMb2NhbGUiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGUzIiwic2V0U2VsZWN0ZWRDdXJyZW5jeSIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTQiLCJhZGRDb250YWN0IiwiY29udGFjdCIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTUiLCJkZWxldGVDb250YWN0IiwiY29udGFjdElkIiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNiIsImZpbmFsQ29udGFjdHMiLCJyZXZva2VEaXNjb3JkIiwicmVzcCIsInBhdGNoUGFzdFR4IiwicG9zdFBhc3RUeCIsInR4IiwiZ2V0V2FsbGV0T3JkZXJzIiwiZ2V0VG9wVXBPcmRlcnMiLCJnZXRCaWxsQm9hcmREYXRhIiwiZ2V0TWVzc2FnZUZvclNpZ25pbmciLCJ3ZWIzQXV0aElkVG9rZW4iLCJwdWJsaWNfYWRkcmVzcyIsImlkX3Rva2VuIiwiZ2V0VHdpdHRlcklkIiwibmljayIsInNlbmRFbWFpbCIsImVtYWlsT2JqZWN0IiwicmVmcmVzaEp3dCIsIm1lc3NhZ2VUb1NpZ24iLCJzaWduZWRfbWVzc2FnZSIsImdldERhcHBMaXN0IiwiaW5pdCIsIm1ldGFkYXRhIiwic2lnbmF0dXJlcyIsInByZWZlcmVuY2VzIiwiY3VycmVudFN0YXRlIiwibWVyZ2VkU3RhdGUiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGU3IiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlOCIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiVFJBTlNBQ1RJT05fVFlQRVMiLCJDQU5DRUwiLCJSRVRSWSIsIkNPTlRSQUNUX0lOVEVSQUNUSU9OIiwiREVQTE9ZX0NPTlRSQUNUIiwiV0FTTV9CQVNFRF9ERVBMT1kiLCJTVEFOREFSRF9UUkFOU0FDVElPTiIsIlNUQU5EQVJEX1BBWU1FTlRfVFJBTlNBQ1RJT04iLCJTRU5UX0VUSEVSIiwiVE9LRU5fTUVUSE9EX1RSQU5TRkVSIiwiVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST00iLCJUT0tFTl9NRVRIT0RfQVBQUk9WRSIsIkNPTExFQ1RJQkxFX01FVEhPRF9TQUZFX1RSQU5TRkVSX0ZST00iLCJTRVRfQVBQUk9WQUxfRk9SX0FMTCIsIlRYX0VWRU5UUyIsIlRYX1dBUk5JTkciLCJUWF9FUlJPUiIsIlRYX0ZBSUxFRCIsIlRYX0NPTkZJUk1FRCIsIlRYX0RST1BQRUQiLCJUWF9FWFBJUkVEIiwiVFhfU1RBVFVTX1VQREFURSIsIlRYX1VOQVBQUk9WRUQiLCJUWF9SRVRSWSIsIlRYX0JMT0NLX1VQREFURSIsIkJhc2VUcmFuc2FjdGlvblN0YXRlTWFuYWdlciIsImdldEN1cnJlbnRDaGFpbklkIiwidHhIaXN0b3J5TGltaXQiLCJ0cmFuc2FjdGlvbnMiLCJ1bmFwcHJvdmVkVHhzIiwiY3VycmVudE5ldHdvcmtUeHNMaXN0IiwiZ2V0VW5hcHByb3ZlZFR4TGlzdCIsInVuYXBwcm92ZWQiLCJnZXRUcmFuc2FjdGlvbiIsInR4SWQiLCJ1cGRhdGVUcmFuc2FjdGlvbiIsInR4TWV0YSIsInVwZGF0ZWRfYXQiLCJ0b0lTT1N0cmluZyIsInNldFR4U3RhdHVzUmVqZWN0ZWQiLCJfc2V0VHJhbnNhY3Rpb25TdGF0dXMiLCJyZWplY3RlZCIsIl9kZWxldGVUcmFuc2FjdGlvbiIsInNldFR4U3RhdHVzVW5hcHByb3ZlZCIsInNldFR4U3RhdHVzQXBwcm92ZWQiLCJhcHByb3ZlZCIsInNldFR4U3RhdHVzU2lnbmVkIiwiaXNGaW5hbFN0ZXAiLCJzaWduZWQiLCJzZXRUeFN0YXR1c1N1Ym1pdHRlZCIsInN1Ym1pdHRlZCIsInNldFR4U3RhdHVzRHJvcHBlZCIsImRyb3BwZWQiLCJzZXRUeFN0YXR1c0V4cGlyZWQiLCJleHBpcmVkIiwic2V0VHhTdGF0dXNDb25maXJtZWQiLCJjb25maXJtZWQiLCJzZXRUeFN0YXR1c0ZhaWxlZCIsImVycm9yXyIsImZhaWxlZCIsImlzRmluYWxTdGF0ZSIsImNhbmNlbGxlZCIsImNsZWFyVW5hcHByb3ZlZFR4cyIsIl9hZGRUcmFuc2FjdGlvbnNUb1N0YXRlIiwibmV3VHgiLCJfc2V0VHJhbnNhY3Rpb25zVG9TdGF0ZSIsInRhcmdldFRyYW5zYWN0aW9uSWQiLCJfZGVsZXRlVHJhbnNhY3Rpb25zIiwidGFyZ2V0VHJhbnNhY3Rpb25JZHMiLCJ0cmFuc2FjdGlvbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BroadcastChannel: () => (/* binding */ BroadcastChannel$1),\n/* harmony export */   IndexedDbMethod: () => (/* binding */ IndexeDbMethod),\n/* harmony export */   LocalStorageMethod: () => (/* binding */ LocalstorageMethod),\n/* harmony export */   NativeMethod: () => (/* binding */ NativeMethod),\n/* harmony export */   OPEN_BROADCAST_CHANNELS: () => (/* binding */ OPEN_BROADCAST_CHANNELS),\n/* harmony export */   ServerMethod: () => (/* binding */ ServerMethod),\n/* harmony export */   chooseMethod: () => (/* binding */ chooseMethod),\n/* harmony export */   enforceOptions: () => (/* binding */ enforceOptions)\n/* harmony export */ });\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! oblivious-set */ \"(ssr)/./node_modules/oblivious-set/dist/esm/src/index.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(ssr)/./node_modules/socket.io-client/build/esm-debug/index.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n/* harmony import */ var _toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/metadata-helpers */ \"(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\");\n\n\n\n\n\n// import Bowser from 'bowser';\n/**\n * returns true if the given object is a promise\n */ function isPromise(obj) {\n    if (obj && typeof obj.then === \"function\") {\n        return true;\n    } else {\n        return false;\n    }\n}\nPromise.resolve(false);\nPromise.resolve(true);\nconst PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n    if (!time) time = 0;\n    return new Promise((res)=>setTimeout(()=>res(resolveWith), time));\n}\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/8084248\n */ function randomToken() {\n    return Math.random().toString(36).substring(2);\n}\nlet lastMs = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */ function microSeconds$5() {\n    let ret = Date.now() * 1000; // milliseconds to microseconds\n    if (ret <= lastMs) {\n        ret = lastMs + 1;\n    }\n    lastMs = ret;\n    return ret;\n}\n// the problem is only in iframes. we should default to server in case of iframes.\n// storage scoping is present in all browsers now\n// Safari and other browsers support native Broadcast channel now. It's in LS.\n// test here: https://pubkey.github.io/broadcast-channel/e2e.html?methodType=native\n// https://caniuse.com/broadcastchannel\n// export function are3PCSupported() {\n//     if (typeof navigator === 'undefined') return false;\n//     const browserInfo = Bowser.parse(navigator.userAgent);\n//     log.info(JSON.stringify(browserInfo), 'current browser info');\n//     let thirdPartyCookieSupport = true;\n//     // brave\n//     if (navigator.brave) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     // All webkit & gecko engine instances use itp (intelligent tracking prevention -\n//     // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)\n//     if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     return thirdPartyCookieSupport;\n// }\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_0___default().getLogger(\"broadcast-channel\");\nlog.setLevel(\"error\");\nconst microSeconds$4 = microSeconds$5;\nconst type$4 = \"native\";\nfunction create$4(channelName) {\n    const state = {\n        time: microSeconds$5(),\n        messagesCallback: null,\n        bc: new BroadcastChannel(channelName),\n        subFns: [] // subscriberFunctions\n    };\n    state.bc.onmessage = (msg)=>{\n        if (state.messagesCallback) {\n            state.messagesCallback(msg.data);\n        }\n    };\n    return state;\n}\nfunction close$4(channelState) {\n    channelState.bc.close();\n    channelState.subFns = [];\n}\nfunction postMessage$4(channelState, messageJson) {\n    try {\n        channelState.bc.postMessage(messageJson, false);\n        return PROMISE_RESOLVED_VOID;\n    } catch (err) {\n        return Promise.reject(err);\n    }\n}\nfunction onMessage$4(channelState, fn1) {\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$4() {\n    /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */ if (true) return false;\n    if (typeof BroadcastChannel === \"function\") {\n        if (BroadcastChannel._pubkey) {\n            throw new Error(\"BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill\");\n        }\n        return true;\n    } else return false;\n}\nfunction averageResponseTime$4() {\n    return 150;\n}\nvar NativeMethod = {\n    create: create$4,\n    close: close$4,\n    onMessage: onMessage$4,\n    postMessage: postMessage$4,\n    canBeUsed: canBeUsed$4,\n    type: type$4,\n    averageResponseTime: averageResponseTime$4,\n    microSeconds: microSeconds$4\n};\nfunction fillOptionsWithDefaults() {\n    let originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = JSON.parse(JSON.stringify(originalOptions));\n    // main\n    if (typeof options.webWorkerSupport === \"undefined\") options.webWorkerSupport = true;\n    // indexed-db\n    if (!options.idb) options.idb = {};\n    //  after this time the messages get deleted\n    if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n    if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n    //  handles abrupt db onclose events.\n    if (originalOptions.idb && typeof originalOptions.idb.onclose === \"function\") options.idb.onclose = originalOptions.idb.onclose;\n    // localstorage\n    if (!options.localstorage) options.localstorage = {};\n    if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n    // server\n    if (!options.server) options.server = {};\n    if (!options.server.url) options.server.url = \"https://session.web3auth.io\";\n    if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes\n    // custom methods\n    if (originalOptions.methods) options.methods = originalOptions.methods;\n    return options;\n}\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n *\n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */ const microSeconds$3 = microSeconds$5;\nconst DB_PREFIX = \"pubkey.broadcast-channel-0-\";\nconst OBJECT_STORE_ID = \"messages\";\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ const TRANSACTION_SETTINGS = {\n    durability: \"relaxed\"\n};\nconst type$3 = \"idb\";\nfunction getIdb() {\n    if (typeof indexedDB !== \"undefined\") return indexedDB;\n    if (false) {}\n    return false;\n}\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ function commitIndexedDBTransaction(tx) {\n    if (tx.commit) {\n        tx.commit();\n    }\n}\nfunction createDatabase(channelName) {\n    const IndexedDB = getIdb();\n    // create table\n    const dbName = DB_PREFIX + channelName;\n    /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */ const openRequest = IndexedDB.open(dbName);\n    openRequest.onupgradeneeded = (ev)=>{\n        const db = ev.target.result;\n        db.createObjectStore(OBJECT_STORE_ID, {\n            keyPath: \"id\",\n            autoIncrement: true\n        });\n    };\n    const dbPromise = new Promise((res, rej)=>{\n        openRequest.onerror = (ev)=>rej(ev);\n        openRequest.onsuccess = ()=>{\n            res(openRequest.result);\n        };\n    });\n    return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */ function writeMessage(db, readerUuid, messageJson) {\n    const time = Date.now();\n    const writeObject = {\n        uuid: readerUuid,\n        time,\n        data: messageJson\n    };\n    const tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    return new Promise((res, rej)=>{\n        tx.oncomplete = ()=>res();\n        tx.onerror = (ev)=>rej(ev);\n        const objectStore = tx.objectStore(OBJECT_STORE_ID);\n        objectStore.add(writeObject);\n        commitIndexedDBTransaction(tx);\n    });\n}\nfunction getAllMessages(db) {\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    return new Promise((res)=>{\n        objectStore.openCursor().onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                ret.push(cursor.value);\n                //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                cursor.continue();\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n    /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */ if (objectStore.getAll) {\n        const getAllRequest = objectStore.getAll(keyRangeValue);\n        return new Promise((res, rej)=>{\n            getAllRequest.onerror = (err)=>rej(err);\n            getAllRequest.onsuccess = function(e) {\n                res(e.target.result);\n            };\n        });\n    }\n    function openCursor() {\n        // Occasionally Safari will fail on IDBKeyRange.bound, this\n        // catches that error, having it open the cursor to the first\n        // item. When it gets data it will advance to the desired key.\n        try {\n            keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n            return objectStore.openCursor(keyRangeValue);\n        } catch (e) {\n            return objectStore.openCursor();\n        }\n    }\n    return new Promise((res, rej)=>{\n        const openCursorRequest = openCursor();\n        openCursorRequest.onerror = (err)=>rej(err);\n        openCursorRequest.onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                if (cursor.value.id < lastCursorId + 1) {\n                    cursor.continue(lastCursorId + 1);\n                } else {\n                    ret.push(cursor.value);\n                    cursor.continue();\n                }\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction removeMessagesById(db, ids) {\n    const tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    return Promise.all(ids.map((id)=>{\n        const deleteRequest = objectStore.delete(id);\n        return new Promise((res)=>{\n            deleteRequest.onsuccess = ()=>res();\n        });\n    }));\n}\nfunction getOldMessages(db, ttl) {\n    const olderThen = Date.now() - ttl;\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    return new Promise((res)=>{\n        objectStore.openCursor().onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                const msgObk = cursor.value;\n                if (msgObk.time < olderThen) {\n                    ret.push(msgObk);\n                    //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                    cursor.continue();\n                } else {\n                    // no more old messages,\n                    commitIndexedDBTransaction(tx);\n                    res(ret);\n                    return;\n                }\n            } else {\n                res(ret);\n            }\n        };\n    });\n}\nfunction cleanOldMessages(db, ttl) {\n    return getOldMessages(db, ttl).then((tooOld)=>{\n        return removeMessagesById(db, tooOld.map((msg)=>msg.id));\n    });\n}\nfunction create$3(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    return createDatabase(channelName).then((db)=>{\n        const state = {\n            closed: false,\n            lastCursorId: 0,\n            channelName,\n            options,\n            uuid: randomToken(),\n            /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */ eMIs: new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.idb.ttl * 2),\n            // ensures we do not read messages in parrallel\n            writeBlockPromise: PROMISE_RESOLVED_VOID,\n            messagesCallback: null,\n            readQueuePromises: [],\n            db,\n            time: microSeconds$5()\n        };\n        /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */ db.onclose = function() {\n            state.closed = true;\n            if (options.idb.onclose) options.idb.onclose();\n        };\n        /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */ _readLoop(state);\n        return state;\n    });\n}\nfunction _readLoop(state) {\n    if (state.closed) return;\n    readNewMessages(state).then(()=>sleep(state.options.idb.fallbackInterval)).then(()=>_readLoop(state));\n}\nfunction _filterMessage(msgObj, state) {\n    if (msgObj.uuid === state.uuid) return false; // send by own\n    if (state.eMIs.has(msgObj.id)) return false; // already emitted\n    if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n    return true;\n}\n/**\n * reads all new messages from the database and emits them\n */ function readNewMessages(state) {\n    // channel already closed\n    if (state.closed) return PROMISE_RESOLVED_VOID;\n    // if no one is listening, we do not need to scan for new messages\n    if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n    return getMessagesHigherThan(state.db, state.lastCursorId).then((newerMessages)=>{\n        const useMessages = newerMessages/**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */ .filter((msgObj)=>!!msgObj).map((msgObj)=>{\n            if (msgObj.id > state.lastCursorId) {\n                state.lastCursorId = msgObj.id;\n            }\n            return msgObj;\n        }).filter((msgObj)=>_filterMessage(msgObj, state)).sort((msgObjA, msgObjB)=>msgObjA.time - msgObjB.time); // sort by time\n        useMessages.forEach((msgObj)=>{\n            if (state.messagesCallback) {\n                state.eMIs.add(msgObj.id);\n                state.messagesCallback(msgObj.data);\n            }\n        });\n        return PROMISE_RESOLVED_VOID;\n    });\n}\nfunction close$3(channelState) {\n    channelState.closed = true;\n    channelState.db.close();\n}\nfunction postMessage$3(channelState, messageJson) {\n    channelState.writeBlockPromise = channelState.writeBlockPromise.then(()=>writeMessage(channelState.db, channelState.uuid, messageJson)).then(()=>{\n        if (randomInt(0, 10) === 0) {\n            /* await (do not await) */ cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n        }\n    });\n    return channelState.writeBlockPromise;\n}\nfunction onMessage$3(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n    readNewMessages(channelState);\n}\nfunction canBeUsed$3() {\n    const idb = getIdb();\n    if (!idb) return false;\n    return true;\n}\nfunction averageResponseTime$3(options) {\n    return options.idb.fallbackInterval * 2;\n}\nvar IndexeDbMethod = {\n    getIdb,\n    createDatabase,\n    create: create$3,\n    close: close$3,\n    onMessage: onMessage$3,\n    postMessage: postMessage$3,\n    canBeUsed: canBeUsed$3,\n    type: type$3,\n    averageResponseTime: averageResponseTime$3,\n    microSeconds: microSeconds$3,\n    writeMessage,\n    getAllMessages,\n    cleanOldMessages,\n    getMessagesHigherThan,\n    getOldMessages\n};\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ const microSeconds$2 = microSeconds$5;\nconst KEY_PREFIX$1 = \"pubkey.broadcastChannel-\";\nconst type$2 = \"localstorage\";\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */ function getLocalStorage() {\n    let localStorage;\n    if (true) return null;\n    try {\n        localStorage = window.localStorage;\n        localStorage = window[\"ie8-eventlistener/storage\"] || window.localStorage;\n    } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n    }\n    return localStorage;\n}\nfunction storageKey$1(channelName) {\n    return KEY_PREFIX$1 + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage$2(channelState, messageJson) {\n    return new Promise((res)=>{\n        sleep().then(()=>{\n            const key = storageKey$1(channelState.channelName);\n            const writeObj = {\n                token: randomToken(),\n                time: Date.now(),\n                data: messageJson,\n                uuid: channelState.uuid\n            };\n            const value = JSON.stringify(writeObj);\n            getLocalStorage().setItem(key, value);\n            /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */ const ev = document.createEvent(\"Event\");\n            ev.initEvent(\"storage\", true, true);\n            ev.key = key;\n            ev.newValue = value;\n            window.dispatchEvent(ev);\n            res();\n        });\n    });\n}\nfunction addStorageEventListener(channelName, fn1) {\n    const key = storageKey$1(channelName);\n    const listener = (ev)=>{\n        if (ev.key === key) {\n            fn1(JSON.parse(ev.newValue));\n        }\n    };\n    window.addEventListener(\"storage\", listener);\n    return listener;\n}\nfunction removeStorageEventListener(listener) {\n    window.removeEventListener(\"storage\", listener);\n}\nfunction create$2(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    if (!canBeUsed$2()) {\n        throw new Error(\"BroadcastChannel: localstorage cannot be used\");\n    }\n    const uuid = randomToken();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ const eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.localstorage.removeTimeout);\n    const state = {\n        channelName,\n        uuid,\n        time: microSeconds$5(),\n        eMIs\n    };\n    state.listener = addStorageEventListener(channelName, (msgObj)=>{\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === uuid) return; // own message\n        if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n        if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    return state;\n}\nfunction close$2(channelState) {\n    removeStorageEventListener(channelState.listener);\n}\nfunction onMessage$2(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$2() {\n    const ls = getLocalStorage();\n    if (!ls) return false;\n    try {\n        const key = \"__broadcastchannel_check\";\n        ls.setItem(key, \"works\");\n        ls.removeItem(key);\n    } catch (e) {\n        // Safari 10 in private mode will not allow write access to local\n        // storage and fail with a QuotaExceededError. See\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n        return false;\n    }\n    return true;\n}\nfunction averageResponseTime$2() {\n    const defaultTime = 120;\n    const userAgent = navigator.userAgent.toLowerCase();\n    if (userAgent.includes(\"safari\") && !userAgent.includes(\"chrome\")) {\n        // safari is much slower so this time is higher\n        return defaultTime * 2;\n    }\n    return defaultTime;\n}\nvar LocalstorageMethod = {\n    getLocalStorage,\n    create: create$2,\n    close: close$2,\n    onMessage: onMessage$2,\n    postMessage: postMessage$2,\n    canBeUsed: canBeUsed$2,\n    type: type$2,\n    averageResponseTime: averageResponseTime$2,\n    microSeconds: microSeconds$2,\n    storageKey: storageKey$1,\n    addStorageEventListener,\n    removeStorageEventListener\n};\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ const microSeconds$1 = microSeconds$5;\nconst KEY_PREFIX = \"pubkey.broadcastChannel-\";\nconst type$1 = \"server\";\nlet SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nconst runningChannels = new Set();\nfunction storageKey(channelName) {\n    return KEY_PREFIX + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage$1(channelState, messageJson) {\n    return new Promise((res, rej)=>{\n        sleep().then(async ()=>{\n            const key = storageKey(channelState.channelName);\n            const channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(key, \"utf8\"));\n            const encData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.encryptData)(channelEncPrivKey.toString(\"hex\"), {\n                token: randomToken(),\n                time: Date.now(),\n                data: messageJson,\n                uuid: channelState.uuid\n            });\n            const body = {\n                sameOriginCheck: true,\n                sameIpCheck: true,\n                key: (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(channelEncPrivKey).toString(\"hex\"),\n                data: encData,\n                signature: (await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.sign)(channelEncPrivKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(encData, \"utf8\")))).toString(\"hex\")\n            };\n            if (channelState.timeout) body.timeout = channelState.timeout;\n            return fetch(channelState.serverUrl + \"/channel/set\", {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json; charset=utf-8\"\n                }\n            }).then(res).catch(rej);\n        });\n    });\n}\nfunction getSocketInstance(serverUrl) {\n    if (SOCKET_CONN_INSTANCE) {\n        return SOCKET_CONN_INSTANCE;\n    }\n    const SOCKET_CONN = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(serverUrl, {\n        transports: [\n            \"websocket\",\n            \"polling\"\n        ],\n        // use WebSocket first, if available\n        withCredentials: true,\n        reconnectionDelayMax: 10000,\n        reconnectionAttempts: 10\n    });\n    SOCKET_CONN.on(\"connect_error\", (err)=>{\n        // revert to classic upgrade\n        SOCKET_CONN.io.opts.transports = [\n            \"polling\",\n            \"websocket\"\n        ];\n        log.error(\"connect error\", err);\n    });\n    SOCKET_CONN.on(\"connect\", async ()=>{\n        const { engine } = SOCKET_CONN.io;\n        log.debug(\"initially connected to\", engine.transport.name); // in most cases, prints \"polling\"\n        engine.once(\"upgrade\", ()=>{\n            // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n            log.debug(\"upgraded\", engine.transport.name); // in most cases, prints \"websocket\"\n        });\n        engine.once(\"close\", (reason)=>{\n            // called when the underlying connection is closed\n            log.debug(\"connection closed\", reason);\n        });\n    });\n    SOCKET_CONN.on(\"error\", (err)=>{\n        log.error(\"socket errored\", err);\n        SOCKET_CONN.disconnect();\n    });\n    SOCKET_CONN_INSTANCE = SOCKET_CONN;\n    return SOCKET_CONN;\n}\nfunction setupSocketConnection(serverUrl, channelState, fn1) {\n    const socketConn = getSocketInstance(serverUrl);\n    const key = storageKey(channelState.channelName);\n    const channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(key, \"utf8\"));\n    const channelPubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(channelEncPrivKey).toString(\"hex\");\n    if (socketConn.connected) {\n        socketConn.emit(\"check_auth_status\", channelPubKey, {\n            sameOriginCheck: true,\n            sameIpCheck: true\n        });\n    } else {\n        socketConn.once(\"connect\", ()=>{\n            log.debug(\"connected with socket\");\n            socketConn.emit(\"check_auth_status\", channelPubKey, {\n                sameOriginCheck: true,\n                sameIpCheck: true\n            });\n        });\n    }\n    const reconnect = ()=>{\n        socketConn.once(\"connect\", async ()=>{\n            if (runningChannels.has(channelState.channelName)) {\n                socketConn.emit(\"check_auth_status\", channelPubKey, {\n                    sameOriginCheck: true,\n                    sameIpCheck: true\n                });\n            }\n        });\n    };\n    const visibilityListener = ()=>{\n        // if channel is closed, then remove the listener.\n        if (!socketConn || !runningChannels.has(channelState.channelName)) {\n            document.removeEventListener(\"visibilitychange\", visibilityListener);\n            return;\n        }\n        // if not connected, then wait for connection and ping server for latest msg.\n        if (!socketConn.connected && document.visibilityState === \"visible\") {\n            reconnect();\n        }\n    };\n    const listener = async (ev)=>{\n        try {\n            const decData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.decryptData)(channelEncPrivKey.toString(\"hex\"), ev);\n            log.info(decData);\n            fn1(decData);\n        } catch (error) {\n            log.error(error);\n        }\n    };\n    socketConn.on(\"disconnect\", ()=>{\n        log.debug(\"socket disconnected\");\n        if (runningChannels.has(channelState.channelName)) {\n            log.error(\"socket disconnected unexpectedly, reconnecting socket\");\n            reconnect();\n        }\n    });\n    socketConn.on(`${channelPubKey}_success`, listener);\n    if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", visibilityListener);\n    return socketConn;\n}\nfunction create$1(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    const uuid = randomToken();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ const eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.server.removeTimeout);\n    const state = {\n        channelName,\n        uuid,\n        eMIs,\n        // emittedMessagesIds\n        serverUrl: options.server.url,\n        time: microSeconds$5()\n    };\n    if (options.server.timeout) state.timeout = options.server.timeout;\n    setupSocketConnection(options.server.url, state, (msgObj)=>{\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === state.uuid) return; // own message\n        if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n        // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        state.eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    runningChannels.add(channelName);\n    return state;\n}\nfunction close$1(channelState) {\n    runningChannels.delete(channelState.channelName);\n// give 2 sec for all msgs which are in transit to be consumed\n// by receiver.\n// window.setTimeout(() => {\n//     removeStorageEventListener(channelState);\n//     SOCKET_CONN_INSTANCE = null;\n// }, 1000);\n}\nfunction onMessage$1(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$1() {\n    return true;\n}\nfunction averageResponseTime$1() {\n    const defaultTime = 500;\n    // TODO: Maybe increase it based on operation\n    return defaultTime;\n}\nvar ServerMethod = {\n    create: create$1,\n    close: close$1,\n    onMessage: onMessage$1,\n    postMessage: postMessage$1,\n    canBeUsed: canBeUsed$1,\n    type: type$1,\n    averageResponseTime: averageResponseTime$1,\n    microSeconds: microSeconds$1\n};\nconst microSeconds = microSeconds$5;\nconst type = \"simulate\";\nconst SIMULATE_CHANNELS = new Set();\nconst SIMULATE_DELAY_TIME = 5;\nfunction create(channelName) {\n    const state = {\n        time: microSeconds$5(),\n        name: channelName,\n        messagesCallback: null\n    };\n    SIMULATE_CHANNELS.add(state);\n    return state;\n}\nfunction close(channelState) {\n    SIMULATE_CHANNELS.delete(channelState);\n}\nfunction postMessage(channelState, messageJson) {\n    return new Promise((res)=>setTimeout(()=>{\n            const channelArray = Array.from(SIMULATE_CHANNELS);\n            channelArray.forEach((channel)=>{\n                if (channel.name === channelState.name && // has same name\n                channel !== channelState && // not own channel\n                !!channel.messagesCallback && // has subscribers\n                channel.time < messageJson.time // channel not created after postMessage() call\n                ) {\n                    channel.messagesCallback(messageJson);\n                }\n            });\n            res();\n        }, SIMULATE_DELAY_TIME));\n}\nfunction onMessage(channelState, fn1) {\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed() {\n    return true;\n}\nfunction averageResponseTime() {\n    return SIMULATE_DELAY_TIME;\n}\nvar SimulateMethod = {\n    create,\n    close,\n    onMessage,\n    postMessage,\n    canBeUsed,\n    type,\n    averageResponseTime,\n    microSeconds\n};\n// order is important\nconst METHODS = [\n    NativeMethod,\n    // fastest\n    IndexeDbMethod,\n    LocalstorageMethod,\n    ServerMethod\n];\nfunction chooseMethod(options) {\n    let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n    // directly chosen\n    if (options.type) {\n        if (options.type === \"simulate\") {\n            // only use simulate-method if directly chosen\n            return SimulateMethod;\n        }\n        const ret = chooseMethods.find((m)=>m.type === options.type);\n        if (!ret) throw new Error(\"method-type \" + options.type + \" not found\");\n        else return ret;\n    }\n    /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */ if (!options.webWorkerSupport) {\n        chooseMethods = chooseMethods.filter((m)=>m.type !== \"idb\");\n    }\n    const useMethod = chooseMethods.find((method)=>method.canBeUsed(options));\n    if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map((m)=>m.type))}`);\n    else return useMethod;\n}\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */ const OPEN_BROADCAST_CHANNELS = new Set();\nlet lastId = 0;\nconst BroadcastChannel$1 = function(name, options) {\n    // identifier of the channel to debug stuff\n    this.id = lastId++;\n    OPEN_BROADCAST_CHANNELS.add(this);\n    this.name = name;\n    if (ENFORCED_OPTIONS) {\n        options = ENFORCED_OPTIONS;\n    }\n    this.options = fillOptionsWithDefaults(options);\n    this.method = chooseMethod(this.options);\n    // isListening\n    this._iL = false;\n    /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */ this._onML = null;\n    /**\n   * _addEventListeners\n   */ this._addEL = {\n        message: [],\n        internal: []\n    };\n    /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */ this._uMP = new Set();\n    /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */ this._befC = [];\n    /**\n   * _preparePromise\n   */ this._prepP = null;\n    _prepareChannel(this);\n};\n// STATICS\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */ BroadcastChannel$1._pubkey = true;\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */ let ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n    ENFORCED_OPTIONS = options;\n}\n// PROTOTYPE\nBroadcastChannel$1.prototype = {\n    postMessage (msg) {\n        if (this.closed) {\n            throw new Error(\"BroadcastChannel.postMessage(): \" + \"Cannot post message after channel has closed \" + /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */ JSON.stringify(msg));\n        }\n        return _post(this, \"message\", msg);\n    },\n    postInternal (msg) {\n        return _post(this, \"internal\", msg);\n    },\n    set onmessage (fn){\n        const time = this.method.microSeconds();\n        const listenObj = {\n            time,\n            fn\n        };\n        _removeListenerObject(this, \"message\", this._onML);\n        if (fn && typeof fn === \"function\") {\n            this._onML = listenObj;\n            _addListenerObject(this, \"message\", listenObj);\n        } else {\n            this._onML = null;\n        }\n    },\n    addEventListener (type, fn1) {\n        const time = this.method.microSeconds();\n        const listenObj = {\n            time,\n            fn: fn1\n        };\n        _addListenerObject(this, type, listenObj);\n    },\n    removeEventListener (type, fn1) {\n        const obj = this._addEL[type].find((obj)=>obj.fn === fn1);\n        _removeListenerObject(this, type, obj);\n    },\n    close () {\n        if (this.closed) {\n            return;\n        }\n        OPEN_BROADCAST_CHANNELS.delete(this);\n        this.closed = true;\n        const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n        this._onML = null;\n        this._addEL.message = [];\n        return awaitPrepare// wait until all current sending are processed\n        .then(()=>Promise.all(Array.from(this._uMP)))// run before-close hooks\n        .then(()=>Promise.all(this._befC.map((fn1)=>fn1())))// close the channel\n        .then(()=>this.method.close(this._state));\n    },\n    get type () {\n        return this.method.type;\n    },\n    get isClosed () {\n        return this.closed;\n    }\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */ function _post(broadcastChannel, type, msg) {\n    const time = broadcastChannel.method.microSeconds();\n    const msgObj = {\n        time,\n        type,\n        data: msg\n    };\n    const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n    return awaitPrepare.then(()=>{\n        const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n        // add/remove to unsend messages list\n        broadcastChannel._uMP.add(sendPromise);\n        sendPromise.catch().then(()=>broadcastChannel._uMP.delete(sendPromise));\n        return sendPromise;\n    });\n}\nfunction _prepareChannel(channel) {\n    const maybePromise = channel.method.create(channel.name, channel.options);\n    if (isPromise(maybePromise)) {\n        channel._prepP = maybePromise;\n        maybePromise.then((s)=>{\n            // used in tests to simulate slow runtime\n            /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/ channel._state = s;\n        });\n    } else {\n        channel._state = maybePromise;\n    }\n}\nfunction _hasMessageListeners(channel) {\n    if (channel._addEL.message.length > 0) return true;\n    if (channel._addEL.internal.length > 0) return true;\n    return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n    channel._addEL[type].push(obj);\n    _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n    channel._addEL[type] = channel._addEL[type].filter((o)=>o !== obj);\n    _stopListening(channel);\n}\nfunction _startListening(channel) {\n    if (!channel._iL && _hasMessageListeners(channel)) {\n        // someone is listening, start subscribing\n        const listenerFn = (msgObj)=>{\n            channel._addEL[msgObj.type].forEach((listenerObject)=>{\n                /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */ // const hundredMsInMicro = 100 * 1000;\n                // const minMessageTime = listenerObject.time - hundredMsInMicro;\n                if (msgObj.time >= listenerObject.time) {\n                    listenerObject.fn(msgObj.data);\n                } else if (channel.method.type === \"server\") {\n                    // server msg might lag based on connection.\n                    listenerObject.fn(msgObj.data);\n                }\n            });\n        };\n        const time = channel.method.microSeconds();\n        if (channel._prepP) {\n            channel._prepP.then(()=>{\n                channel._iL = true;\n                channel.method.onMessage(channel._state, listenerFn, time);\n            });\n        } else {\n            channel._iL = true;\n            channel.method.onMessage(channel._state, listenerFn, time);\n        }\n    }\n}\nfunction _stopListening(channel) {\n    if (channel._iL && !_hasMessageListeners(channel)) {\n        // noone is listening, stop subscribing\n        channel._iL = false;\n        const time = channel.method.microSeconds();\n        channel.method.onMessage(channel._state, null, time);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2Jyb2FkY2FzdENoYW5uZWwuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2E7QUFDUDtBQUNnQjtBQUM0QjtBQUVsRiwrQkFBK0I7QUFFL0I7O0NBRUMsR0FDRCxTQUFTUSxVQUFVQyxHQUFHO0lBQ3BCLElBQUlBLE9BQU8sT0FBT0EsSUFBSUMsSUFBSSxLQUFLLFlBQVk7UUFDekMsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUNBQyxRQUFRQyxPQUFPLENBQUM7QUFDaEJELFFBQVFDLE9BQU8sQ0FBQztBQUNoQixNQUFNQyx3QkFBd0JGLFFBQVFDLE9BQU87QUFDN0MsU0FBU0UsTUFBTUMsSUFBSSxFQUFFQyxXQUFXO0lBQzlCLElBQUksQ0FBQ0QsTUFBTUEsT0FBTztJQUNsQixPQUFPLElBQUlKLFFBQVFNLENBQUFBLE1BQU9DLFdBQVcsSUFBTUQsSUFBSUQsY0FBY0Q7QUFDL0Q7QUFDQSxTQUFTSSxVQUFVQyxHQUFHLEVBQUVDLEdBQUc7SUFDekIsT0FBT0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQU1ILENBQUFBLE1BQU1ELE1BQU0sS0FBS0E7QUFDdEQ7QUFFQTs7Q0FFQyxHQUNELFNBQVNLO0lBQ1AsT0FBT0gsS0FBS0UsTUFBTSxHQUFHRSxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDO0FBQzlDO0FBQ0EsSUFBSUMsU0FBUztBQUViOzs7Ozs7Q0FNQyxHQUNELFNBQVNDO0lBQ1AsSUFBSUMsTUFBTUMsS0FBS0MsR0FBRyxLQUFLLE1BQU0sK0JBQStCO0lBQzVELElBQUlGLE9BQU9GLFFBQVE7UUFDakJFLE1BQU1GLFNBQVM7SUFDakI7SUFDQUEsU0FBU0U7SUFDVCxPQUFPQTtBQUNUO0FBRUEsa0ZBQWtGO0FBQ2xGLGlEQUFpRDtBQUNqRCw4RUFBOEU7QUFDOUUsbUZBQW1GO0FBQ25G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Ozs7Ozs7OztTQVFDLEdBQ0QsdUNBQXVDO2dCQUN2QyxpRUFBaUU7Z0JBRWpFLElBQUl0SixPQUFPckosSUFBSSxJQUFJMlMsZUFBZTNTLElBQUksRUFBRTtvQkFDdEMyUyxlQUFlalEsRUFBRSxDQUFDMkcsT0FBT3JILElBQUk7Z0JBQy9CLE9BQU8sSUFBSWlPLFFBQVF2QyxNQUFNLENBQUN2SyxJQUFJLEtBQUssVUFBVTtvQkFDM0MsNENBQTRDO29CQUM1Q3dQLGVBQWVqUSxFQUFFLENBQUMyRyxPQUFPckgsSUFBSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsTUFBTWhDLE9BQU9pUSxRQUFRdkMsTUFBTSxDQUFDckssWUFBWTtRQUN4QyxJQUFJNE0sUUFBUXFCLE1BQU0sRUFBRTtZQUNsQnJCLFFBQVFxQixNQUFNLENBQUMzUixJQUFJLENBQUM7Z0JBQ2xCc1EsUUFBUWMsR0FBRyxHQUFHO2dCQUNkZCxRQUFRdkMsTUFBTSxDQUFDekssU0FBUyxDQUFDZ04sUUFBUStCLE1BQU0sRUFBRVUsWUFBWTFTO1lBQ3ZEO1FBQ0YsT0FBTztZQUNMaVEsUUFBUWMsR0FBRyxHQUFHO1lBQ2RkLFFBQVF2QyxNQUFNLENBQUN6SyxTQUFTLENBQUNnTixRQUFRK0IsTUFBTSxFQUFFVSxZQUFZMVM7UUFDdkQ7SUFDRjtBQUNGO0FBQ0EsU0FBU3lTLGVBQWV4QyxPQUFPO0lBQzdCLElBQUlBLFFBQVFjLEdBQUcsSUFBSSxDQUFDdUIscUJBQXFCckMsVUFBVTtRQUNqRCx1Q0FBdUM7UUFDdkNBLFFBQVFjLEdBQUcsR0FBRztRQUNkLE1BQU0vUSxPQUFPaVEsUUFBUXZDLE1BQU0sQ0FBQ3JLLFlBQVk7UUFDeEM0TSxRQUFRdkMsTUFBTSxDQUFDekssU0FBUyxDQUFDZ04sUUFBUStCLE1BQU0sRUFBRSxNQUFNaFM7SUFDakQ7QUFDRjtBQUVrTiIsInNvdXJjZXMiOlsid2VicGFjazovL3FvZ25pdGEvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2Jyb2FkY2FzdENoYW5uZWwuZXNtLmpzPzk3MzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZ2xldmVsIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IE9ibGl2aW91c1NldCB9IGZyb20gJ29ibGl2aW91cy1zZXQnO1xuaW1wb3J0IHsgaW8gfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCB7IGdldFB1YmxpYywgc2lnbiB9IGZyb20gJ0B0b3J1c2xhYnMvZWNjcnlwdG8nO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBlbmNyeXB0RGF0YSwgZGVjcnlwdERhdGEgfSBmcm9tICdAdG9ydXNsYWJzL21ldGFkYXRhLWhlbHBlcnMnO1xuXG4vLyBpbXBvcnQgQm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblByb21pc2UucmVzb2x2ZShmYWxzZSk7XG5Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5jb25zdCBQUk9NSVNFX1JFU09MVkVEX1ZPSUQgPSBQcm9taXNlLnJlc29sdmUoKTtcbmZ1bmN0aW9uIHNsZWVwKHRpbWUsIHJlc29sdmVXaXRoKSB7XG4gIGlmICghdGltZSkgdGltZSA9IDA7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dCgoKSA9PiByZXMocmVzb2x2ZVdpdGgpLCB0aW1lKSk7XG59XG5mdW5jdGlvbiByYW5kb21JbnQobWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbik7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgwODQyNDhcbiAqL1xuZnVuY3Rpb24gcmFuZG9tVG9rZW4oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG59XG5sZXQgbGFzdE1zID0gMDtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gbWljcm8tc2Vjb25kcyxcbiAqIFdBUk5JTkc6IFRoaXMgaXMgYSBwc2V1ZG8tZnVuY3Rpb25cbiAqIFBlcmZvcm1hbmNlLm5vdyBpcyBub3QgcmVsaWFibGUgaW4gd2Vid29ya2Vycywgc28gd2UganVzdCBtYWtlIHN1cmUgdG8gbmV2ZXIgcmV0dXJuIHRoZSBzYW1lIHRpbWUuXG4gKiBUaGlzIGlzIGVub3VnaCBpbiBicm93c2VycywgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgYmUgdXNlZCBpbiBub2RlanMuXG4gKiBUaGUgbWFpbiByZWFzb24gZm9yIHRoaXMgaGFjayBpcyB0byBlbnN1cmUgdGhhdCBCcm9hZGNhc3RDaGFubmVsIGJlaGF2ZXMgZXF1YWwgdG8gcHJvZHVjdGlvbiB3aGVuIGl0IGlzIHVzZWQgaW4gZmFzdC1ydW5uaW5nIHVuaXQgdGVzdHMuXG4gKi9cbmZ1bmN0aW9uIG1pY3JvU2Vjb25kcyQ1KCkge1xuICBsZXQgcmV0ID0gRGF0ZS5ub3coKSAqIDEwMDA7IC8vIG1pbGxpc2Vjb25kcyB0byBtaWNyb3NlY29uZHNcbiAgaWYgKHJldCA8PSBsYXN0TXMpIHtcbiAgICByZXQgPSBsYXN0TXMgKyAxO1xuICB9XG4gIGxhc3RNcyA9IHJldDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gdGhlIHByb2JsZW0gaXMgb25seSBpbiBpZnJhbWVzLiB3ZSBzaG91bGQgZGVmYXVsdCB0byBzZXJ2ZXIgaW4gY2FzZSBvZiBpZnJhbWVzLlxuLy8gc3RvcmFnZSBzY29waW5nIGlzIHByZXNlbnQgaW4gYWxsIGJyb3dzZXJzIG5vd1xuLy8gU2FmYXJpIGFuZCBvdGhlciBicm93c2VycyBzdXBwb3J0IG5hdGl2ZSBCcm9hZGNhc3QgY2hhbm5lbCBub3cuIEl0J3MgaW4gTFMuXG4vLyB0ZXN0IGhlcmU6IGh0dHBzOi8vcHVia2V5LmdpdGh1Yi5pby9icm9hZGNhc3QtY2hhbm5lbC9lMmUuaHRtbD9tZXRob2RUeXBlPW5hdGl2ZVxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9icm9hZGNhc3RjaGFubmVsXG4vLyBleHBvcnQgZnVuY3Rpb24gYXJlM1BDU3VwcG9ydGVkKCkge1xuLy8gICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuLy8gICAgIGNvbnN0IGJyb3dzZXJJbmZvID0gQm93c2VyLnBhcnNlKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gICAgIGxvZy5pbmZvKEpTT04uc3RyaW5naWZ5KGJyb3dzZXJJbmZvKSwgJ2N1cnJlbnQgYnJvd3NlciBpbmZvJyk7XG5cbi8vICAgICBsZXQgdGhpcmRQYXJ0eUNvb2tpZVN1cHBvcnQgPSB0cnVlO1xuLy8gICAgIC8vIGJyYXZlXG4vLyAgICAgaWYgKG5hdmlnYXRvci5icmF2ZSkge1xuLy8gICAgICAgICB0aGlyZFBhcnR5Q29va2llU3VwcG9ydCA9IGZhbHNlO1xuLy8gICAgIH1cbi8vICAgICAvLyBBbGwgd2Via2l0ICYgZ2Vja28gZW5naW5lIGluc3RhbmNlcyB1c2UgaXRwIChpbnRlbGxpZ2VudCB0cmFja2luZyBwcmV2ZW50aW9uIC1cbi8vICAgICAvLyBodHRwczovL3dlYmtpdC5vcmcvdHJhY2tpbmctcHJldmVudGlvbi8jaW50ZWxsaWdlbnQtdHJhY2tpbmctcHJldmVudGlvbi1pdHApXG4vLyAgICAgaWYgKGJyb3dzZXJJbmZvLmVuZ2luZS5uYW1lID09PSBCb3dzZXIuRU5HSU5FX01BUC5XZWJLaXQgfHwgYnJvd3NlckluZm8uZW5naW5lLm5hbWUgPT09IEJvd3Nlci5FTkdJTkVfTUFQLkdlY2tvKSB7XG4vLyAgICAgICAgIHRoaXJkUGFydHlDb29raWVTdXBwb3J0ID0gZmFsc2U7XG4vLyAgICAgfVxuXG4vLyAgICAgcmV0dXJuIHRoaXJkUGFydHlDb29raWVTdXBwb3J0O1xuLy8gfVxuXG5jb25zdCBsb2cgPSBsb2dsZXZlbC5nZXRMb2dnZXIoJ2Jyb2FkY2FzdC1jaGFubmVsJyk7XG5sb2cuc2V0TGV2ZWwoJ2Vycm9yJyk7XG5cbmNvbnN0IG1pY3JvU2Vjb25kcyQ0ID0gbWljcm9TZWNvbmRzJDU7XG5jb25zdCB0eXBlJDQgPSAnbmF0aXZlJztcbmZ1bmN0aW9uIGNyZWF0ZSQ0KGNoYW5uZWxOYW1lKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHRpbWU6IG1pY3JvU2Vjb25kcyQ1KCksXG4gICAgbWVzc2FnZXNDYWxsYmFjazogbnVsbCxcbiAgICBiYzogbmV3IEJyb2FkY2FzdENoYW5uZWwoY2hhbm5lbE5hbWUpLFxuICAgIHN1YkZuczogW10gLy8gc3Vic2NyaWJlckZ1bmN0aW9uc1xuICB9O1xuICBzdGF0ZS5iYy5vbm1lc3NhZ2UgPSBtc2cgPT4ge1xuICAgIGlmIChzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSB7XG4gICAgICBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKG1zZy5kYXRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlJDQoY2hhbm5lbFN0YXRlKSB7XG4gIGNoYW5uZWxTdGF0ZS5iYy5jbG9zZSgpO1xuICBjaGFubmVsU3RhdGUuc3ViRm5zID0gW107XG59XG5mdW5jdGlvbiBwb3N0TWVzc2FnZSQ0KGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgdHJ5IHtcbiAgICBjaGFubmVsU3RhdGUuYmMucG9zdE1lc3NhZ2UobWVzc2FnZUpzb24sIGZhbHNlKTtcbiAgICByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgfVxufVxuZnVuY3Rpb24gb25NZXNzYWdlJDQoY2hhbm5lbFN0YXRlLCBmbikge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZnVuY3Rpb24gY2FuQmVVc2VkJDQoKSB7XG4gIC8qKlxuICAgKiBpbiB0aGUgZWxlY3Ryb24tcmVuZGVyZXIsIGlzTm9kZSB3aWxsIGJlIHRydWUgZXZlbiBpZiB3ZSBhcmUgaW4gYnJvd3Nlci1jb250ZXh0XG4gICAqIHNvIHdlIGFsc28gY2hlY2sgaWYgd2luZG93IGlzIHVuZGVmaW5lZFxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChCcm9hZGNhc3RDaGFubmVsLl9wdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbDogRG8gbm90IG92ZXJ3cml0ZSB3aW5kb3cuQnJvYWRjYXN0Q2hhbm5lbCB3aXRoIHRoaXMgbW9kdWxlLCB0aGlzIGlzIG5vdCBhIHBvbHlmaWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSQ0KCkge1xuICByZXR1cm4gMTUwO1xufVxudmFyIE5hdGl2ZU1ldGhvZCA9IHtcbiAgY3JlYXRlOiBjcmVhdGUkNCxcbiAgY2xvc2U6IGNsb3NlJDQsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlJDQsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSQ0LFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCQ0LFxuICB0eXBlOiB0eXBlJDQsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUkNCxcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHMkNFxufTtcblxuZnVuY3Rpb24gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMoKSB7XG4gIGxldCBvcmlnaW5hbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcmlnaW5hbE9wdGlvbnMpKTtcblxuICAvLyBtYWluXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy53ZWJXb3JrZXJTdXBwb3J0ID09PSAndW5kZWZpbmVkJykgb3B0aW9ucy53ZWJXb3JrZXJTdXBwb3J0ID0gdHJ1ZTtcblxuICAvLyBpbmRleGVkLWRiXG4gIGlmICghb3B0aW9ucy5pZGIpIG9wdGlvbnMuaWRiID0ge307XG4gIC8vICBhZnRlciB0aGlzIHRpbWUgdGhlIG1lc3NhZ2VzIGdldCBkZWxldGVkXG4gIGlmICghb3B0aW9ucy5pZGIudHRsKSBvcHRpb25zLmlkYi50dGwgPSAxMDAwICogNDU7XG4gIGlmICghb3B0aW9ucy5pZGIuZmFsbGJhY2tJbnRlcnZhbCkgb3B0aW9ucy5pZGIuZmFsbGJhY2tJbnRlcnZhbCA9IDE1MDtcbiAgLy8gIGhhbmRsZXMgYWJydXB0IGRiIG9uY2xvc2UgZXZlbnRzLlxuICBpZiAob3JpZ2luYWxPcHRpb25zLmlkYiAmJiB0eXBlb2Ygb3JpZ2luYWxPcHRpb25zLmlkYi5vbmNsb3NlID09PSAnZnVuY3Rpb24nKSBvcHRpb25zLmlkYi5vbmNsb3NlID0gb3JpZ2luYWxPcHRpb25zLmlkYi5vbmNsb3NlO1xuXG4gIC8vIGxvY2Fsc3RvcmFnZVxuICBpZiAoIW9wdGlvbnMubG9jYWxzdG9yYWdlKSBvcHRpb25zLmxvY2Fsc3RvcmFnZSA9IHt9O1xuICBpZiAoIW9wdGlvbnMubG9jYWxzdG9yYWdlLnJlbW92ZVRpbWVvdXQpIG9wdGlvbnMubG9jYWxzdG9yYWdlLnJlbW92ZVRpbWVvdXQgPSAxMDAwICogNjA7XG5cbiAgLy8gc2VydmVyXG4gIGlmICghb3B0aW9ucy5zZXJ2ZXIpIG9wdGlvbnMuc2VydmVyID0ge307XG4gIGlmICghb3B0aW9ucy5zZXJ2ZXIudXJsKSBvcHRpb25zLnNlcnZlci51cmwgPSAnaHR0cHM6Ly9zZXNzaW9uLndlYjNhdXRoLmlvJztcbiAgaWYgKCFvcHRpb25zLnNlcnZlci5yZW1vdmVUaW1lb3V0KSBvcHRpb25zLnNlcnZlci5yZW1vdmVUaW1lb3V0ID0gMTAwMCAqIDYwICogNTsgLy8gNSBtaW51dGVzXG5cbiAgLy8gY3VzdG9tIG1ldGhvZHNcbiAgaWYgKG9yaWdpbmFsT3B0aW9ucy5tZXRob2RzKSBvcHRpb25zLm1ldGhvZHMgPSBvcmlnaW5hbE9wdGlvbnMubWV0aG9kcztcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogdGhpcyBtZXRob2QgdXNlcyBpbmRleGVkZGIgdG8gc3RvcmUgdGhlIG1lc3NhZ2VzXG4gKiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gb2JzZXJ2ZXJBUEkgZm9yIGlkYlxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbmRleGVkREIvaXNzdWVzLzUxXG4gKlxuICogV2hlbiB3b3JraW5nIG9uIHRoaXMsIGVuc3VyZSB0byB1c2UgdGhlc2UgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqIEBsaW5rIGh0dHBzOi8vcnhkYi5pbmZvL3Nsb3ctaW5kZXhlZGRiLmh0bWxcbiAqL1xuXG5jb25zdCBtaWNyb1NlY29uZHMkMyA9IG1pY3JvU2Vjb25kcyQ1O1xuY29uc3QgREJfUFJFRklYID0gJ3B1YmtleS5icm9hZGNhc3QtY2hhbm5lbC0wLSc7XG5jb25zdCBPQkpFQ1RfU1RPUkVfSUQgPSAnbWVzc2FnZXMnO1xuXG4vKipcbiAqIFVzZSByZWxheGVkIGR1cmFiaWxpdHkgZm9yIGZhc3RlciBwZXJmb3JtYW5jZSBvbiBhbGwgdHJhbnNhY3Rpb25zLlxuICogQGxpbmsgaHR0cHM6Ly9ub2xhbmxhd3Nvbi5jb20vMjAyMS8wOC8yMi9zcGVlZGluZy11cC1pbmRleGVkZGItcmVhZHMtYW5kLXdyaXRlcy9cbiAqL1xuY29uc3QgVFJBTlNBQ1RJT05fU0VUVElOR1MgPSB7XG4gIGR1cmFiaWxpdHk6ICdyZWxheGVkJ1xufTtcbmNvbnN0IHR5cGUkMyA9ICdpZGInO1xuZnVuY3Rpb24gZ2V0SWRiKCkge1xuICBpZiAodHlwZW9mIGluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBpbmRleGVkREI7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93Lm1vekluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3aW5kb3cubW96SW5kZXhlZERCO1xuICAgIGlmICh0eXBlb2Ygd2luZG93LndlYmtpdEluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3aW5kb3cud2Via2l0SW5kZXhlZERCO1xuICAgIGlmICh0eXBlb2Ygd2luZG93Lm1zSW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy5tc0luZGV4ZWREQjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSWYgcG9zc2libGUsIHdlIHNob3VsZCBleHBsaWNpdGx5IGNvbW1pdCBJbmRleGVkREIgdHJhbnNhY3Rpb25zXG4gKiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICogQGxpbmsgaHR0cHM6Ly9ub2xhbmxhd3Nvbi5jb20vMjAyMS8wOC8yMi9zcGVlZGluZy11cC1pbmRleGVkZGItcmVhZHMtYW5kLXdyaXRlcy9cbiAqL1xuZnVuY3Rpb24gY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpIHtcbiAgaWYgKHR4LmNvbW1pdCkge1xuICAgIHR4LmNvbW1pdCgpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhYmFzZShjaGFubmVsTmFtZSkge1xuICBjb25zdCBJbmRleGVkREIgPSBnZXRJZGIoKTtcblxuICAvLyBjcmVhdGUgdGFibGVcbiAgY29uc3QgZGJOYW1lID0gREJfUFJFRklYICsgY2hhbm5lbE5hbWU7XG5cbiAgLyoqXG4gICAqIEFsbCBJbmRleGVkREIgZGF0YWJhc2VzIGFyZSBvcGVuZWQgd2l0aG91dCB2ZXJzaW9uXG4gICAqIGJlY2F1c2UgaXQgaXMgYSBiaXQgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIGZpcmVmb3hcbiAgICogQGxpbmsgaHR0cDovL25wYXJhc2h1cmFtLmNvbS9JbmRleGVkREIvcGVyZi8jT3BlbiUyMERhdGFiYXNlJTIwd2l0aCUyMHZlcnNpb25cbiAgICovXG4gIGNvbnN0IG9wZW5SZXF1ZXN0ID0gSW5kZXhlZERCLm9wZW4oZGJOYW1lKTtcbiAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZXYgPT4ge1xuICAgIGNvbnN0IGRiID0gZXYudGFyZ2V0LnJlc3VsdDtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQsIHtcbiAgICAgIGtleVBhdGg6ICdpZCcsXG4gICAgICBhdXRvSW5jcmVtZW50OiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGRiUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBldiA9PiByZWooZXYpO1xuICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgIHJlcyhvcGVuUmVxdWVzdC5yZXN1bHQpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZGJQcm9taXNlO1xufVxuXG4vKipcbiAqIHdyaXRlcyB0aGUgbmV3IG1lc3NhZ2UgdG8gdGhlIGRhdGFiYXNlXG4gKiBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XG4gKi9cbmZ1bmN0aW9uIHdyaXRlTWVzc2FnZShkYiwgcmVhZGVyVXVpZCwgbWVzc2FnZUpzb24pIHtcbiAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IHdyaXRlT2JqZWN0ID0ge1xuICAgIHV1aWQ6IHJlYWRlclV1aWQsXG4gICAgdGltZSxcbiAgICBkYXRhOiBtZXNzYWdlSnNvblxuICB9O1xuICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFtPQkpFQ1RfU1RPUkVfSURdLCAncmVhZHdyaXRlJywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgdHgub25jb21wbGV0ZSA9ICgpID0+IHJlcygpO1xuICAgIHR4Lm9uZXJyb3IgPSBldiA9PiByZWooZXYpO1xuICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgICBvYmplY3RTdG9yZS5hZGQod3JpdGVPYmplY3QpO1xuICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBbGxNZXNzYWdlcyhkYikge1xuICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCwgJ3JlYWRvbmx5JywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIGNvbnN0IHJldCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzID0+IHtcbiAgICBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKCkub25zdWNjZXNzID0gZXYgPT4ge1xuICAgICAgY29uc3QgY3Vyc29yID0gZXYudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgcmV0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgLy9hbGVydChcIk5hbWUgZm9yIFNTTiBcIiArIGN1cnNvci5rZXkgKyBcIiBpcyBcIiArIGN1cnNvci52YWx1ZS5uYW1lKTtcbiAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJlcyhyZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZXNIaWdoZXJUaGFuKGRiLCBsYXN0Q3Vyc29ySWQpIHtcbiAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkb25seScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICBjb25zdCByZXQgPSBbXTtcbiAgbGV0IGtleVJhbmdlVmFsdWUgPSBJREJLZXlSYW5nZS5ib3VuZChsYXN0Q3Vyc29ySWQgKyAxLCBJbmZpbml0eSk7XG5cbiAgLyoqXG4gICAqIE9wdGltaXphdGlvbiBzaG9ydGN1dCxcbiAgICogaWYgZ2V0QWxsKCkgY2FuIGJlIHVzZWQsIGRvIG5vdCB1c2UgYSBjdXJzb3IuXG4gICAqIEBsaW5rIGh0dHBzOi8vcnhkYi5pbmZvL3Nsb3ctaW5kZXhlZGRiLmh0bWxcbiAgICovXG4gIGlmIChvYmplY3RTdG9yZS5nZXRBbGwpIHtcbiAgICBjb25zdCBnZXRBbGxSZXF1ZXN0ID0gb2JqZWN0U3RvcmUuZ2V0QWxsKGtleVJhbmdlVmFsdWUpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIGdldEFsbFJlcXVlc3Qub25lcnJvciA9IGVyciA9PiByZWooZXJyKTtcbiAgICAgIGdldEFsbFJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmVzKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9wZW5DdXJzb3IoKSB7XG4gICAgLy8gT2NjYXNpb25hbGx5IFNhZmFyaSB3aWxsIGZhaWwgb24gSURCS2V5UmFuZ2UuYm91bmQsIHRoaXNcbiAgICAvLyBjYXRjaGVzIHRoYXQgZXJyb3IsIGhhdmluZyBpdCBvcGVuIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0XG4gICAgLy8gaXRlbS4gV2hlbiBpdCBnZXRzIGRhdGEgaXQgd2lsbCBhZHZhbmNlIHRvIHRoZSBkZXNpcmVkIGtleS5cbiAgICB0cnkge1xuICAgICAga2V5UmFuZ2VWYWx1ZSA9IElEQktleVJhbmdlLmJvdW5kKGxhc3RDdXJzb3JJZCArIDEsIEluZmluaXR5KTtcbiAgICAgIHJldHVybiBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlVmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBjb25zdCBvcGVuQ3Vyc29yUmVxdWVzdCA9IG9wZW5DdXJzb3IoKTtcbiAgICBvcGVuQ3Vyc29yUmVxdWVzdC5vbmVycm9yID0gZXJyID0+IHJlaihlcnIpO1xuICAgIG9wZW5DdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IGV2ID0+IHtcbiAgICAgIGNvbnN0IGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIGlmIChjdXJzb3IudmFsdWUuaWQgPCBsYXN0Q3Vyc29ySWQgKyAxKSB7XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKGxhc3RDdXJzb3JJZCArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmVzKHJldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVNZXNzYWdlc0J5SWQoZGIsIGlkcykge1xuICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFtPQkpFQ1RfU1RPUkVfSURdLCAncmVhZHdyaXRlJywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIHJldHVybiBQcm9taXNlLmFsbChpZHMubWFwKGlkID0+IHtcbiAgICBjb25zdCBkZWxldGVSZXF1ZXN0ID0gb2JqZWN0U3RvcmUuZGVsZXRlKGlkKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzID0+IHtcbiAgICAgIGRlbGV0ZVJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzKCk7XG4gICAgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGdldE9sZE1lc3NhZ2VzKGRiLCB0dGwpIHtcbiAgY29uc3Qgb2xkZXJUaGVuID0gRGF0ZS5ub3coKSAtIHR0bDtcbiAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkb25seScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICBjb25zdCByZXQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiB7XG4gICAgb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGV2ID0+IHtcbiAgICAgIGNvbnN0IGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IG1zZ09iayA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgaWYgKG1zZ09iay50aW1lIDwgb2xkZXJUaGVuKSB7XG4gICAgICAgICAgcmV0LnB1c2gobXNnT2JrKTtcbiAgICAgICAgICAvL2FsZXJ0KFwiTmFtZSBmb3IgU1NOIFwiICsgY3Vyc29yLmtleSArIFwiIGlzIFwiICsgY3Vyc29yLnZhbHVlLm5hbWUpO1xuICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIG1vcmUgb2xkIG1lc3NhZ2VzLFxuICAgICAgICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICByZXMocmV0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyhyZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYW5PbGRNZXNzYWdlcyhkYiwgdHRsKSB7XG4gIHJldHVybiBnZXRPbGRNZXNzYWdlcyhkYiwgdHRsKS50aGVuKHRvb09sZCA9PiB7XG4gICAgcmV0dXJuIHJlbW92ZU1lc3NhZ2VzQnlJZChkYiwgdG9vT2xkLm1hcChtc2cgPT4gbXNnLmlkKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlJDMoY2hhbm5lbE5hbWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICByZXR1cm4gY3JlYXRlRGF0YWJhc2UoY2hhbm5lbE5hbWUpLnRoZW4oZGIgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgY2xvc2VkOiBmYWxzZSxcbiAgICAgIGxhc3RDdXJzb3JJZDogMCxcbiAgICAgIGNoYW5uZWxOYW1lLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHV1aWQ6IHJhbmRvbVRva2VuKCksXG4gICAgICAvKipcbiAgICAgICAqIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICAgICAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAgICAgKiBAdHlwZSB7T2JsaXZpb3VzU2V0fVxuICAgICAgICovXG4gICAgICBlTUlzOiBuZXcgT2JsaXZpb3VzU2V0KG9wdGlvbnMuaWRiLnR0bCAqIDIpLFxuICAgICAgLy8gZW5zdXJlcyB3ZSBkbyBub3QgcmVhZCBtZXNzYWdlcyBpbiBwYXJyYWxsZWxcbiAgICAgIHdyaXRlQmxvY2tQcm9taXNlOiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQsXG4gICAgICBtZXNzYWdlc0NhbGxiYWNrOiBudWxsLFxuICAgICAgcmVhZFF1ZXVlUHJvbWlzZXM6IFtdLFxuICAgICAgZGIsXG4gICAgICB0aW1lOiBtaWNyb1NlY29uZHMkNSgpXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhYnJ1cHQgY2xvc2VzIHRoYXQgZG8gbm90IG9yaWdpbmF0ZSBmcm9tIGRiLmNsb3NlKCkuXG4gICAgICogVGhpcyBjb3VsZCBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiB0aGUgdW5kZXJseWluZyBzdG9yYWdlIGlzXG4gICAgICogcmVtb3ZlZCBvciBpZiB0aGUgdXNlciBjbGVhcnMgdGhlIGRhdGFiYXNlIGluIHRoZSBicm93c2VyJ3NcbiAgICAgKiBoaXN0b3J5IHByZWZlcmVuY2VzLlxuICAgICAqL1xuICAgIGRiLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdGF0ZS5jbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKG9wdGlvbnMuaWRiLm9uY2xvc2UpIG9wdGlvbnMuaWRiLm9uY2xvc2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaWYgc2VydmljZS13b3JrZXJzIGFyZSB1c2VkLFxuICAgICAqIHdlIGhhdmUgbm8gJ3N0b3JhZ2UnLWV2ZW50IGlmIHRoZXkgcG9zdCBhIG1lc3NhZ2UsXG4gICAgICogdGhlcmVmb3JlIHdlIGFsc28gaGF2ZSB0byBzZXQgYW4gaW50ZXJ2YWxcbiAgICAgKi9cbiAgICBfcmVhZExvb3Aoc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfcmVhZExvb3Aoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmNsb3NlZCkgcmV0dXJuO1xuICByZWFkTmV3TWVzc2FnZXMoc3RhdGUpLnRoZW4oKCkgPT4gc2xlZXAoc3RhdGUub3B0aW9ucy5pZGIuZmFsbGJhY2tJbnRlcnZhbCkpLnRoZW4oKCkgPT4gX3JlYWRMb29wKHN0YXRlKSk7XG59XG5mdW5jdGlvbiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKSB7XG4gIGlmIChtc2dPYmoudXVpZCA9PT0gc3RhdGUudXVpZCkgcmV0dXJuIGZhbHNlOyAvLyBzZW5kIGJ5IG93blxuICBpZiAoc3RhdGUuZU1Jcy5oYXMobXNnT2JqLmlkKSkgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IGVtaXR0ZWRcbiAgaWYgKG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuIGZhbHNlOyAvLyBvbGRlciB0aGVuIG9uTWVzc2FnZUNhbGxiYWNrXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIHJlYWRzIGFsbCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgZGF0YWJhc2UgYW5kIGVtaXRzIHRoZW1cbiAqL1xuZnVuY3Rpb24gcmVhZE5ld01lc3NhZ2VzKHN0YXRlKSB7XG4gIC8vIGNoYW5uZWwgYWxyZWFkeSBjbG9zZWRcbiAgaWYgKHN0YXRlLmNsb3NlZCkgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcblxuICAvLyBpZiBubyBvbmUgaXMgbGlzdGVuaW5nLCB3ZSBkbyBub3QgbmVlZCB0byBzY2FuIGZvciBuZXcgbWVzc2FnZXNcbiAgaWYgKCFzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICByZXR1cm4gZ2V0TWVzc2FnZXNIaWdoZXJUaGFuKHN0YXRlLmRiLCBzdGF0ZS5sYXN0Q3Vyc29ySWQpLnRoZW4obmV3ZXJNZXNzYWdlcyA9PiB7XG4gICAgY29uc3QgdXNlTWVzc2FnZXMgPSBuZXdlck1lc3NhZ2VzXG4gICAgLyoqXG4gICAgICogdGhlcmUgaXMgYSBidWcgaW4gaU9TIHdoZXJlIHRoZSBtc2dPYmogY2FuIGJlIHVuZGVmaW5lZCBzb21lIHRpbWVzXG4gICAgICogc28gd2UgZmlsdGVyIHRoZW0gb3V0XG4gICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3B1YmtleS9icm9hZGNhc3QtY2hhbm5lbC9pc3N1ZXMvMTlcbiAgICAgKi8uZmlsdGVyKG1zZ09iaiA9PiAhIW1zZ09iaikubWFwKG1zZ09iaiA9PiB7XG4gICAgICBpZiAobXNnT2JqLmlkID4gc3RhdGUubGFzdEN1cnNvcklkKSB7XG4gICAgICAgIHN0YXRlLmxhc3RDdXJzb3JJZCA9IG1zZ09iai5pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtc2dPYmo7XG4gICAgfSkuZmlsdGVyKG1zZ09iaiA9PiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKSkuc29ydCgobXNnT2JqQSwgbXNnT2JqQikgPT4gbXNnT2JqQS50aW1lIC0gbXNnT2JqQi50aW1lKTsgLy8gc29ydCBieSB0aW1lXG4gICAgdXNlTWVzc2FnZXMuZm9yRWFjaChtc2dPYmogPT4ge1xuICAgICAgaWYgKHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHtcbiAgICAgICAgc3RhdGUuZU1Jcy5hZGQobXNnT2JqLmlkKTtcbiAgICAgICAgc3RhdGUubWVzc2FnZXNDYWxsYmFjayhtc2dPYmouZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbG9zZSQzKGNoYW5uZWxTdGF0ZSkge1xuICBjaGFubmVsU3RhdGUuY2xvc2VkID0gdHJ1ZTtcbiAgY2hhbm5lbFN0YXRlLmRiLmNsb3NlKCk7XG59XG5mdW5jdGlvbiBwb3N0TWVzc2FnZSQzKGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgY2hhbm5lbFN0YXRlLndyaXRlQmxvY2tQcm9taXNlID0gY2hhbm5lbFN0YXRlLndyaXRlQmxvY2tQcm9taXNlLnRoZW4oKCkgPT4gd3JpdGVNZXNzYWdlKGNoYW5uZWxTdGF0ZS5kYiwgY2hhbm5lbFN0YXRlLnV1aWQsIG1lc3NhZ2VKc29uKSkudGhlbigoKSA9PiB7XG4gICAgaWYgKHJhbmRvbUludCgwLCAxMCkgPT09IDApIHtcbiAgICAgIC8qIGF3YWl0IChkbyBub3QgYXdhaXQpICovXG4gICAgICBjbGVhbk9sZE1lc3NhZ2VzKGNoYW5uZWxTdGF0ZS5kYiwgY2hhbm5lbFN0YXRlLm9wdGlvbnMuaWRiLnR0bCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNoYW5uZWxTdGF0ZS53cml0ZUJsb2NrUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG9uTWVzc2FnZSQzKGNoYW5uZWxTdGF0ZSwgZm4sIHRpbWUpIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lID0gdGltZTtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbiAgcmVhZE5ld01lc3NhZ2VzKGNoYW5uZWxTdGF0ZSk7XG59XG5mdW5jdGlvbiBjYW5CZVVzZWQkMygpIHtcbiAgY29uc3QgaWRiID0gZ2V0SWRiKCk7XG4gIGlmICghaWRiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSQzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwgKiAyO1xufVxudmFyIEluZGV4ZURiTWV0aG9kID0ge1xuICBnZXRJZGIsXG4gIGNyZWF0ZURhdGFiYXNlLFxuICBjcmVhdGU6IGNyZWF0ZSQzLFxuICBjbG9zZTogY2xvc2UkMyxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UkMyxcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlJDMsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkJDMsXG4gIHR5cGU6IHR5cGUkMyxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSQzLFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kcyQzLFxuICB3cml0ZU1lc3NhZ2UsXG4gIGdldEFsbE1lc3NhZ2VzLFxuICBjbGVhbk9sZE1lc3NhZ2VzLFxuICBnZXRNZXNzYWdlc0hpZ2hlclRoYW4sXG4gIGdldE9sZE1lc3NhZ2VzXG59O1xuXG4vKipcbiAqIEEgbG9jYWxTdG9yYWdlLW9ubHkgbWV0aG9kIHdoaWNoIHVzZXMgbG9jYWxzdG9yYWdlIGFuZCBpdHMgJ3N0b3JhZ2UnLWV2ZW50XG4gKiBUaGlzIGRvZXMgbm90IHdvcmsgaW5zaWRlIG9mIHdlYndvcmtlcnMgYmVjYXVzZSB0aGV5IGhhdmUgbm8gYWNjZXNzIHRvIGxvY2FzdG9yYWdlXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBpbXBsZW1lbnRlZCB0byBzdXBwb3J0IElFOSBvciB5b3VyIGdyYW5kbW90aGVycyB0b2FzdGVyLlxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1uYW1ldmFsdWUtc3RvcmFnZVxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1pbmRleGVkZGJcbiAqL1xuXG5jb25zdCBtaWNyb1NlY29uZHMkMiA9IG1pY3JvU2Vjb25kcyQ1O1xuY29uc3QgS0VZX1BSRUZJWCQxID0gJ3B1YmtleS5icm9hZGNhc3RDaGFubmVsLSc7XG5jb25zdCB0eXBlJDIgPSAnbG9jYWxzdG9yYWdlJztcblxuLyoqXG4gKiBjb3BpZWQgZnJvbSBjcm9zc3RhYlxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RlamFjcXVlcy9jcm9zc3RhYi9ibG9iL21hc3Rlci9zcmMvY3Jvc3N0YWIuanMjTDMyXG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZSgpIHtcbiAgbGV0IGxvY2FsU3RvcmFnZTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvd1snaWU4LWV2ZW50bGlzdGVuZXIvc3RvcmFnZSddIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZXcgdmVyc2lvbnMgb2YgRmlyZWZveCB0aHJvdyBhIFNlY3VyaXR5IGV4Y2VwdGlvblxuICAgIC8vIGlmIGNvb2tpZXMgYXJlIGRpc2FibGVkLiBTZWVcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDI4MTUzXG4gIH1cbiAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbn1cbmZ1bmN0aW9uIHN0b3JhZ2VLZXkkMShjaGFubmVsTmFtZSkge1xuICByZXR1cm4gS0VZX1BSRUZJWCQxICsgY2hhbm5lbE5hbWU7XG59XG5cbi8qKlxuICogd3JpdGVzIHRoZSBuZXcgbWVzc2FnZSB0byB0aGUgc3RvcmFnZVxuICogYW5kIGZpcmVzIHRoZSBzdG9yYWdlLWV2ZW50IHNvIG90aGVyIHJlYWRlcnMgY2FuIGZpbmQgaXRcbiAqL1xuZnVuY3Rpb24gcG9zdE1lc3NhZ2UkMihjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgIHNsZWVwKCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBzdG9yYWdlS2V5JDEoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKTtcbiAgICAgIGNvbnN0IHdyaXRlT2JqID0ge1xuICAgICAgICB0b2tlbjogcmFuZG9tVG9rZW4oKSxcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgZGF0YTogbWVzc2FnZUpzb24sXG4gICAgICAgIHV1aWQ6IGNoYW5uZWxTdGF0ZS51dWlkXG4gICAgICB9O1xuICAgICAgY29uc3QgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh3cml0ZU9iaik7XG4gICAgICBnZXRMb2NhbFN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFN0b3JhZ2VFdmVudCBkb2VzIG5vdCBmaXJlIHRoZSAnc3RvcmFnZScgZXZlbnRcbiAgICAgICAqIGluIHRoZSB3aW5kb3cgdGhhdCBjaGFuZ2VzIHRoZSBzdGF0ZSBvZiB0aGUgbG9jYWwgc3RvcmFnZS5cbiAgICAgICAqIFNvIHdlIGZpcmUgaXQgbWFudWFsbHlcbiAgICAgICAqL1xuICAgICAgY29uc3QgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2LmluaXRFdmVudCgnc3RvcmFnZScsIHRydWUsIHRydWUpO1xuICAgICAgZXYua2V5ID0ga2V5O1xuICAgICAgZXYubmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICAgIHJlcygpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFN0b3JhZ2VFdmVudExpc3RlbmVyKGNoYW5uZWxOYW1lLCBmbikge1xuICBjb25zdCBrZXkgPSBzdG9yYWdlS2V5JDEoY2hhbm5lbE5hbWUpO1xuICBjb25zdCBsaXN0ZW5lciA9IGV2ID0+IHtcbiAgICBpZiAoZXYua2V5ID09PSBrZXkpIHtcbiAgICAgIGZuKEpTT04ucGFyc2UoZXYubmV3VmFsdWUpKTtcbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgbGlzdGVuZXIpO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5mdW5jdGlvbiByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGxpc3RlbmVyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZSQyKGNoYW5uZWxOYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgaWYgKCFjYW5CZVVzZWQkMigpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsOiBsb2NhbHN0b3JhZ2UgY2Fubm90IGJlIHVzZWQnKTtcbiAgfVxuICBjb25zdCB1dWlkID0gcmFuZG9tVG9rZW4oKTtcblxuICAvKipcbiAgICogZU1Jc1xuICAgKiBjb250YWlucyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBiZWZvcmVcbiAgICogQHR5cGUge09ibGl2aW91c1NldH1cbiAgICovXG4gIGNvbnN0IGVNSXMgPSBuZXcgT2JsaXZpb3VzU2V0KG9wdGlvbnMubG9jYWxzdG9yYWdlLnJlbW92ZVRpbWVvdXQpO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBjaGFubmVsTmFtZSxcbiAgICB1dWlkLFxuICAgIHRpbWU6IG1pY3JvU2Vjb25kcyQ1KCksXG4gICAgZU1JcyAvLyBlbWl0dGVkTWVzc2FnZXNJZHNcbiAgfTtcbiAgc3RhdGUubGlzdGVuZXIgPSBhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsTmFtZSwgbXNnT2JqID0+IHtcbiAgICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybjsgLy8gbm8gbGlzdGVuZXJcbiAgICBpZiAobXNnT2JqLnV1aWQgPT09IHV1aWQpIHJldHVybjsgLy8gb3duIG1lc3NhZ2VcbiAgICBpZiAoIW1zZ09iai50b2tlbiB8fCBlTUlzLmhhcyhtc2dPYmoudG9rZW4pKSByZXR1cm47IC8vIGFscmVhZHkgZW1pdHRlZFxuICAgIGlmIChtc2dPYmouZGF0YS50aW1lICYmIG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuOyAvLyB0b28gb2xkXG5cbiAgICBlTUlzLmFkZChtc2dPYmoudG9rZW4pO1xuICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY2xvc2UkMihjaGFubmVsU3RhdGUpIHtcbiAgcmVtb3ZlU3RvcmFnZUV2ZW50TGlzdGVuZXIoY2hhbm5lbFN0YXRlLmxpc3RlbmVyKTtcbn1cbmZ1bmN0aW9uIG9uTWVzc2FnZSQyKGNoYW5uZWxTdGF0ZSwgZm4sIHRpbWUpIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lID0gdGltZTtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbn1cbmZ1bmN0aW9uIGNhbkJlVXNlZCQyKCkge1xuICBjb25zdCBscyA9IGdldExvY2FsU3RvcmFnZSgpO1xuICBpZiAoIWxzKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qga2V5ID0gJ19fYnJvYWRjYXN0Y2hhbm5lbF9jaGVjayc7XG4gICAgbHMuc2V0SXRlbShrZXksICd3b3JrcycpO1xuICAgIGxzLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFNhZmFyaSAxMCBpbiBwcml2YXRlIG1vZGUgd2lsbCBub3QgYWxsb3cgd3JpdGUgYWNjZXNzIHRvIGxvY2FsXG4gICAgLy8gc3RvcmFnZSBhbmQgZmFpbCB3aXRoIGEgUXVvdGFFeGNlZWRlZEVycm9yLiBTZWVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1N0b3JhZ2VfQVBJI1ByaXZhdGVfQnJvd3NpbmdfSW5jb2duaXRvX21vZGVzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSQyKCkge1xuICBjb25zdCBkZWZhdWx0VGltZSA9IDEyMDtcbiAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBpZiAodXNlckFnZW50LmluY2x1ZGVzKCdzYWZhcmknKSAmJiAhdXNlckFnZW50LmluY2x1ZGVzKCdjaHJvbWUnKSkge1xuICAgIC8vIHNhZmFyaSBpcyBtdWNoIHNsb3dlciBzbyB0aGlzIHRpbWUgaXMgaGlnaGVyXG4gICAgcmV0dXJuIGRlZmF1bHRUaW1lICogMjtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFRpbWU7XG59XG52YXIgTG9jYWxzdG9yYWdlTWV0aG9kID0ge1xuICBnZXRMb2NhbFN0b3JhZ2UsXG4gIGNyZWF0ZTogY3JlYXRlJDIsXG4gIGNsb3NlOiBjbG9zZSQyLFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSQyLFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UkMixcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQkMixcbiAgdHlwZTogdHlwZSQyLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lJDIsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzJDIsXG4gIHN0b3JhZ2VLZXk6IHN0b3JhZ2VLZXkkMSxcbiAgYWRkU3RvcmFnZUV2ZW50TGlzdGVuZXIsXG4gIHJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyXG59O1xuXG4vKipcbiAqIEEgbG9jYWxTdG9yYWdlLW9ubHkgbWV0aG9kIHdoaWNoIHVzZXMgbG9jYWxzdG9yYWdlIGFuZCBpdHMgJ3N0b3JhZ2UnLWV2ZW50XG4gKiBUaGlzIGRvZXMgbm90IHdvcmsgaW5zaWRlIG9mIHdlYndvcmtlcnMgYmVjYXVzZSB0aGV5IGhhdmUgbm8gYWNjZXNzIHRvIGxvY2FzdG9yYWdlXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBpbXBsZW1lbnRlZCB0byBzdXBwb3J0IElFOSBvciB5b3VyIGdyYW5kbW90aGVycyB0b2FzdGVyLlxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1uYW1ldmFsdWUtc3RvcmFnZVxuICogQGxpbmsgaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1pbmRleGVkZGJcbiAqL1xuXG5jb25zdCBtaWNyb1NlY29uZHMkMSA9IG1pY3JvU2Vjb25kcyQ1O1xuY29uc3QgS0VZX1BSRUZJWCA9ICdwdWJrZXkuYnJvYWRjYXN0Q2hhbm5lbC0nO1xuY29uc3QgdHlwZSQxID0gJ3NlcnZlcic7XG5sZXQgU09DS0VUX0NPTk5fSU5TVEFOQ0UgPSBudWxsO1xuLy8gdXNlZCB0byBkZWNpZGUgdG8gcmVjb25uZWN0IHNvY2tldCBlLmcuIHdoZW4gc29ja2V0IGNvbm5lY3Rpb24gaXMgZGlzY29ubmVjdGVkIHVuZXhwZWN0ZWRseVxuY29uc3QgcnVubmluZ0NoYW5uZWxzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gc3RvcmFnZUtleShjaGFubmVsTmFtZSkge1xuICByZXR1cm4gS0VZX1BSRUZJWCArIGNoYW5uZWxOYW1lO1xufVxuXG4vKipcbiAqIHdyaXRlcyB0aGUgbmV3IG1lc3NhZ2UgdG8gdGhlIHN0b3JhZ2VcbiAqIGFuZCBmaXJlcyB0aGUgc3RvcmFnZS1ldmVudCBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XG4gKi9cbmZ1bmN0aW9uIHBvc3RNZXNzYWdlJDEoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgc2xlZXAoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHN0b3JhZ2VLZXkoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKTtcbiAgICAgIGNvbnN0IGNoYW5uZWxFbmNQcml2S2V5ID0ga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKGtleSwgJ3V0ZjgnKSk7XG4gICAgICBjb25zdCBlbmNEYXRhID0gYXdhaXQgZW5jcnlwdERhdGEoY2hhbm5lbEVuY1ByaXZLZXkudG9TdHJpbmcoJ2hleCcpLCB7XG4gICAgICAgIHRva2VuOiByYW5kb21Ub2tlbigpLFxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBkYXRhOiBtZXNzYWdlSnNvbixcbiAgICAgICAgdXVpZDogY2hhbm5lbFN0YXRlLnV1aWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgc2FtZU9yaWdpbkNoZWNrOiB0cnVlLFxuICAgICAgICBzYW1lSXBDaGVjazogdHJ1ZSxcbiAgICAgICAga2V5OiBnZXRQdWJsaWMoY2hhbm5lbEVuY1ByaXZLZXkpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgZGF0YTogZW5jRGF0YSxcbiAgICAgICAgc2lnbmF0dXJlOiAoYXdhaXQgc2lnbihjaGFubmVsRW5jUHJpdktleSwga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKGVuY0RhdGEsICd1dGY4JykpKSkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9O1xuICAgICAgaWYgKGNoYW5uZWxTdGF0ZS50aW1lb3V0KSBib2R5LnRpbWVvdXQgPSBjaGFubmVsU3RhdGUudGltZW91dDtcbiAgICAgIHJldHVybiBmZXRjaChjaGFubmVsU3RhdGUuc2VydmVyVXJsICsgJy9jaGFubmVsL3NldCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKHJlcykuY2F0Y2gocmVqKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTb2NrZXRJbnN0YW5jZShzZXJ2ZXJVcmwpIHtcbiAgaWYgKFNPQ0tFVF9DT05OX0lOU1RBTkNFKSB7XG4gICAgcmV0dXJuIFNPQ0tFVF9DT05OX0lOU1RBTkNFO1xuICB9XG4gIGNvbnN0IFNPQ0tFVF9DT05OID0gaW8oc2VydmVyVXJsLCB7XG4gICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnLCAncG9sbGluZyddLFxuICAgIC8vIHVzZSBXZWJTb2NrZXQgZmlyc3QsIGlmIGF2YWlsYWJsZVxuICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICByZWNvbm5lY3Rpb25EZWxheU1heDogMTAwMDAsXG4gICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IDEwXG4gIH0pO1xuICBTT0NLRVRfQ09OTi5vbignY29ubmVjdF9lcnJvcicsIGVyciA9PiB7XG4gICAgLy8gcmV2ZXJ0IHRvIGNsYXNzaWMgdXBncmFkZVxuICAgIFNPQ0tFVF9DT05OLmlvLm9wdHMudHJhbnNwb3J0cyA9IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgICBsb2cuZXJyb3IoJ2Nvbm5lY3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgU09DS0VUX0NPTk4ub24oJ2Nvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZW5naW5lXG4gICAgfSA9IFNPQ0tFVF9DT05OLmlvO1xuICAgIGxvZy5kZWJ1ZygnaW5pdGlhbGx5IGNvbm5lY3RlZCB0bycsIGVuZ2luZS50cmFuc3BvcnQubmFtZSk7IC8vIGluIG1vc3QgY2FzZXMsIHByaW50cyBcInBvbGxpbmdcIlxuICAgIGVuZ2luZS5vbmNlKCd1cGdyYWRlJywgKCkgPT4ge1xuICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyB1cGdyYWRlZCAoaS5lLiBmcm9tIEhUVFAgbG9uZy1wb2xsaW5nIHRvIFdlYlNvY2tldClcbiAgICAgIGxvZy5kZWJ1ZygndXBncmFkZWQnLCBlbmdpbmUudHJhbnNwb3J0Lm5hbWUpOyAvLyBpbiBtb3N0IGNhc2VzLCBwcmludHMgXCJ3ZWJzb2NrZXRcIlxuICAgIH0pO1xuICAgIGVuZ2luZS5vbmNlKCdjbG9zZScsIHJlYXNvbiA9PiB7XG4gICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIGlzIGNsb3NlZFxuICAgICAgbG9nLmRlYnVnKCdjb25uZWN0aW9uIGNsb3NlZCcsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0pO1xuICBTT0NLRVRfQ09OTi5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgIGxvZy5lcnJvcignc29ja2V0IGVycm9yZWQnLCBlcnIpO1xuICAgIFNPQ0tFVF9DT05OLmRpc2Nvbm5lY3QoKTtcbiAgfSk7XG4gIFNPQ0tFVF9DT05OX0lOU1RBTkNFID0gU09DS0VUX0NPTk47XG4gIHJldHVybiBTT0NLRVRfQ09OTjtcbn1cbmZ1bmN0aW9uIHNldHVwU29ja2V0Q29ubmVjdGlvbihzZXJ2ZXJVcmwsIGNoYW5uZWxTdGF0ZSwgZm4pIHtcbiAgY29uc3Qgc29ja2V0Q29ubiA9IGdldFNvY2tldEluc3RhbmNlKHNlcnZlclVybCk7XG4gIGNvbnN0IGtleSA9IHN0b3JhZ2VLZXkoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKTtcbiAgY29uc3QgY2hhbm5lbEVuY1ByaXZLZXkgPSBrZWNjYWsyNTYoQnVmZmVyLmZyb20oa2V5LCAndXRmOCcpKTtcbiAgY29uc3QgY2hhbm5lbFB1YktleSA9IGdldFB1YmxpYyhjaGFubmVsRW5jUHJpdktleSkudG9TdHJpbmcoJ2hleCcpO1xuICBpZiAoc29ja2V0Q29ubi5jb25uZWN0ZWQpIHtcbiAgICBzb2NrZXRDb25uLmVtaXQoJ2NoZWNrX2F1dGhfc3RhdHVzJywgY2hhbm5lbFB1YktleSwge1xuICAgICAgc2FtZU9yaWdpbkNoZWNrOiB0cnVlLFxuICAgICAgc2FtZUlwQ2hlY2s6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzb2NrZXRDb25uLm9uY2UoJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBsb2cuZGVidWcoJ2Nvbm5lY3RlZCB3aXRoIHNvY2tldCcpO1xuICAgICAgc29ja2V0Q29ubi5lbWl0KCdjaGVja19hdXRoX3N0YXR1cycsIGNoYW5uZWxQdWJLZXksIHtcbiAgICAgICAgc2FtZU9yaWdpbkNoZWNrOiB0cnVlLFxuICAgICAgICBzYW1lSXBDaGVjazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcmVjb25uZWN0ID0gKCkgPT4ge1xuICAgIHNvY2tldENvbm4ub25jZSgnY29ubmVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChydW5uaW5nQ2hhbm5lbHMuaGFzKGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSkpIHtcbiAgICAgICAgc29ja2V0Q29ubi5lbWl0KCdjaGVja19hdXRoX3N0YXR1cycsIGNoYW5uZWxQdWJLZXksIHtcbiAgICAgICAgICBzYW1lT3JpZ2luQ2hlY2s6IHRydWUsXG4gICAgICAgICAgc2FtZUlwQ2hlY2s6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHZpc2liaWxpdHlMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAvLyBpZiBjaGFubmVsIGlzIGNsb3NlZCwgdGhlbiByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgIGlmICghc29ja2V0Q29ubiB8fCAhcnVubmluZ0NoYW5uZWxzLmhhcyhjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUxpc3RlbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgbm90IGNvbm5lY3RlZCwgdGhlbiB3YWl0IGZvciBjb25uZWN0aW9uIGFuZCBwaW5nIHNlcnZlciBmb3IgbGF0ZXN0IG1zZy5cbiAgICBpZiAoIXNvY2tldENvbm4uY29ubmVjdGVkICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICByZWNvbm5lY3QoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxpc3RlbmVyID0gYXN5bmMgZXYgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNEYXRhID0gYXdhaXQgZGVjcnlwdERhdGEoY2hhbm5lbEVuY1ByaXZLZXkudG9TdHJpbmcoJ2hleCcpLCBldik7XG4gICAgICBsb2cuaW5mbyhkZWNEYXRhKTtcbiAgICAgIGZuKGRlY0RhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgc29ja2V0Q29ubi5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICBsb2cuZGVidWcoJ3NvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICBpZiAocnVubmluZ0NoYW5uZWxzLmhhcyhjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpKSB7XG4gICAgICBsb2cuZXJyb3IoJ3NvY2tldCBkaXNjb25uZWN0ZWQgdW5leHBlY3RlZGx5LCByZWNvbm5lY3Rpbmcgc29ja2V0Jyk7XG4gICAgICByZWNvbm5lY3QoKTtcbiAgICB9XG4gIH0pO1xuICBzb2NrZXRDb25uLm9uKGAke2NoYW5uZWxQdWJLZXl9X3N1Y2Nlc3NgLCBsaXN0ZW5lcik7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUxpc3RlbmVyKTtcbiAgcmV0dXJuIHNvY2tldENvbm47XG59XG5mdW5jdGlvbiBjcmVhdGUkMShjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIGNvbnN0IHV1aWQgPSByYW5kb21Ub2tlbigpO1xuXG4gIC8qKlxuICAgKiBlTUlzXG4gICAqIGNvbnRhaW5zIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYmVlbiBlbWl0dGVkIGJlZm9yZVxuICAgKiBAdHlwZSB7T2JsaXZpb3VzU2V0fVxuICAgKi9cbiAgY29uc3QgZU1JcyA9IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5zZXJ2ZXIucmVtb3ZlVGltZW91dCk7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGNoYW5uZWxOYW1lLFxuICAgIHV1aWQsXG4gICAgZU1JcyxcbiAgICAvLyBlbWl0dGVkTWVzc2FnZXNJZHNcbiAgICBzZXJ2ZXJVcmw6IG9wdGlvbnMuc2VydmVyLnVybCxcbiAgICB0aW1lOiBtaWNyb1NlY29uZHMkNSgpXG4gIH07XG4gIGlmIChvcHRpb25zLnNlcnZlci50aW1lb3V0KSBzdGF0ZS50aW1lb3V0ID0gb3B0aW9ucy5zZXJ2ZXIudGltZW91dDtcbiAgc2V0dXBTb2NrZXRDb25uZWN0aW9uKG9wdGlvbnMuc2VydmVyLnVybCwgc3RhdGUsIG1zZ09iaiA9PiB7XG4gICAgaWYgKCFzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSByZXR1cm47IC8vIG5vIGxpc3RlbmVyXG4gICAgaWYgKG1zZ09iai51dWlkID09PSBzdGF0ZS51dWlkKSByZXR1cm47IC8vIG93biBtZXNzYWdlXG4gICAgaWYgKCFtc2dPYmoudG9rZW4gfHwgc3RhdGUuZU1Jcy5oYXMobXNnT2JqLnRva2VuKSkgcmV0dXJuOyAvLyBhbHJlYWR5IGVtaXR0ZWRcbiAgICAvLyBpZiAobXNnT2JqLmRhdGEudGltZSAmJiBtc2dPYmouZGF0YS50aW1lIDwgc3RhdGUubWVzc2FnZXNDYWxsYmFja1RpbWUpIHJldHVybjsgLy8gdG9vIG9sZFxuXG4gICAgc3RhdGUuZU1Jcy5hZGQobXNnT2JqLnRva2VuKTtcbiAgICBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKG1zZ09iai5kYXRhKTtcbiAgfSk7XG4gIHJ1bm5pbmdDaGFubmVscy5hZGQoY2hhbm5lbE5hbWUpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjbG9zZSQxKGNoYW5uZWxTdGF0ZSkge1xuICBydW5uaW5nQ2hhbm5lbHMuZGVsZXRlKGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSk7XG4gIC8vIGdpdmUgMiBzZWMgZm9yIGFsbCBtc2dzIHdoaWNoIGFyZSBpbiB0cmFuc2l0IHRvIGJlIGNvbnN1bWVkXG4gIC8vIGJ5IHJlY2VpdmVyLlxuICAvLyB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gIC8vICAgICByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsU3RhdGUpO1xuICAvLyAgICAgU09DS0VUX0NPTk5fSU5TVEFOQ0UgPSBudWxsO1xuICAvLyB9LCAxMDAwKTtcbn1cbmZ1bmN0aW9uIG9uTWVzc2FnZSQxKGNoYW5uZWxTdGF0ZSwgZm4sIHRpbWUpIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lID0gdGltZTtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbn1cbmZ1bmN0aW9uIGNhbkJlVXNlZCQxKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUkMSgpIHtcbiAgY29uc3QgZGVmYXVsdFRpbWUgPSA1MDA7XG4gIC8vIFRPRE86IE1heWJlIGluY3JlYXNlIGl0IGJhc2VkIG9uIG9wZXJhdGlvblxuICByZXR1cm4gZGVmYXVsdFRpbWU7XG59XG52YXIgU2VydmVyTWV0aG9kID0ge1xuICBjcmVhdGU6IGNyZWF0ZSQxLFxuICBjbG9zZTogY2xvc2UkMSxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UkMSxcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlJDEsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkJDEsXG4gIHR5cGU6IHR5cGUkMSxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSQxLFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kcyQxXG59O1xuXG5jb25zdCBtaWNyb1NlY29uZHMgPSBtaWNyb1NlY29uZHMkNTtcbmNvbnN0IHR5cGUgPSAnc2ltdWxhdGUnO1xuY29uc3QgU0lNVUxBVEVfQ0hBTk5FTFMgPSBuZXcgU2V0KCk7XG5jb25zdCBTSU1VTEFURV9ERUxBWV9USU1FID0gNTtcbmZ1bmN0aW9uIGNyZWF0ZShjaGFubmVsTmFtZSkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICB0aW1lOiBtaWNyb1NlY29uZHMkNSgpLFxuICAgIG5hbWU6IGNoYW5uZWxOYW1lLFxuICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGxcbiAgfTtcbiAgU0lNVUxBVEVfQ0hBTk5FTFMuYWRkKHN0YXRlKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY2xvc2UoY2hhbm5lbFN0YXRlKSB7XG4gIFNJTVVMQVRFX0NIQU5ORUxTLmRlbGV0ZShjaGFubmVsU3RhdGUpO1xufVxuZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnN0IGNoYW5uZWxBcnJheSA9IEFycmF5LmZyb20oU0lNVUxBVEVfQ0hBTk5FTFMpO1xuICAgIGNoYW5uZWxBcnJheS5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgaWYgKGNoYW5uZWwubmFtZSA9PT0gY2hhbm5lbFN0YXRlLm5hbWUgJiZcbiAgICAgIC8vIGhhcyBzYW1lIG5hbWVcbiAgICAgIGNoYW5uZWwgIT09IGNoYW5uZWxTdGF0ZSAmJlxuICAgICAgLy8gbm90IG93biBjaGFubmVsXG4gICAgICAhIWNoYW5uZWwubWVzc2FnZXNDYWxsYmFjayAmJlxuICAgICAgLy8gaGFzIHN1YnNjcmliZXJzXG4gICAgICBjaGFubmVsLnRpbWUgPCBtZXNzYWdlSnNvbi50aW1lIC8vIGNoYW5uZWwgbm90IGNyZWF0ZWQgYWZ0ZXIgcG9zdE1lc3NhZ2UoKSBjYWxsXG4gICAgICApIHtcbiAgICAgICAgY2hhbm5lbC5tZXNzYWdlc0NhbGxiYWNrKG1lc3NhZ2VKc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXMoKTtcbiAgfSwgU0lNVUxBVEVfREVMQVlfVElNRSkpO1xufVxuZnVuY3Rpb24gb25NZXNzYWdlKGNoYW5uZWxTdGF0ZSwgZm4pIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbn1cbmZ1bmN0aW9uIGNhbkJlVXNlZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKCkge1xuICByZXR1cm4gU0lNVUxBVEVfREVMQVlfVElNRTtcbn1cbnZhciBTaW11bGF0ZU1ldGhvZCA9IHtcbiAgY3JlYXRlLFxuICBjbG9zZSxcbiAgb25NZXNzYWdlLFxuICBwb3N0TWVzc2FnZSxcbiAgY2FuQmVVc2VkLFxuICB0eXBlLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lLFxuICBtaWNyb1NlY29uZHNcbn07XG5cbi8vIG9yZGVyIGlzIGltcG9ydGFudFxuY29uc3QgTUVUSE9EUyA9IFtOYXRpdmVNZXRob2QsXG4vLyBmYXN0ZXN0XG5JbmRleGVEYk1ldGhvZCwgTG9jYWxzdG9yYWdlTWV0aG9kLCBTZXJ2ZXJNZXRob2RdO1xuZnVuY3Rpb24gY2hvb3NlTWV0aG9kKG9wdGlvbnMpIHtcbiAgbGV0IGNob29zZU1ldGhvZHMgPSBbXS5jb25jYXQob3B0aW9ucy5tZXRob2RzLCBNRVRIT0RTKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgLy8gZGlyZWN0bHkgY2hvc2VuXG4gIGlmIChvcHRpb25zLnR5cGUpIHtcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnc2ltdWxhdGUnKSB7XG4gICAgICAvLyBvbmx5IHVzZSBzaW11bGF0ZS1tZXRob2QgaWYgZGlyZWN0bHkgY2hvc2VuXG4gICAgICByZXR1cm4gU2ltdWxhdGVNZXRob2Q7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IGNob29zZU1ldGhvZHMuZmluZChtID0+IG0udHlwZSA9PT0gb3B0aW9ucy50eXBlKTtcbiAgICBpZiAoIXJldCkgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QtdHlwZSAnICsgb3B0aW9ucy50eXBlICsgJyBub3QgZm91bmQnKTtlbHNlIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogaWYgbm8gd2Vid29ya2VyIHN1cHBvcnQgaXMgbmVlZGVkLFxuICAgKiByZW1vdmUgaWRiIGZyb20gdGhlIGxpc3Qgc28gdGhhdCBsb2NhbHN0b3JhZ2UgaXMgYmVlbiBjaG9zZW5cbiAgICovXG4gIGlmICghb3B0aW9ucy53ZWJXb3JrZXJTdXBwb3J0KSB7XG4gICAgY2hvb3NlTWV0aG9kcyA9IGNob29zZU1ldGhvZHMuZmlsdGVyKG0gPT4gbS50eXBlICE9PSAnaWRiJyk7XG4gIH1cbiAgY29uc3QgdXNlTWV0aG9kID0gY2hvb3NlTWV0aG9kcy5maW5kKG1ldGhvZCA9PiBtZXRob2QuY2FuQmVVc2VkKG9wdGlvbnMpKTtcbiAgaWYgKCF1c2VNZXRob2QpIHRocm93IG5ldyBFcnJvcihgTm8gdXNlYWJsZSBtZXRob2QgZm91bmQgaW4gJHtKU09OLnN0cmluZ2lmeShNRVRIT0RTLm1hcChtID0+IG0udHlwZSkpfWApO2Vsc2UgcmV0dXJuIHVzZU1ldGhvZDtcbn1cblxuLyoqXG4gKiBDb250YWlucyBhbGwgb3BlbiBjaGFubmVscyxcbiAqIHVzZWQgaW4gdGVzdHMgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgaXMgY2xvc2VkLlxuICovXG5jb25zdCBPUEVOX0JST0FEQ0FTVF9DSEFOTkVMUyA9IG5ldyBTZXQoKTtcbmxldCBsYXN0SWQgPSAwO1xuY29uc3QgQnJvYWRjYXN0Q2hhbm5lbCQxID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgLy8gaWRlbnRpZmllciBvZiB0aGUgY2hhbm5lbCB0byBkZWJ1ZyBzdHVmZlxuICB0aGlzLmlkID0gbGFzdElkKys7XG4gIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTLmFkZCh0aGlzKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgaWYgKEVORk9SQ0VEX09QVElPTlMpIHtcbiAgICBvcHRpb25zID0gRU5GT1JDRURfT1BUSU9OUztcbiAgfVxuICB0aGlzLm9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgdGhpcy5tZXRob2QgPSBjaG9vc2VNZXRob2QodGhpcy5vcHRpb25zKTtcblxuICAvLyBpc0xpc3RlbmluZ1xuICB0aGlzLl9pTCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBfb25NZXNzYWdlTGlzdGVuZXJcbiAgICogc2V0dGluZyBvbm1lc3NhZ2UgdHdpY2UsXG4gICAqIHdpbGwgb3ZlcndyaXRlIHRoZSBmaXJzdCBsaXN0ZW5lclxuICAgKi9cbiAgdGhpcy5fb25NTCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIF9hZGRFdmVudExpc3RlbmVyc1xuICAgKi9cbiAgdGhpcy5fYWRkRUwgPSB7XG4gICAgbWVzc2FnZTogW10sXG4gICAgaW50ZXJuYWw6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc2VuZCBtZXNzYWdlIHByb21pc2VzXG4gICAqIHdoZXJlIHRoZSBzZW5kaW5nIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIEB0eXBlIHtTZXQ8UHJvbWlzZT59XG4gICAqL1xuICB0aGlzLl91TVAgPSBuZXcgU2V0KCk7XG5cbiAgLyoqXG4gICAqIF9iZWZvcmVDbG9zZVxuICAgKiBhcnJheSBvZiBwcm9taXNlcyB0aGF0IHdpbGwgYmUgYXdhaXRlZFxuICAgKiBiZWZvcmUgdGhlIGNoYW5uZWwgaXMgY2xvc2VkXG4gICAqL1xuICB0aGlzLl9iZWZDID0gW107XG5cbiAgLyoqXG4gICAqIF9wcmVwYXJlUHJvbWlzZVxuICAgKi9cbiAgdGhpcy5fcHJlcFAgPSBudWxsO1xuICBfcHJlcGFyZUNoYW5uZWwodGhpcyk7XG59O1xuXG4vLyBTVEFUSUNTXG5cbi8qKlxuICogdXNlZCB0byBpZGVudGlmeSBpZiBzb21lb25lIG92ZXJ3cml0ZXNcbiAqIHdpbmRvdy5Ccm9hZGNhc3RDaGFubmVsIHdpdGggdGhpc1xuICogU2VlIG1ldGhvZHMvbmF0aXZlLmpzXG4gKi9cbkJyb2FkY2FzdENoYW5uZWwkMS5fcHVia2V5ID0gdHJ1ZTtcblxuLyoqXG4gKiBpZiBzZXQsIHRoaXMgbWV0aG9kIGlzIGVuZm9yY2VkLFxuICogbm8gbWF0aGVyIHdoYXQgdGhlIG9wdGlvbnMgYXJlXG4gKi9cbmxldCBFTkZPUkNFRF9PUFRJT05TO1xuZnVuY3Rpb24gZW5mb3JjZU9wdGlvbnMob3B0aW9ucykge1xuICBFTkZPUkNFRF9PUFRJT05TID0gb3B0aW9ucztcbn1cblxuLy8gUFJPVE9UWVBFXG5Ccm9hZGNhc3RDaGFubmVsJDEucHJvdG90eXBlID0ge1xuICBwb3N0TWVzc2FnZShtc2cpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSgpOiAnICsgJ0Nhbm5vdCBwb3N0IG1lc3NhZ2UgYWZ0ZXIgY2hhbm5lbCBoYXMgY2xvc2VkICcgK1xuICAgICAgLyoqXG4gICAgICAgKiBJbiB0aGUgcGFzdCB3aGVuIHRoaXMgZXJyb3IgYXBwZWFyZWQsIGl0IHdhcyByZWFseSBoYXJkIHRvIGRlYnVnLlxuICAgICAgICogU28gbm93IHdlIGxvZyB0aGUgbXNnIHRvZ2V0aGVyIHdpdGggdGhlIGVycm9yIHNvIGl0IGF0IGxlYXN0XG4gICAgICAgKiBnaXZlcyBzb21lIGNsdWUgYWJvdXQgd2hlcmUgaW4geW91ciBhcHBsaWNhdGlvbiB0aGlzIGhhcHBlbnMuXG4gICAgICAgKi9cbiAgICAgIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgIH1cbiAgICByZXR1cm4gX3Bvc3QodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICB9LFxuICBwb3N0SW50ZXJuYWwobXNnKSB7XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdpbnRlcm5hbCcsIG1zZyk7XG4gIH0sXG4gIHNldCBvbm1lc3NhZ2UoZm4pIHtcbiAgICBjb25zdCB0aW1lID0gdGhpcy5tZXRob2QubWljcm9TZWNvbmRzKCk7XG4gICAgY29uc3QgbGlzdGVuT2JqID0ge1xuICAgICAgdGltZSxcbiAgICAgIGZuXG4gICAgfTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgJ21lc3NhZ2UnLCB0aGlzLl9vbk1MKTtcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9vbk1MID0gbGlzdGVuT2JqO1xuICAgICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsICdtZXNzYWdlJywgbGlzdGVuT2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25NTCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIGNvbnN0IGxpc3Rlbk9iaiA9IHtcbiAgICAgIHRpbWUsXG4gICAgICBmblxuICAgIH07XG4gICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsIHR5cGUsIGxpc3Rlbk9iaik7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLl9hZGRFTFt0eXBlXS5maW5kKG9iaiA9PiBvYmouZm4gPT09IGZuKTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgdHlwZSwgb2JqKTtcbiAgfSxcbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTLmRlbGV0ZSh0aGlzKTtcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgY29uc3QgYXdhaXRQcmVwYXJlID0gdGhpcy5fcHJlcFAgPyB0aGlzLl9wcmVwUCA6IFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgICB0aGlzLl9vbk1MID0gbnVsbDtcbiAgICB0aGlzLl9hZGRFTC5tZXNzYWdlID0gW107XG4gICAgcmV0dXJuIGF3YWl0UHJlcGFyZVxuICAgIC8vIHdhaXQgdW50aWwgYWxsIGN1cnJlbnQgc2VuZGluZyBhcmUgcHJvY2Vzc2VkXG4gICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbSh0aGlzLl91TVApKSlcbiAgICAvLyBydW4gYmVmb3JlLWNsb3NlIGhvb2tzXG4gICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5hbGwodGhpcy5fYmVmQy5tYXAoZm4gPT4gZm4oKSkpKVxuICAgIC8vIGNsb3NlIHRoZSBjaGFubmVsXG4gICAgLnRoZW4oKCkgPT4gdGhpcy5tZXRob2QuY2xvc2UodGhpcy5fc3RhdGUpKTtcbiAgfSxcbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kLnR5cGU7XG4gIH0sXG4gIGdldCBpc0Nsb3NlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZWQ7XG4gIH1cbn07XG5cbi8qKlxuICogUG9zdCBhIG1lc3NhZ2Ugb3ZlciB0aGUgY2hhbm5lbFxuICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZWQgd2hlbiB0aGUgbWVzc2FnZSBzZW5kaW5nIGlzIGRvbmVcbiAqL1xuZnVuY3Rpb24gX3Bvc3QoYnJvYWRjYXN0Q2hhbm5lbCwgdHlwZSwgbXNnKSB7XG4gIGNvbnN0IHRpbWUgPSBicm9hZGNhc3RDaGFubmVsLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgY29uc3QgbXNnT2JqID0ge1xuICAgIHRpbWUsXG4gICAgdHlwZSxcbiAgICBkYXRhOiBtc2dcbiAgfTtcbiAgY29uc3QgYXdhaXRQcmVwYXJlID0gYnJvYWRjYXN0Q2hhbm5lbC5fcHJlcFAgPyBicm9hZGNhc3RDaGFubmVsLl9wcmVwUCA6IFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgcmV0dXJuIGF3YWl0UHJlcGFyZS50aGVuKCgpID0+IHtcbiAgICBjb25zdCBzZW5kUHJvbWlzZSA9IGJyb2FkY2FzdENoYW5uZWwubWV0aG9kLnBvc3RNZXNzYWdlKGJyb2FkY2FzdENoYW5uZWwuX3N0YXRlLCBtc2dPYmopO1xuXG4gICAgLy8gYWRkL3JlbW92ZSB0byB1bnNlbmQgbWVzc2FnZXMgbGlzdFxuICAgIGJyb2FkY2FzdENoYW5uZWwuX3VNUC5hZGQoc2VuZFByb21pc2UpO1xuICAgIHNlbmRQcm9taXNlLmNhdGNoKCkudGhlbigoKSA9PiBicm9hZGNhc3RDaGFubmVsLl91TVAuZGVsZXRlKHNlbmRQcm9taXNlKSk7XG4gICAgcmV0dXJuIHNlbmRQcm9taXNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9wcmVwYXJlQ2hhbm5lbChjaGFubmVsKSB7XG4gIGNvbnN0IG1heWJlUHJvbWlzZSA9IGNoYW5uZWwubWV0aG9kLmNyZWF0ZShjaGFubmVsLm5hbWUsIGNoYW5uZWwub3B0aW9ucyk7XG4gIGlmIChpc1Byb21pc2UobWF5YmVQcm9taXNlKSkge1xuICAgIGNoYW5uZWwuX3ByZXBQID0gbWF5YmVQcm9taXNlO1xuICAgIG1heWJlUHJvbWlzZS50aGVuKHMgPT4ge1xuICAgICAgLy8gdXNlZCBpbiB0ZXN0cyB0byBzaW11bGF0ZSBzbG93IHJ1bnRpbWVcbiAgICAgIC8qaWYgKGNoYW5uZWwub3B0aW9ucy5wcmVwYXJlRGVsYXkpIHtcbiAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCB0aGlzLm9wdGlvbnMucHJlcGFyZURlbGF5KSk7XG4gICAgICB9Ki9cbiAgICAgIGNoYW5uZWwuX3N0YXRlID0gcztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFubmVsLl9zdGF0ZSA9IG1heWJlUHJvbWlzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5fYWRkRUwubWVzc2FnZS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNoYW5uZWwuX2FkZEVMLmludGVybmFsLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfYWRkTGlzdGVuZXJPYmplY3QoY2hhbm5lbCwgdHlwZSwgb2JqKSB7XG4gIGNoYW5uZWwuX2FkZEVMW3R5cGVdLnB1c2gob2JqKTtcbiAgX3N0YXJ0TGlzdGVuaW5nKGNoYW5uZWwpO1xufVxuZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyT2JqZWN0KGNoYW5uZWwsIHR5cGUsIG9iaikge1xuICBjaGFubmVsLl9hZGRFTFt0eXBlXSA9IGNoYW5uZWwuX2FkZEVMW3R5cGVdLmZpbHRlcihvID0+IG8gIT09IG9iaik7XG4gIF9zdG9wTGlzdGVuaW5nKGNoYW5uZWwpO1xufVxuZnVuY3Rpb24gX3N0YXJ0TGlzdGVuaW5nKGNoYW5uZWwpIHtcbiAgaWYgKCFjaGFubmVsLl9pTCAmJiBfaGFzTWVzc2FnZUxpc3RlbmVycyhjaGFubmVsKSkge1xuICAgIC8vIHNvbWVvbmUgaXMgbGlzdGVuaW5nLCBzdGFydCBzdWJzY3JpYmluZ1xuXG4gICAgY29uc3QgbGlzdGVuZXJGbiA9IG1zZ09iaiA9PiB7XG4gICAgICBjaGFubmVsLl9hZGRFTFttc2dPYmoudHlwZV0uZm9yRWFjaChsaXN0ZW5lck9iamVjdCA9PiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXR0aW5nIHRoZSBjdXJyZW50IHRpbWUgaW4gSmF2YVNjcmlwdCBoYXMgbm8gZ29vZCBwcmVjaXNpb24uXG4gICAgICAgICAqIFNvIGluc3RlYWQgb2Ygb25seSBsaXN0ZW5pbmcgdG8gZXZlbnRzIHRoYXQgaGFwcGVuZCAnYWZ0ZXInIHRoZSBsaXN0ZW5lclxuICAgICAgICAgKiB3YXMgYWRkZWQsIHdlIGFsc28gbGlzdGVuIHRvIGV2ZW50cyB0aGF0IGhhcHBlbmRlZCAxMDBtcyBiZWZvcmUgaXQuXG4gICAgICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gYW5vdGhlciBwcm9jZXNzLCBsaWtlIGEgV2ViV29ya2VyLCBzZW5kcyBldmVudHNcbiAgICAgICAgICogd2UgZG8gbm90IG1pc3MgdGhlbSBvdXQgYmVjYXVzZSB0aGVpciB0aW1lc3RhbXAgaXMgYSBiaXQgb2ZmIGNvbXBhcmVkIHRvIHRoZSBtYWluIHByb2Nlc3MuXG4gICAgICAgICAqIE5vdCBkb2luZyB0aGlzIHdvdWxkIG1ha2UgbWVzc2FnZXMgbWlzc2luZyB3aGVuIHdlIHNlbmQgZGF0YSBkaXJlY3RseSBhZnRlciBzdWJzY3JpYmluZyBhbmQgYXdhaXRpbmcgYSByZXNwb25zZS5cbiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9qb2hucmVzaWcuY29tL2Jsb2cvYWNjdXJhY3ktb2YtamF2YXNjcmlwdC10aW1lL1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gY29uc3QgaHVuZHJlZE1zSW5NaWNybyA9IDEwMCAqIDEwMDA7XG4gICAgICAgIC8vIGNvbnN0IG1pbk1lc3NhZ2VUaW1lID0gbGlzdGVuZXJPYmplY3QudGltZSAtIGh1bmRyZWRNc0luTWljcm87XG5cbiAgICAgICAgaWYgKG1zZ09iai50aW1lID49IGxpc3RlbmVyT2JqZWN0LnRpbWUpIHtcbiAgICAgICAgICBsaXN0ZW5lck9iamVjdC5mbihtc2dPYmouZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5tZXRob2QudHlwZSA9PT0gJ3NlcnZlcicpIHtcbiAgICAgICAgICAvLyBzZXJ2ZXIgbXNnIG1pZ2h0IGxhZyBiYXNlZCBvbiBjb25uZWN0aW9uLlxuICAgICAgICAgIGxpc3RlbmVyT2JqZWN0LmZuKG1zZ09iai5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lID0gY2hhbm5lbC5tZXRob2QubWljcm9TZWNvbmRzKCk7XG4gICAgaWYgKGNoYW5uZWwuX3ByZXBQKSB7XG4gICAgICBjaGFubmVsLl9wcmVwUC50aGVuKCgpID0+IHtcbiAgICAgICAgY2hhbm5lbC5faUwgPSB0cnVlO1xuICAgICAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIGxpc3RlbmVyRm4sIHRpbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWwuX2lMID0gdHJ1ZTtcbiAgICAgIGNoYW5uZWwubWV0aG9kLm9uTWVzc2FnZShjaGFubmVsLl9zdGF0ZSwgbGlzdGVuZXJGbiwgdGltZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfc3RvcExpc3RlbmluZyhjaGFubmVsKSB7XG4gIGlmIChjaGFubmVsLl9pTCAmJiAhX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcbiAgICAvLyBub29uZSBpcyBsaXN0ZW5pbmcsIHN0b3Agc3Vic2NyaWJpbmdcbiAgICBjaGFubmVsLl9pTCA9IGZhbHNlO1xuICAgIGNvbnN0IHRpbWUgPSBjaGFubmVsLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIG51bGwsIHRpbWUpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJyb2FkY2FzdENoYW5uZWwkMSBhcyBCcm9hZGNhc3RDaGFubmVsLCBJbmRleGVEYk1ldGhvZCBhcyBJbmRleGVkRGJNZXRob2QsIExvY2Fsc3RvcmFnZU1ldGhvZCBhcyBMb2NhbFN0b3JhZ2VNZXRob2QsIE5hdGl2ZU1ldGhvZCwgT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFMsIFNlcnZlck1ldGhvZCwgY2hvb3NlTWV0aG9kLCBlbmZvcmNlT3B0aW9ucyB9O1xuIl0sIm5hbWVzIjpbImxvZ2xldmVsIiwiT2JsaXZpb3VzU2V0IiwiaW8iLCJnZXRQdWJsaWMiLCJzaWduIiwia2VjY2FrMjU2IiwiZW5jcnlwdERhdGEiLCJkZWNyeXB0RGF0YSIsImlzUHJvbWlzZSIsIm9iaiIsInRoZW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsIlBST01JU0VfUkVTT0xWRURfVk9JRCIsInNsZWVwIiwidGltZSIsInJlc29sdmVXaXRoIiwicmVzIiwic2V0VGltZW91dCIsInJhbmRvbUludCIsIm1pbiIsIm1heCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInJhbmRvbVRva2VuIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJsYXN0TXMiLCJtaWNyb1NlY29uZHMkNSIsInJldCIsIkRhdGUiLCJub3ciLCJsb2ciLCJnZXRMb2dnZXIiLCJzZXRMZXZlbCIsIm1pY3JvU2Vjb25kcyQ0IiwidHlwZSQ0IiwiY3JlYXRlJDQiLCJjaGFubmVsTmFtZSIsInN0YXRlIiwibWVzc2FnZXNDYWxsYmFjayIsImJjIiwiQnJvYWRjYXN0Q2hhbm5lbCIsInN1YkZucyIsIm9ubWVzc2FnZSIsIm1zZyIsImRhdGEiLCJjbG9zZSQ0IiwiY2hhbm5lbFN0YXRlIiwiY2xvc2UiLCJwb3N0TWVzc2FnZSQ0IiwibWVzc2FnZUpzb24iLCJwb3N0TWVzc2FnZSIsImVyciIsInJlamVjdCIsIm9uTWVzc2FnZSQ0IiwiZm4iLCJjYW5CZVVzZWQkNCIsIl9wdWJrZXkiLCJFcnJvciIsImF2ZXJhZ2VSZXNwb25zZVRpbWUkNCIsIk5hdGl2ZU1ldGhvZCIsImNyZWF0ZSIsIm9uTWVzc2FnZSIsImNhbkJlVXNlZCIsInR5cGUiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwibWljcm9TZWNvbmRzIiwiZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMiLCJvcmlnaW5hbE9wdGlvbnMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJvcHRpb25zIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Iiwid2ViV29ya2VyU3VwcG9ydCIsImlkYiIsInR0bCIsImZhbGxiYWNrSW50ZXJ2YWwiLCJvbmNsb3NlIiwibG9jYWxzdG9yYWdlIiwicmVtb3ZlVGltZW91dCIsInNlcnZlciIsInVybCIsIm1ldGhvZHMiLCJtaWNyb1NlY29uZHMkMyIsIkRCX1BSRUZJWCIsIk9CSkVDVF9TVE9SRV9JRCIsIlRSQU5TQUNUSU9OX1NFVFRJTkdTIiwiZHVyYWJpbGl0eSIsInR5cGUkMyIsImdldElkYiIsImluZGV4ZWREQiIsIndpbmRvdyIsIm1vekluZGV4ZWREQiIsIndlYmtpdEluZGV4ZWREQiIsIm1zSW5kZXhlZERCIiwiY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24iLCJ0eCIsImNvbW1pdCIsImNyZWF0ZURhdGFiYXNlIiwiSW5kZXhlZERCIiwiZGJOYW1lIiwib3BlblJlcXVlc3QiLCJvcGVuIiwib251cGdyYWRlbmVlZGVkIiwiZXYiLCJkYiIsInRhcmdldCIsInJlc3VsdCIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsImF1dG9JbmNyZW1lbnQiLCJkYlByb21pc2UiLCJyZWoiLCJvbmVycm9yIiwib25zdWNjZXNzIiwid3JpdGVNZXNzYWdlIiwicmVhZGVyVXVpZCIsIndyaXRlT2JqZWN0IiwidXVpZCIsInRyYW5zYWN0aW9uIiwib25jb21wbGV0ZSIsIm9iamVjdFN0b3JlIiwiYWRkIiwiZ2V0QWxsTWVzc2FnZXMiLCJvcGVuQ3Vyc29yIiwiY3Vyc29yIiwicHVzaCIsInZhbHVlIiwiY29udGludWUiLCJnZXRNZXNzYWdlc0hpZ2hlclRoYW4iLCJsYXN0Q3Vyc29ySWQiLCJrZXlSYW5nZVZhbHVlIiwiSURCS2V5UmFuZ2UiLCJib3VuZCIsIkluZmluaXR5IiwiZ2V0QWxsIiwiZ2V0QWxsUmVxdWVzdCIsImUiLCJvcGVuQ3Vyc29yUmVxdWVzdCIsImlkIiwicmVtb3ZlTWVzc2FnZXNCeUlkIiwiaWRzIiwiYWxsIiwibWFwIiwiZGVsZXRlUmVxdWVzdCIsImRlbGV0ZSIsImdldE9sZE1lc3NhZ2VzIiwib2xkZXJUaGVuIiwibXNnT2JrIiwiY2xlYW5PbGRNZXNzYWdlcyIsInRvb09sZCIsImNyZWF0ZSQzIiwiY2xvc2VkIiwiZU1JcyIsIndyaXRlQmxvY2tQcm9taXNlIiwicmVhZFF1ZXVlUHJvbWlzZXMiLCJfcmVhZExvb3AiLCJyZWFkTmV3TWVzc2FnZXMiLCJfZmlsdGVyTWVzc2FnZSIsIm1zZ09iaiIsImhhcyIsIm1lc3NhZ2VzQ2FsbGJhY2tUaW1lIiwibmV3ZXJNZXNzYWdlcyIsInVzZU1lc3NhZ2VzIiwiZmlsdGVyIiwic29ydCIsIm1zZ09iakEiLCJtc2dPYmpCIiwiZm9yRWFjaCIsImNsb3NlJDMiLCJwb3N0TWVzc2FnZSQzIiwib25NZXNzYWdlJDMiLCJjYW5CZVVzZWQkMyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUkMyIsIkluZGV4ZURiTWV0aG9kIiwibWljcm9TZWNvbmRzJDIiLCJLRVlfUFJFRklYJDEiLCJ0eXBlJDIiLCJnZXRMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJzdG9yYWdlS2V5JDEiLCJwb3N0TWVzc2FnZSQyIiwia2V5Iiwid3JpdGVPYmoiLCJ0b2tlbiIsInNldEl0ZW0iLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwibmV3VmFsdWUiLCJkaXNwYXRjaEV2ZW50IiwiYWRkU3RvcmFnZUV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGUkMiIsImNhbkJlVXNlZCQyIiwiY2xvc2UkMiIsIm9uTWVzc2FnZSQyIiwibHMiLCJyZW1vdmVJdGVtIiwiYXZlcmFnZVJlc3BvbnNlVGltZSQyIiwiZGVmYXVsdFRpbWUiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiTG9jYWxzdG9yYWdlTWV0aG9kIiwic3RvcmFnZUtleSIsIm1pY3JvU2Vjb25kcyQxIiwiS0VZX1BSRUZJWCIsInR5cGUkMSIsIlNPQ0tFVF9DT05OX0lOU1RBTkNFIiwicnVubmluZ0NoYW5uZWxzIiwiU2V0IiwicG9zdE1lc3NhZ2UkMSIsImNoYW5uZWxFbmNQcml2S2V5IiwiQnVmZmVyIiwiZnJvbSIsImVuY0RhdGEiLCJib2R5Iiwic2FtZU9yaWdpbkNoZWNrIiwic2FtZUlwQ2hlY2siLCJzaWduYXR1cmUiLCJ0aW1lb3V0IiwiZmV0Y2giLCJzZXJ2ZXJVcmwiLCJtZXRob2QiLCJoZWFkZXJzIiwiY2F0Y2giLCJnZXRTb2NrZXRJbnN0YW5jZSIsIlNPQ0tFVF9DT05OIiwidHJhbnNwb3J0cyIsIndpdGhDcmVkZW50aWFscyIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJvbiIsIm9wdHMiLCJlcnJvciIsImVuZ2luZSIsImRlYnVnIiwidHJhbnNwb3J0IiwibmFtZSIsIm9uY2UiLCJyZWFzb24iLCJkaXNjb25uZWN0Iiwic2V0dXBTb2NrZXRDb25uZWN0aW9uIiwic29ja2V0Q29ubiIsImNoYW5uZWxQdWJLZXkiLCJjb25uZWN0ZWQiLCJlbWl0IiwicmVjb25uZWN0IiwidmlzaWJpbGl0eUxpc3RlbmVyIiwidmlzaWJpbGl0eVN0YXRlIiwiZGVjRGF0YSIsImluZm8iLCJjcmVhdGUkMSIsImNsb3NlJDEiLCJvbk1lc3NhZ2UkMSIsImNhbkJlVXNlZCQxIiwiYXZlcmFnZVJlc3BvbnNlVGltZSQxIiwiU2VydmVyTWV0aG9kIiwiU0lNVUxBVEVfQ0hBTk5FTFMiLCJTSU1VTEFURV9ERUxBWV9USU1FIiwiY2hhbm5lbEFycmF5IiwiQXJyYXkiLCJjaGFubmVsIiwiU2ltdWxhdGVNZXRob2QiLCJNRVRIT0RTIiwiY2hvb3NlTWV0aG9kIiwiY2hvb3NlTWV0aG9kcyIsImNvbmNhdCIsIkJvb2xlYW4iLCJmaW5kIiwibSIsInVzZU1ldGhvZCIsIk9QRU5fQlJPQURDQVNUX0NIQU5ORUxTIiwibGFzdElkIiwiQnJvYWRjYXN0Q2hhbm5lbCQxIiwiRU5GT1JDRURfT1BUSU9OUyIsIl9pTCIsIl9vbk1MIiwiX2FkZEVMIiwibWVzc2FnZSIsImludGVybmFsIiwiX3VNUCIsIl9iZWZDIiwiX3ByZXBQIiwiX3ByZXBhcmVDaGFubmVsIiwiZW5mb3JjZU9wdGlvbnMiLCJwcm90b3R5cGUiLCJfcG9zdCIsInBvc3RJbnRlcm5hbCIsImxpc3Rlbk9iaiIsIl9yZW1vdmVMaXN0ZW5lck9iamVjdCIsIl9hZGRMaXN0ZW5lck9iamVjdCIsImF3YWl0UHJlcGFyZSIsIl9zdGF0ZSIsImlzQ2xvc2VkIiwiYnJvYWRjYXN0Q2hhbm5lbCIsInNlbmRQcm9taXNlIiwibWF5YmVQcm9taXNlIiwicyIsIl9oYXNNZXNzYWdlTGlzdGVuZXJzIiwiX3N0YXJ0TGlzdGVuaW5nIiwibyIsIl9zdG9wTGlzdGVuaW5nIiwibGlzdGVuZXJGbiIsImxpc3RlbmVyT2JqZWN0IiwiSW5kZXhlZERiTWV0aG9kIiwiTG9jYWxTdG9yYWdlTWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toruslabs/constants/dist/constants.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FND_SERVER: () => (/* binding */ FND_SERVER),\n/* harmony export */   KEY_TYPE: () => (/* binding */ KEY_TYPE),\n/* harmony export */   LEGACY_NETWORKS_ROUTE_MAP: () => (/* binding */ LEGACY_NETWORKS_ROUTE_MAP),\n/* harmony export */   METADATA_MAP: () => (/* binding */ METADATA_MAP),\n/* harmony export */   MULTI_CLUSTER_NETWORKS: () => (/* binding */ MULTI_CLUSTER_NETWORKS),\n/* harmony export */   NETWORK_MAP: () => (/* binding */ NETWORK_MAP),\n/* harmony export */   PROXY_CONTRACT_ADDRESS: () => (/* binding */ PROXY_CONTRACT_ADDRESS),\n/* harmony export */   SESSION_SERVER: () => (/* binding */ SESSION_SERVER),\n/* harmony export */   SIGNER_MAP: () => (/* binding */ SIGNER_MAP),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* binding */ TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* binding */ TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   abi: () => (/* binding */ abi)\n/* harmony export */ });\nconst TORUS_LEGACY_NETWORK = {\n    MAINNET: \"mainnet\",\n    TESTNET: \"testnet\",\n    CYAN: \"cyan\",\n    AQUA: \"aqua\",\n    CELESTE: \"celeste\"\n};\nconst TORUS_SAPPHIRE_NETWORK = {\n    SAPPHIRE_DEVNET: \"sapphire_devnet\",\n    SAPPHIRE_MAINNET: \"sapphire_mainnet\"\n};\nconst PROXY_CONTRACT_ADDRESS = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"0xf20336e16B5182637f09821c27BDe29b0AFcfe80\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"0x9f072ba19b3370e512aa1b4bfcdaf97283168005\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"0x29Dea82a0509153b91040ee13cDBba0f03efb625\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c\"\n};\nconst MULTI_CLUSTER_NETWORKS = [];\nconst LEGACY_NETWORKS_ROUTE_MAP = {\n    [TORUS_LEGACY_NETWORK.AQUA]: {\n        migrationCompleted: true,\n        networkIdentifier: \"aqua\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.CELESTE]: {\n        migrationCompleted: true,\n        networkIdentifier: \"celeste\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.CYAN]: {\n        migrationCompleted: true,\n        networkIdentifier: \"cyan\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.MAINNET]: {\n        migrationCompleted: true,\n        networkIdentifier: \"mainnet\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.TESTNET]: {\n        migrationCompleted: true,\n        networkIdentifier: \"teal\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET\n    }\n};\nconst NETWORK_MAP = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"mainnet\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"goerli\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"polygon-mainnet\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"polygon-mainnet\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"polygon-mainnet\"\n};\nconst SIGNER_MAP = {\n    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: \"https://signer.web3auth.io\",\n    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"https://signer-polygon.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"https://signer-polygon.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"https://signer-polygon.web3auth.io\"\n};\nconst METADATA_MAP = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"https://metadata.web3auth.io\"\n};\nconst FND_SERVER = \"https://fnd.web3auth.io\";\nconst SESSION_SERVER = \"https://session.web3auth.io\";\nconst KEY_TYPE = {\n    SECP256K1: \"secp256k1\",\n    ED25519: \"ed25519\"\n};\nconst abi = [\n    {\n        inputs: [\n            {\n                internalType: \"string\",\n                name: \"_verifier\",\n                type: \"string\"\n            },\n            {\n                internalType: \"bytes32\",\n                name: \"hashedVerifierId\",\n                type: \"bytes32\"\n            }\n        ],\n        name: \"getNodeSet\",\n        outputs: [\n            {\n                internalType: \"uint256\",\n                name: \"currentEpoch\",\n                type: \"uint256\"\n            },\n            {\n                internalType: \"string[]\",\n                name: \"torusNodeEndpoints\",\n                type: \"string[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusNodePubX\",\n                type: \"uint256[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusNodePubY\",\n                type: \"uint256[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusIndexes\",\n                type: \"uint256[]\"\n            }\n        ],\n        stateMutability: \"view\",\n        type: \"function\"\n    }\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9jb25zdGFudHMvZGlzdC9jb25zdGFudHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLHVCQUF1QjtJQUMzQkMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxTQUFTO0FBQ1g7QUFDQSxNQUFNQyx5QkFBeUI7SUFDN0JDLGlCQUFpQjtJQUNqQkMsa0JBQWtCO0FBQ3BCO0FBQ0EsTUFBTUMseUJBQXlCO0lBQzdCLENBQUNULHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1LLHlCQUF5QixFQUk5QjtBQUNELE1BQU1DLDRCQUE0QjtJQUNoQyxDQUFDWCxxQkFBcUJJLElBQUksQ0FBQyxFQUFFO1FBQzNCUSxvQkFBb0I7UUFDcEJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CUix1QkFBdUJFLGdCQUFnQjtJQUM1RDtJQUNBLENBQUNSLHFCQUFxQkssT0FBTyxDQUFDLEVBQUU7UUFDOUJPLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyxtQkFBbUJSLHVCQUF1QkUsZ0JBQWdCO0lBQzVEO0lBQ0EsQ0FBQ1IscUJBQXFCRyxJQUFJLENBQUMsRUFBRTtRQUMzQlMsb0JBQW9CO1FBQ3BCQyxtQkFBbUI7UUFDbkJDLG1CQUFtQlIsdUJBQXVCRSxnQkFBZ0I7SUFDNUQ7SUFDQSxDQUFDUixxQkFBcUJDLE9BQU8sQ0FBQyxFQUFFO1FBQzlCVyxvQkFBb0I7UUFDcEJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CUix1QkFBdUJFLGdCQUFnQjtJQUM1RDtJQUNBLENBQUNSLHFCQUFxQkUsT0FBTyxDQUFDLEVBQUU7UUFDOUJVLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyxtQkFBbUJSLHVCQUF1QkMsZUFBZTtJQUMzRDtBQUNGO0FBQ0EsTUFBTVEsY0FBYztJQUNsQixDQUFDZixxQkFBcUJDLE9BQU8sQ0FBQyxFQUFFO0lBQ2hDLENBQUNELHFCQUFxQkUsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0YscUJBQXFCRyxJQUFJLENBQUMsRUFBRTtJQUM3QixDQUFDSCxxQkFBcUJJLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNKLHFCQUFxQkssT0FBTyxDQUFDLEVBQUU7QUFDbEM7QUFDQSxNQUFNVyxhQUFhO0lBQ2pCLENBQUNWLHVCQUF1QkUsZ0JBQWdCLENBQUMsRUFBRTtJQUMzQyxDQUFDRix1QkFBdUJDLGVBQWUsQ0FBQyxFQUFFO0lBQzFDLENBQUNQLHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1ZLGVBQWU7SUFDbkIsQ0FBQ2pCLHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1hLGFBQWE7QUFDbkIsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLFdBQVc7SUFDZkMsV0FBVztJQUNYQyxTQUFTO0FBQ1g7QUFFQSxNQUFNQyxNQUFNO0lBQUM7UUFDWEMsUUFBUTtZQUFDO2dCQUNQQyxjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFBRztnQkFDREYsY0FBYztnQkFDZEMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1NBQUU7UUFDRkQsTUFBTTtRQUNORSxTQUFTO1lBQUM7Z0JBQ1JILGNBQWM7Z0JBQ2RDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtZQUFHO2dCQUNERixjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFBRztnQkFDREYsY0FBYztnQkFDZEMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1lBQUc7Z0JBQ0RGLGNBQWM7Z0JBQ2RDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtZQUFHO2dCQUNERixjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7U0FBRTtRQUNGRSxpQkFBaUI7UUFDakJGLE1BQU07SUFDUjtDQUFFO0FBRW1OIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcW9nbml0YS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2NvbnN0YW50cy9kaXN0L2NvbnN0YW50cy5lc20uanM/M2U5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBUT1JVU19MRUdBQ1lfTkVUV09SSyA9IHtcbiAgTUFJTk5FVDogXCJtYWlubmV0XCIsXG4gIFRFU1RORVQ6IFwidGVzdG5ldFwiLFxuICBDWUFOOiBcImN5YW5cIixcbiAgQVFVQTogXCJhcXVhXCIsXG4gIENFTEVTVEU6IFwiY2VsZXN0ZVwiXG59O1xuY29uc3QgVE9SVVNfU0FQUEhJUkVfTkVUV09SSyA9IHtcbiAgU0FQUEhJUkVfREVWTkVUOiBcInNhcHBoaXJlX2Rldm5ldFwiLFxuICBTQVBQSElSRV9NQUlOTkVUOiBcInNhcHBoaXJlX21haW5uZXRcIlxufTtcbmNvbnN0IFBST1hZX0NPTlRSQUNUX0FERFJFU1MgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCIweGYyMDMzNmUxNkI1MTgyNjM3ZjA5ODIxYzI3QkRlMjliMEFGY2ZlODBcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiBcIjB4ZDA4NDYwNGU1RkEzODdGYkMyRGE4YkFhYjA3ZkRENmFERUQ0NjE0QVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiMHg5ZjA3MmJhMTliMzM3MGU1MTJhYTFiNGJmY2RhZjk3MjgzMTY4MDA1XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXTogXCIweDI5RGVhODJhMDUwOTE1M2I5MTA0MGVlMTNjREJiYTBmMDNlZmI2MjVcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiBcIjB4NkJmZmI0ZTg5NDUzMDY5RTc0ODdmMGZhNWM5ZjRhMkQ3NzFjY2U2Y1wiXG59O1xuY29uc3QgTVVMVElfQ0xVU1RFUl9ORVRXT1JLUyA9IFtcbiAgLy8gVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQSxcbiAgLy8gVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURSxcbiAgLy8gVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTixcbl07XG5jb25zdCBMRUdBQ1lfTkVUV09SS1NfUk9VVEVfTUFQID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwiYXF1YVwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcImNlbGVzdGVcIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXG4gIH0sXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJjeWFuXCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwibWFpbm5ldFwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcInRlYWxcIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9ERVZORVRcbiAgfVxufTtcbmNvbnN0IE5FVFdPUktfTUFQID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IFwibWFpbm5ldFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiZ29lcmxpXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXTogXCJwb2x5Z29uLW1haW5uZXRcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcInBvbHlnb24tbWFpbm5ldFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwicG9seWdvbi1tYWlubmV0XCJcbn07XG5jb25zdCBTSUdORVJfTUFQID0ge1xuICBbVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXTogXCJodHRwczovL3NpZ25lci53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9ERVZORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCJodHRwczovL3NpZ25lci53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiaHR0cHM6Ly9zaWduZXIud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcImh0dHBzOi8vc2lnbmVyLXBvbHlnb24ud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcImh0dHBzOi8vc2lnbmVyLXBvbHlnb24ud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiBcImh0dHBzOi8vc2lnbmVyLXBvbHlnb24ud2ViM2F1dGguaW9cIlxufTtcbmNvbnN0IE1FVEFEQVRBX01BUCA9IHtcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcImh0dHBzOi8vbWV0YWRhdGEud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiBcImh0dHBzOi8vbWV0YWRhdGEud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcImh0dHBzOi8vbWV0YWRhdGEud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcImh0dHBzOi8vbWV0YWRhdGEud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiBcImh0dHBzOi8vbWV0YWRhdGEud2ViM2F1dGguaW9cIlxufTtcbmNvbnN0IEZORF9TRVJWRVIgPSBcImh0dHBzOi8vZm5kLndlYjNhdXRoLmlvXCI7XG5jb25zdCBTRVNTSU9OX1NFUlZFUiA9IFwiaHR0cHM6Ly9zZXNzaW9uLndlYjNhdXRoLmlvXCI7XG5jb25zdCBLRVlfVFlQRSA9IHtcbiAgU0VDUDI1NksxOiBcInNlY3AyNTZrMVwiLFxuICBFRDI1NTE5OiBcImVkMjU1MTlcIlxufTtcblxuY29uc3QgYWJpID0gW3tcbiAgaW5wdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICBuYW1lOiBcIl92ZXJpZmllclwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgbmFtZTogXCJoYXNoZWRWZXJpZmllcklkXCIsXG4gICAgdHlwZTogXCJieXRlczMyXCJcbiAgfV0sXG4gIG5hbWU6IFwiZ2V0Tm9kZVNldFwiLFxuICBvdXRwdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgbmFtZTogXCJjdXJyZW50RXBvY2hcIixcbiAgICB0eXBlOiBcInVpbnQyNTZcIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1tdXCIsXG4gICAgbmFtZTogXCJ0b3J1c05vZGVFbmRwb2ludHNcIixcbiAgICB0eXBlOiBcInN0cmluZ1tdXCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2W11cIixcbiAgICBuYW1lOiBcInRvcnVzTm9kZVB1YlhcIixcbiAgICB0eXBlOiBcInVpbnQyNTZbXVwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NltdXCIsXG4gICAgbmFtZTogXCJ0b3J1c05vZGVQdWJZXCIsXG4gICAgdHlwZTogXCJ1aW50MjU2W11cIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZbXVwiLFxuICAgIG5hbWU6IFwidG9ydXNJbmRleGVzXCIsXG4gICAgdHlwZTogXCJ1aW50MjU2W11cIlxuICB9XSxcbiAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgdHlwZTogXCJmdW5jdGlvblwiXG59XTtcblxuZXhwb3J0IHsgRk5EX1NFUlZFUiwgS0VZX1RZUEUsIExFR0FDWV9ORVRXT1JLU19ST1VURV9NQVAsIE1FVEFEQVRBX01BUCwgTVVMVElfQ0xVU1RFUl9ORVRXT1JLUywgTkVUV09SS19NQVAsIFBST1hZX0NPTlRSQUNUX0FERFJFU1MsIFNFU1NJT05fU0VSVkVSLCBTSUdORVJfTUFQLCBUT1JVU19MRUdBQ1lfTkVUV09SSywgVE9SVVNfU0FQUEhJUkVfTkVUV09SSywgYWJpIH07XG4iXSwibmFtZXMiOlsiVE9SVVNfTEVHQUNZX05FVFdPUksiLCJNQUlOTkVUIiwiVEVTVE5FVCIsIkNZQU4iLCJBUVVBIiwiQ0VMRVNURSIsIlRPUlVTX1NBUFBISVJFX05FVFdPUksiLCJTQVBQSElSRV9ERVZORVQiLCJTQVBQSElSRV9NQUlOTkVUIiwiUFJPWFlfQ09OVFJBQ1RfQUREUkVTUyIsIk1VTFRJX0NMVVNURVJfTkVUV09SS1MiLCJMRUdBQ1lfTkVUV09SS1NfUk9VVEVfTUFQIiwibWlncmF0aW9uQ29tcGxldGVkIiwibmV0d29ya0lkZW50aWZpZXIiLCJuZXR3b3JrTWlncmF0ZWRUbyIsIk5FVFdPUktfTUFQIiwiU0lHTkVSX01BUCIsIk1FVEFEQVRBX01BUCIsIkZORF9TRVJWRVIiLCJTRVNTSU9OX1NFUlZFUiIsIktFWV9UWVBFIiwiU0VDUDI1NksxIiwiRUQyNTUxOSIsImFiaSIsImlucHV0cyIsImludGVybmFsVHlwZSIsIm5hbWUiLCJ0eXBlIiwib3V0cHV0cyIsInN0YXRlTXV0YWJpbGl0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   derivePadded: () => (/* binding */ derivePadded),\n/* harmony export */   deriveUnpadded: () => (/* binding */ deriveUnpadded),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generatePrivate: () => (/* binding */ generatePrivate),\n/* harmony export */   getPublic: () => (/* binding */ getPublic),\n/* harmony export */   getPublicCompressed: () => (/* binding */ getPublicCompressed),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_1__.ec(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst browserCrypto = global.crypto || global.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nfunction isScalar(x) {\n    return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n    if (!isScalar(privateKey)) {\n        return false;\n    }\n    return privateKey.compare(ZERO32) > 0 && // > 0\n    privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for(let i = 0; i < b1.length; i++){\n        res |= b1[i] ^ b2[i]; // jshint ignore:line\n    }\n    return res === 0;\n}\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */ function randomBytes(size) {\n    const arr = new Uint8Array(size);\n    if (typeof browserCrypto.getRandomValues === \"undefined\") {\n        return Buffer.from(crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(size));\n    }\n    browserCrypto.getRandomValues(arr);\n    return Buffer.from(arr);\n}\nasync function sha512(msg) {\n    if (subtle) {\n        const hash = await subtle.digest(\"SHA-512\", msg);\n        const result = new Uint8Array(hash);\n        return result;\n    }\n    const hash = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha512\");\n    const result = hash.update(msg).digest();\n    return new Uint8Array(result);\n}\nfunction getAes(op) {\n    return async function(iv, key, data) {\n        if (subtle) {\n            const importAlgorithm = {\n                name: \"AES-CBC\"\n            };\n            const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [\n                op\n            ]);\n            const encAlgorithm = {\n                name: \"AES-CBC\",\n                iv\n            };\n            const result = await subtle[op](encAlgorithm, cryptoKey, data);\n            return Buffer.from(new Uint8Array(result));\n        } else if (op === \"encrypt\") {\n            const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(\"aes-256-cbc\", key, iv);\n            const firstChunk = cipher.update(data);\n            const secondChunk = cipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        } else if (op === \"decrypt\") {\n            const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(\"aes-256-cbc\", key, iv);\n            const firstChunk = decipher.update(data);\n            const secondChunk = decipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        }\n        throw new Error(`Unsupported operation: ${op}`);\n    };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n    if (subtle) {\n        const importAlgorithm = {\n            name: \"HMAC\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\n            \"sign\",\n            \"verify\"\n        ]);\n        const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n        const result = Buffer.from(new Uint8Array(sig));\n        return result;\n    }\n    const hmac = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHmac(\"sha256\", Buffer.from(key));\n    hmac.update(msg);\n    const result = hmac.digest();\n    return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n    const expectedSig = await hmacSha256Sign(key, msg);\n    return equalConstTime(expectedSig, sig);\n}\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */ const generatePrivate = function() {\n    let privateKey = randomBytes(32);\n    while(!isValidPrivateKey(privateKey)){\n        privateKey = randomBytes(32);\n    }\n    return privateKey;\n};\nconst getPublic = function(privateKey) {\n    // This function has sync API so we throw an error immediately.\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // XXX(Kagami): `elliptic.utils.encode` returns array for every\n    // encoding except `hex`.\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n/**\n * Get compressed version of public key.\n */ const getPublicCompressed = function(privateKey) {\n    // jshint ignore:line\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // See https://github.com/wanderer/secp256k1-node/issues/46\n    const compressed = true;\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function(privateKey, msg) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    return Buffer.from(ec.sign(msg, privateKey, {\n        canonical: true\n    }).toDER());\n};\nconst verify = async function(publicKey, msg, sig) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65) {\n        assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33) {\n        assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n        return null;\n    }\n    throw new Error(\"Bad signature\");\n};\nconst derive = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function(publicKeyTo, msg, opts) {\n    opts = opts || {};\n    let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey)){\n        ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    const ephemPublicKey = getPublic(ephemPrivateKey);\n    const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n    const hash = await sha512(Px);\n    const iv = opts.iv || randomBytes(16);\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n    const ciphertext = data;\n    const dataToMac = Buffer.concat([\n        iv,\n        ephemPublicKey,\n        ciphertext\n    ]);\n    const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n    return {\n        iv,\n        ephemPublicKey,\n        ciphertext,\n        mac\n    };\n};\nconst decrypt = async function(privateKey, opts, _padding) {\n    const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n    const deriveLocal = padding ? derivePadded : deriveUnpadded;\n    const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n    const hash = await sha512(Px);\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const dataToMac = Buffer.concat([\n        opts.iv,\n        opts.ephemPublicKey,\n        opts.ciphertext\n    ]);\n    const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n    if (!macGood && padding === false) {\n        return decrypt(privateKey, opts, true);\n    } else if (!macGood && padding === true) {\n        throw new Error(\"bad MAC after trying padded\");\n    }\n    const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n    return Buffer.from(new Uint8Array(msg));\n};\n //# sourceMappingURL=eccrypto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9lY2NyeXB0by9kaXN0L2VjY3J5cHRvLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNNO0FBRXRDLE1BQU1DLEtBQUssSUFBSUMsd0NBQUlBLENBQUM7QUFDcEIsOERBQThEO0FBQzlELE1BQU1DLGdCQUFnQkMsT0FBT0MsTUFBTSxJQUFJRCxPQUFPRSxRQUFRLElBQUksQ0FBQztBQUMzRCw4REFBOEQ7QUFDOUQsTUFBTUMsU0FBU0osY0FBY0ksTUFBTSxJQUFJSixjQUFjSyxZQUFZO0FBQ2pFLE1BQU1DLGlCQUFpQkMsT0FBT0MsSUFBSSxDQUFDLG9FQUFvRTtBQUN2RyxNQUFNQyxTQUFTRixPQUFPRyxLQUFLLENBQUMsSUFBSTtBQUNoQyxTQUFTQyxPQUFPQyxTQUFTLEVBQUVDLE9BQU87SUFDaEMsSUFBSSxDQUFDRCxXQUFXO1FBQ2QsTUFBTSxJQUFJRSxNQUFNRCxXQUFXO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTRSxTQUFTQyxDQUFDO0lBQ2pCLE9BQU9ULE9BQU9VLFFBQVEsQ0FBQ0QsTUFBTUEsRUFBRUUsTUFBTSxLQUFLO0FBQzVDO0FBQ0EsU0FBU0Msa0JBQWtCQyxVQUFVO0lBQ25DLElBQUksQ0FBQ0wsU0FBU0ssYUFBYTtRQUN6QixPQUFPO0lBQ1Q7SUFDQSxPQUFPQSxXQUFXQyxPQUFPLENBQUNaLFVBQVUsS0FDcEMsTUFBTTtJQUNOVyxXQUFXQyxPQUFPLENBQUNmLGtCQUFrQixHQUFHLE1BQU07QUFDaEQ7QUFFQSxrRUFBa0U7QUFDbEUsU0FBU2dCLGVBQWVDLEVBQUUsRUFBRUMsRUFBRTtJQUM1QixJQUFJRCxHQUFHTCxNQUFNLEtBQUtNLEdBQUdOLE1BQU0sRUFBRTtRQUMzQixPQUFPO0lBQ1Q7SUFDQSxJQUFJTyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEdBQUdMLE1BQU0sRUFBRVEsSUFBSztRQUNsQ0QsT0FBT0YsRUFBRSxD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VSxnQkFBZ0J6RCxLQUFLMEQsS0FBSyxDQUFDLEdBQUc7SUFDcEMsTUFBTUMsU0FBUzNELEtBQUswRCxLQUFLLENBQUM7SUFDMUIsTUFBTUcsWUFBWXhGLE9BQU8rQyxNQUFNLENBQUM7UUFBQ2tDLEtBQUsvQyxFQUFFO1FBQUUrQyxLQUFLRSxjQUFjO1FBQUVGLEtBQUtNLFVBQVU7S0FBQztJQUMvRSxNQUFNTyxVQUFVLE1BQU1yQyxpQkFBaUJ6RCxPQUFPQyxJQUFJLENBQUNxRixTQUFTRSxXQUFXUCxLQUFLUSxHQUFHO0lBQy9FLElBQUksQ0FBQ0ssV0FBV0YsWUFBWSxPQUFPO1FBQ2pDLE9BQU9GLFFBQVE3RSxZQUFZb0UsTUFBTTtJQUNuQyxPQUFPLElBQUksQ0FBQ2EsV0FBV0YsWUFBWSxNQUFNO1FBQ3ZDLE1BQU0sSUFBSXJGLE1BQU07SUFDbEI7SUFDQSxNQUFNbUIsTUFBTSxNQUFNeUIsY0FBYzhCLEtBQUsvQyxFQUFFLEVBQUVsQyxPQUFPQyxJQUFJLENBQUNtRixnQkFBZ0JILEtBQUtNLFVBQVU7SUFDcEYsT0FBT3ZGLE9BQU9DLElBQUksQ0FBQyxJQUFJc0IsV0FBV0c7QUFDcEM7QUFFaUksQ0FDakksd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcW9nbml0YS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2VjY3J5cHRvL2Rpc3QvZWNjcnlwdG8uZXNtLmpzP2Y1M2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGVjIGFzIGVjJDEgfSBmcm9tICdlbGxpcHRpYyc7XG5cbmNvbnN0IGVjID0gbmV3IGVjJDEoXCJzZWNwMjU2azFcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgYnJvd3NlckNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvIHx8IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuY29uc3QgRUNfR1JPVVBfT1JERVIgPSBCdWZmZXIuZnJvbShcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIiwgXCJoZXhcIik7XG5jb25zdCBaRVJPMzIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTY2FsYXIoeCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHgpICYmIHgubGVuZ3RoID09PSAzMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgaWYgKCFpc1NjYWxhcihwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleS5jb21wYXJlKFpFUk8zMikgPiAwICYmXG4gIC8vID4gMFxuICBwcml2YXRlS2V5LmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMDsgLy8gPCBHXG59XG5cbi8vIENvbXBhcmUgdHdvIGJ1ZmZlcnMgaW4gY29uc3RhbnQgdGltZSB0byBwcmV2ZW50IHRpbWluZyBhdHRhY2tzLlxuZnVuY3Rpb24gZXF1YWxDb25zdFRpbWUoYjEsIGIyKSB7XG4gIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIHJlcyB8PSBiMVtpXSBeIGIyW2ldOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfVxuXG4gIHJldHVybiByZXMgPT09IDA7XG59XG5cbi8qIFRoaXMgbXVzdCBjaGVjayBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlciBvclxubm90LCBzaW5jZSB0aGUgZnVuY3Rpb25zIGFyZSBkaWZmZXJlbnQgYW5kIGRvZXNcbm5vdCBjb252ZXJ0IHVzaW5nIGJyb3dzZXJpZnkgKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKHNpemUpIHtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIGlmICh0eXBlb2YgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obm9kZUNyeXB0by5yYW5kb21CeXRlcyhzaXplKSk7XG4gIH1cbiAgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG59XG5hc3luYyBmdW5jdGlvbiBzaGE1MTIobXNnKSB7XG4gIGlmIChzdWJ0bGUpIHtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbXNnKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGhhc2ggPSBub2RlQ3J5cHRvLmNyZWF0ZUhhc2goXCJzaGE1MTJcIik7XG4gIGNvbnN0IHJlc3VsdCA9IGhhc2gudXBkYXRlKG1zZykuZGlnZXN0KCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZnVuY3Rpb24gZ2V0QWVzKG9wKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXYsIGtleSwgZGF0YSkge1xuICAgIGlmIChzdWJ0bGUpIHtcbiAgICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCJcbiAgICAgIH07XG4gICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW29wXSk7XG4gICAgICBjb25zdCBlbmNBbGdvcml0aG0gPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiLFxuICAgICAgICBpdlxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1YnRsZVtvcF0oZW5jQWxnb3JpdGhtLCBjcnlwdG9LZXksIGRhdGEpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZW5jcnlwdFwiKSB7XG4gICAgICBjb25zdCBjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KFwiYWVzLTI1Ni1jYmNcIiwga2V5LCBpdik7XG4gICAgICBjb25zdCBmaXJzdENodW5rID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgIGNvbnN0IHNlY29uZENodW5rID0gY2lwaGVyLmZpbmFsKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZmlyc3RDaHVuaywgc2Vjb25kQ2h1bmtdKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImRlY3J5cHRcIikge1xuICAgICAgY29uc3QgZGVjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXCJhZXMtMjU2LWNiY1wiLCBrZXksIGl2KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICBjb25zdCBzZWNvbmRDaHVuayA9IGRlY2lwaGVyLmZpbmFsKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZmlyc3RDaHVuaywgc2Vjb25kQ2h1bmtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRpb246ICR7b3B9YCk7XG4gIH07XG59XG5jb25zdCBhZXNDYmNFbmNyeXB0ID0gZ2V0QWVzKFwiZW5jcnlwdFwiKTtcbmNvbnN0IGFlc0NiY0RlY3J5cHQgPSBnZXRBZXMoXCJkZWNyeXB0XCIpO1xuYXN5bmMgZnVuY3Rpb24gaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpIHtcbiAgaWYgKHN1YnRsZSkge1xuICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHtcbiAgICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBcIlNIQS0yNTZcIlxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBuZXcgVWludDhBcnJheShrZXkpLCBpbXBvcnRBbGdvcml0aG0sIGZhbHNlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbiAgICBjb25zdCBzaWcgPSBhd2FpdCBzdWJ0bGUuc2lnbihcIkhNQUNcIiwgY3J5cHRvS2V5LCBtc2cpO1xuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgaG1hYyA9IG5vZGVDcnlwdG8uY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBCdWZmZXIuZnJvbShrZXkpKTtcbiAgaG1hYy51cGRhdGUobXNnKTtcbiAgY29uc3QgcmVzdWx0ID0gaG1hYy5kaWdlc3QoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhtYWNTaGEyNTZWZXJpZnkoa2V5LCBtc2csIHNpZykge1xuICBjb25zdCBleHBlY3RlZFNpZyA9IGF3YWl0IGhtYWNTaGEyNTZTaWduKGtleSwgbXNnKTtcbiAgcmV0dXJuIGVxdWFsQ29uc3RUaW1lKGV4cGVjdGVkU2lnLCBzaWcpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbmV3IHZhbGlkIHByaXZhdGUga2V5LiBXaWxsIHVzZSB0aGUgd2luZG93LmNyeXB0byBvciB3aW5kb3cubXNDcnlwdG8gYXMgc291cmNlXG4gKiBkZXBlbmRpbmcgb24geW91ciBicm93c2VyLlxuICovXG5jb25zdCBnZW5lcmF0ZVByaXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICB3aGlsZSAoIWlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpKSB7XG4gICAgcHJpdmF0ZUtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleTtcbn07XG5jb25zdCBnZXRQdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBzeW5jIEFQSSBzbyB3ZSB0aHJvdyBhbiBlcnJvciBpbW1lZGlhdGVseS5cbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIC8vIFhYWChLYWdhbWkpOiBgZWxsaXB0aWMudXRpbHMuZW5jb2RlYCByZXR1cm5zIGFycmF5IGZvciBldmVyeVxuICAvLyBlbmNvZGluZyBleGNlcHQgYGhleGAuXG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoXCJhcnJheVwiKSk7XG59O1xuXG4vKipcbiAqIEdldCBjb21wcmVzc2VkIHZlcnNpb24gb2YgcHVibGljIGtleS5cbiAqL1xuY29uc3QgZ2V0UHVibGljQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93YW5kZXJlci9zZWNwMjU2azEtbm9kZS9pc3N1ZXMvNDZcbiAgY29uc3QgY29tcHJlc3NlZCA9IHRydWU7XG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoY29tcHJlc3NlZCwgXCJhcnJheVwiKSk7XG59O1xuXG4vLyBOT1RFKEthZ2FtaSk6IFdlIGRvbid0IHVzZSBwcm9taXNlIHNoaW0gaW4gQnJvd3NlciBpbXBsZW1lbnRhdGlvblxuLy8gYmVjYXVzZSBpdCdzIHN1cHBvcnRlZCBuYXRpdmVseSBpbiBuZXcgYnJvd3NlcnMgKHNlZVxuLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1wcm9taXNlcz4pIGFuZCB3ZSBjYW4gdXNlIG9ubHkgbmV3IGJyb3dzZXJzXG4vLyBiZWNhdXNlIG9mIHRoZSBXZWJDcnlwdG9BUEkgKHNlZVxuLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1jcnlwdG9ncmFwaHk+KS5cbmNvbnN0IHNpZ24gPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleSwgbXNnKSB7XG4gIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA+IDAsIFwiTWVzc2FnZSBzaG91bGQgbm90IGJlIGVtcHR5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA8PSAzMiwgXCJNZXNzYWdlIGlzIHRvbyBsb25nXCIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZWMuc2lnbihtc2csIHByaXZhdGVLZXksIHtcbiAgICBjYW5vbmljYWw6IHRydWVcbiAgfSkudG9ERVIoKSk7XG59O1xuY29uc3QgdmVyaWZ5ID0gYXN5bmMgZnVuY3Rpb24gKHB1YmxpY0tleSwgbXNnLCBzaWcpIHtcbiAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleS5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5WzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlbMF0gPT09IDIgfHwgcHVibGljS2V5WzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGFzc2VydChtc2cubGVuZ3RoID4gMCwgXCJNZXNzYWdlIHNob3VsZCBub3QgYmUgZW1wdHlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoIDw9IDMyLCBcIk1lc3NhZ2UgaXMgdG9vIGxvbmdcIik7XG4gIGlmIChlYy52ZXJpZnkobXNnLCBzaWcsIHB1YmxpY0tleSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc2lnbmF0dXJlXCIpO1xufTtcbmNvbnN0IGRlcml2ZSA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5QSwgcHVibGljS2V5Qikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5QiksIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGFzc2VydChwcml2YXRlS2V5QS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Qi5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSAyIHx8IHB1YmxpY0tleUJbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5QSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlBKTtcbiAgY29uc3Qga2V5QiA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5Qik7XG4gIGNvbnN0IFB4ID0ga2V5QS5kZXJpdmUoa2V5Qi5nZXRQdWJsaWMoKSk7IC8vIEJOIGluc3RhbmNlXG4gIHJldHVybiBCdWZmZXIuZnJvbShQeC50b0FycmF5KCkpO1xufTtcbmNvbnN0IGRlcml2ZVVucGFkZGVkID0gZGVyaXZlO1xuY29uc3QgZGVyaXZlUGFkZGVkID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXlBLCBwdWJsaWNLZXlCKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXlCKSwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgYXNzZXJ0KHByaXZhdGVLZXlBLmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDIgfHwgcHVibGljS2V5QlswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlBID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUEpO1xuICBjb25zdCBrZXlCID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXlCKTtcbiAgY29uc3QgUHggPSBrZXlBLmRlcml2ZShrZXlCLmdldFB1YmxpYygpKTsgLy8gQk4gaW5zdGFuY2VcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFB4LnRvU3RyaW5nKDE2LCA2NCksIFwiaGV4XCIpO1xufTtcbmNvbnN0IGVuY3J5cHQgPSBhc3luYyBmdW5jdGlvbiAocHVibGljS2V5VG8sIG1zZywgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgbGV0IGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgLy8gVGhlcmUgaXMgYSB2ZXJ5IHVubGlrZWx5IHBvc3NpYmlsaXR5IHRoYXQgaXQgaXMgbm90IGEgdmFsaWQga2V5XG4gIHdoaWxlICghaXNWYWxpZFByaXZhdGVLZXkoZXBoZW1Qcml2YXRlS2V5KSkge1xuICAgIGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgfVxuICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IGdldFB1YmxpYyhlcGhlbVByaXZhdGVLZXkpO1xuICBjb25zdCBQeCA9IGF3YWl0IGRlcml2ZVVucGFkZGVkKGVwaGVtUHJpdmF0ZUtleSwgcHVibGljS2V5VG8pO1xuICBjb25zdCBoYXNoID0gYXdhaXQgc2hhNTEyKFB4KTtcbiAgY29uc3QgaXYgPSBvcHRzLml2IHx8IHJhbmRvbUJ5dGVzKDE2KTtcbiAgY29uc3QgZW5jcnlwdGlvbktleSA9IGhhc2guc2xpY2UoMCwgMzIpO1xuICBjb25zdCBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGFlc0NiY0VuY3J5cHQoaXYsIEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25LZXkpLCBtc2cpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gZGF0YTtcbiAgY29uc3QgZGF0YVRvTWFjID0gQnVmZmVyLmNvbmNhdChbaXYsIGVwaGVtUHVibGljS2V5LCBjaXBoZXJ0ZXh0XSk7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNTaGEyNTZTaWduKEJ1ZmZlci5mcm9tKG1hY0tleSksIGRhdGFUb01hYyk7XG4gIHJldHVybiB7XG4gICAgaXYsXG4gICAgZXBoZW1QdWJsaWNLZXksXG4gICAgY2lwaGVydGV4dCxcbiAgICBtYWNcbiAgfTtcbn07XG5jb25zdCBkZWNyeXB0ID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXksIG9wdHMsIF9wYWRkaW5nKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSBfcGFkZGluZyAhPT0gbnVsbCAmJiBfcGFkZGluZyAhPT0gdm9pZCAwID8gX3BhZGRpbmcgOiBmYWxzZTtcbiAgY29uc3QgZGVyaXZlTG9jYWwgPSBwYWRkaW5nID8gZGVyaXZlUGFkZGVkIDogZGVyaXZlVW5wYWRkZWQ7XG4gIGNvbnN0IFB4ID0gYXdhaXQgZGVyaXZlTG9jYWwocHJpdmF0ZUtleSwgb3B0cy5lcGhlbVB1YmxpY0tleSk7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBzaGE1MTIoUHgpO1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gaGFzaC5zbGljZSgwLCAzMik7XG4gIGNvbnN0IG1hY0tleSA9IGhhc2guc2xpY2UoMzIpO1xuICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtvcHRzLml2LCBvcHRzLmVwaGVtUHVibGljS2V5LCBvcHRzLmNpcGhlcnRleHRdKTtcbiAgY29uc3QgbWFjR29vZCA9IGF3YWl0IGhtYWNTaGEyNTZWZXJpZnkoQnVmZmVyLmZyb20obWFjS2V5KSwgZGF0YVRvTWFjLCBvcHRzLm1hYyk7XG4gIGlmICghbWFjR29vZCAmJiBwYWRkaW5nID09PSBmYWxzZSkge1xuICAgIHJldHVybiBkZWNyeXB0KHByaXZhdGVLZXksIG9wdHMsIHRydWUpO1xuICB9IGVsc2UgaWYgKCFtYWNHb29kICYmIHBhZGRpbmcgPT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgTUFDIGFmdGVyIHRyeWluZyBwYWRkZWRcIik7XG4gIH1cbiAgY29uc3QgbXNnID0gYXdhaXQgYWVzQ2JjRGVjcnlwdChvcHRzLml2LCBCdWZmZXIuZnJvbShlbmNyeXB0aW9uS2V5KSwgb3B0cy5jaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KG1zZykpO1xufTtcblxuZXhwb3J0IHsgZGVjcnlwdCwgZGVyaXZlLCBkZXJpdmVQYWRkZWQsIGRlcml2ZVVucGFkZGVkLCBlbmNyeXB0LCBnZW5lcmF0ZVByaXZhdGUsIGdldFB1YmxpYywgZ2V0UHVibGljQ29tcHJlc3NlZCwgc2lnbiwgdmVyaWZ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lY2NyeXB0by5lc20uanMubWFwXG4iXSwibmFtZXMiOlsibm9kZUNyeXB0byIsImVjIiwiZWMkMSIsImJyb3dzZXJDcnlwdG8iLCJnbG9iYWwiLCJjcnlwdG8iLCJtc0NyeXB0byIsInN1YnRsZSIsIndlYmtpdFN1YnRsZSIsIkVDX0dST1VQX09SREVSIiwiQnVmZmVyIiwiZnJvbSIsIlpFUk8zMiIsImFsbG9jIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiaXNTY2FsYXIiLCJ4IiwiaXNCdWZmZXIiLCJsZW5ndGgiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJjb21wYXJlIiwiZXF1YWxDb25zdFRpbWUiLCJiMSIsImIyIiwicmVzIiwiaSIsInJhbmRvbUJ5dGVzIiwic2l6ZSIsImFyciIsIlVpbnQ4QXJyYXkiLCJnZXRSYW5kb21WYWx1ZXMiLCJzaGE1MTIiLCJtc2ciLCJoYXNoIiwiZGlnZXN0IiwicmVzdWx0IiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImdldEFlcyIsIm9wIiwiaXYiLCJrZXkiLCJkYXRhIiwiaW1wb3J0QWxnb3JpdGhtIiwibmFtZSIsImNyeXB0b0tleSIsImltcG9ydEtleSIsImVuY0FsZ29yaXRobSIsImNpcGhlciIsImNyZWF0ZUNpcGhlcml2IiwiZmlyc3RDaHVuayIsInNlY29uZENodW5rIiwiZmluYWwiLCJjb25jYXQiLCJkZWNpcGhlciIsImNyZWF0ZURlY2lwaGVyaXYiLCJhZXNDYmNFbmNyeXB0IiwiYWVzQ2JjRGVjcnlwdCIsImhtYWNTaGEyNTZTaWduIiwic2lnIiwic2lnbiIsImhtYWMiLCJjcmVhdGVIbWFjIiwiaG1hY1NoYTI1NlZlcmlmeSIsImV4cGVjdGVkU2lnIiwiZ2VuZXJhdGVQcml2YXRlIiwiZ2V0UHVibGljIiwia2V5RnJvbVByaXZhdGUiLCJnZXRQdWJsaWNDb21wcmVzc2VkIiwiY29tcHJlc3NlZCIsImNhbm9uaWNhbCIsInRvREVSIiwidmVyaWZ5IiwicHVibGljS2V5IiwiZGVyaXZlIiwicHJpdmF0ZUtleUEiLCJwdWJsaWNLZXlCIiwia2V5QSIsImtleUIiLCJrZXlGcm9tUHVibGljIiwiUHgiLCJ0b0FycmF5IiwiZGVyaXZlVW5wYWRkZWQiLCJkZXJpdmVQYWRkZWQiLCJ0b1N0cmluZyIsImVuY3J5cHQiLCJwdWJsaWNLZXlUbyIsIm9wdHMiLCJlcGhlbVByaXZhdGVLZXkiLCJlcGhlbVB1YmxpY0tleSIsImVuY3J5cHRpb25LZXkiLCJzbGljZSIsIm1hY0tleSIsImNpcGhlcnRleHQiLCJkYXRhVG9NYWMiLCJtYWMiLCJkZWNyeXB0IiwiX3BhZGRpbmciLCJwYWRkaW5nIiwiZGVyaXZlTG9jYWwiLCJtYWNHb29kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"(ssr)/./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n    sentry = _sentry;\n    tracingOrigins.push(..._tracingOrigins);\n    tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n    embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n    embedHost = \"\";\n}\nfunction getEmbedHost() {\n    return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n    apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n    apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n    return apiKey;\n}\n// #endregion\nfunction setLogLevel(level) {\n    log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n    let _url = null;\n    try {\n        _url = new URL(url);\n    } catch (error) {}\n    if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n        const transaction = sentry.startTransaction({\n            name: url\n        });\n        const span = transaction.startChild({\n            op: \"http\"\n        }); // This function returns a Span\n        const response = await fetch(url, init);\n        span.finish(); // Remember that only finished spans will be sent with the transaction\n        transaction.finish(); // Finishing the transaction will send it to Sentry\n        return response;\n    }\n    return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n    const headers = {};\n    if (apiKey) headers[gatewayAuthHeader] = apiKey;\n    if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n    return headers;\n}\nfunction debugLogResponse(response) {\n    log.info(`Response: ${response.status} ${response.statusText}`);\n    log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n    const tracingHeader = response.headers.get(\"x-web3-correlation-id\");\n    if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);\n}\nconst promiseTimeout = async (ms, promise)=>{\n    let timeoutFunc = null;\n    try {\n        const timeout = new Promise((_resolve, reject)=>{\n            timeoutFunc = setTimeout(()=>{\n                reject(new Error(`Timed out in ${ms}ms`));\n            }, ms);\n        });\n        const result = await Promise.race([\n            promise,\n            timeout\n        ]);\n        // promise.race will return the first resolved promise\n        // then we clear the timeout\n        if (timeoutFunc != null) {\n            clearTimeout(timeoutFunc);\n        }\n        return result;\n    } catch (err) {\n        // clear the timeout\n        if (timeoutFunc != null) {\n            clearTimeout(timeoutFunc);\n        }\n        // rethrow the original error\n        throw err;\n    }\n};\nconst get = async function(url) {\n    let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {}\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"GET\"\n    });\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst post = function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"POST\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then((response)=>{\n        if (customOptions.logTracingHeader) {\n            logTracingHeader(response);\n        }\n        if (response.ok) {\n            const responseContentType = response.headers.get(\"content-type\");\n            if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n                return response.json();\n            }\n            return response.text();\n        }\n        debugLogResponse(response);\n        throw response;\n    }));\n};\nconst patch = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PATCH\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst put = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PUT\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst remove = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"DELETE\"\n    });\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst generateJsonRPCObject = (method, parameters)=>({\n        jsonrpc: \"2.0\",\n        method,\n        id: 10,\n        params: parameters\n    });\nconst promiseRace = function(url, options) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n    return Promise.race([\n        get(url, options),\n        new Promise((_resolve, reject)=>{\n            setTimeout(()=>{\n                reject(new Error(\"timed out\"));\n            }, timeout);\n        })\n    ]);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9odHRwSGVscGVycy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ2hDO0FBQ1c7QUFFNUMsTUFBTUksTUFBTUYseURBQWtCLENBQUM7QUFDL0JFLElBQUlFLFFBQVEsQ0FBQ0gsNENBQU1BLENBQUNJLElBQUk7QUFDeEIsSUFBSUMsU0FBUztBQUNiLElBQUlDLFlBQVk7QUFFaEIsbUJBQW1CO0FBQ25CLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyx5QkFBeUI7QUFDL0IsSUFBSUMsU0FBUztBQUNiLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLE1BQU1DLGVBQWUsRUFBRTtBQUN2QixTQUFTQyxvQkFBb0JDLE9BQU8sRUFBRUMsZUFBZSxFQUFFQyxhQUFhO0lBQ2xFTixTQUFTSTtJQUNUSCxlQUFlTSxJQUFJLElBQUlGO0lBQ3ZCSCxhQUFhSyxJQUFJLElBQUlEO0FBQ3ZCO0FBQ0EsU0FBU0UsYUFBYUMsVUFBVTtJQUM5QlosWUFBWVk7QUFDZDtBQUNBLFNBQVNDO0lBQ1BiLFlBQVk7QUFDZDtBQUNBLFNBQVNjO0lBQ1AsT0FBT2Q7QUFDVDtBQUNBLFNBQVNlLFVBQVVDLE9BQU87SUFDeEJqQixTQUFTaUI7QUFDWDtBQUNBLFNBQVNDO0lBQ1BsQixTQUFTO0FBQ1g7QUFDQSxTQUFTbUI7SUFDUCxPQUFPbkI7QUFDVDtBQUVBLGFBQWE7QUFFYixTQUFTb0IsWUFBWUMsS0FBSztJQUN4QnpCLElBQUlFLFFBQVEsQ0FBQ3VCO0FBQ2Y7QUFDQSxlQUFlQyxjQUFjQyxHQUFHLEVBQUVDLElBQUk7SUFDcEMsSUFBSUMsT0FBTztJQUNYLElBQUk7UUFDRkEsT0FBTyxJQUFJQyxJQUFJSDtJQUNqQixFQUFFLE9BQU9JLE9BQU8sQ0FBQztJQUNqQixJQUFJdkIsVUFBVXFCLFFBQVNwQixDQUFBQSxlQUFldUIsUUFBUSxDQUFDSCxLQUFL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R0FBRyxDQUFDO1FBQ2pELElBQUkwQix3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssS0FBS0Esb0JBQW9COUMsUUFBUSxDQUFDLHFCQUFxQjtZQUN0SCxPQUFPUyxTQUFTc0MsSUFBSTtRQUN0QjtRQUNBLE9BQU90QyxTQUFTdUMsSUFBSTtJQUN0QjtJQUNBbEMsaUJBQWlCTDtJQUNqQixNQUFNQTtBQUNSO0FBQ0EsTUFBTWtELHdCQUF3QixDQUFDZixRQUFRZ0IsYUFBZ0I7UUFDckRDLFNBQVM7UUFDVGpCO1FBQ0FrQixJQUFJO1FBQ0pDLFFBQVFIO0lBQ1Y7QUFDQSxNQUFNSSxjQUFjLFNBQVVyRSxHQUFHLEVBQUVnRCxPQUFPO0lBQ3hDLElBQUlsQixVQUFVVyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNsRixPQUFPVixRQUFRTSxJQUFJLENBQUM7UUFBQ1osSUFBSXpCLEtBQUtnRDtRQUFVLElBQUlqQixRQUFRLENBQUNDLFVBQVVDO1lBQzdEQyxXQUFXO2dCQUNURCxPQUFPLElBQUlFLE1BQU07WUFDbkIsR0FBR0w7UUFDTDtLQUFHO0FBQ0w7QUFFeVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xb2duaXRhLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzL2Rpc3QvaHR0cEhlbHBlcnMuZXNtLmpzPzQ2MmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gubWVyZ2UnO1xuaW1wb3J0IGxvZ0xldmVsLCB7IGxldmVscyB9IGZyb20gJ2xvZ2xldmVsJztcblxuY29uc3QgbG9nID0gbG9nTGV2ZWwuZ2V0TG9nZ2VyKFwiaHR0cC1oZWxwZXJzXCIpO1xubG9nLnNldExldmVsKGxldmVscy5JTkZPKTtcbmxldCBhcGlLZXkgPSBcInRvcnVzLWRlZmF1bHRcIjtcbmxldCBlbWJlZEhvc3QgPSBcIlwiO1xuXG4vLyAjcmVnaW9uIEFQSSBLZXlzXG5jb25zdCBnYXRld2F5QXV0aEhlYWRlciA9IFwieC1hcGkta2V5XCI7XG5jb25zdCBnYXRld2F5RW1iZWRIb3N0SGVhZGVyID0gXCJ4LWVtYmVkLWhvc3RcIjtcbmxldCBzZW50cnkgPSBudWxsO1xuY29uc3QgdHJhY2luZ09yaWdpbnMgPSBbXTtcbmNvbnN0IHRyYWNpbmdQYXRocyA9IFtdO1xuZnVuY3Rpb24gZW5hYmxlU2VudHJ5VHJhY2luZyhfc2VudHJ5LCBfdHJhY2luZ09yaWdpbnMsIF90cmFjaW5nUGF0aHMpIHtcbiAgc2VudHJ5ID0gX3NlbnRyeTtcbiAgdHJhY2luZ09yaWdpbnMucHVzaCguLi5fdHJhY2luZ09yaWdpbnMpO1xuICB0cmFjaW5nUGF0aHMucHVzaCguLi5fdHJhY2luZ1BhdGhzKTtcbn1cbmZ1bmN0aW9uIHNldEVtYmVkSG9zdChlbWJlZEhvc3RfKSB7XG4gIGVtYmVkSG9zdCA9IGVtYmVkSG9zdF87XG59XG5mdW5jdGlvbiBjbGVhckVtYmVkSG9zdCgpIHtcbiAgZW1iZWRIb3N0ID0gXCJcIjtcbn1cbmZ1bmN0aW9uIGdldEVtYmVkSG9zdCgpIHtcbiAgcmV0dXJuIGVtYmVkSG9zdDtcbn1cbmZ1bmN0aW9uIHNldEFQSUtleShhcGlLZXlfKSB7XG4gIGFwaUtleSA9IGFwaUtleV87XG59XG5mdW5jdGlvbiBjbGVhckFQSUtleSgpIHtcbiAgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCI7XG59XG5mdW5jdGlvbiBnZXRBUElLZXkoKSB7XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbi8vICNlbmRyZWdpb25cblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgbG9nLnNldExldmVsKGxldmVsKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kVHJhY2UodXJsLCBpbml0KSB7XG4gIGxldCBfdXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBfdXJsID0gbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlcnJvcikge31cbiAgaWYgKHNlbnRyeSAmJiBfdXJsICYmICh0cmFjaW5nT3JpZ2lucy5pbmNsdWRlcyhfdXJsLm9yaWdpbikgfHwgdHJhY2luZ1BhdGhzLmluY2x1ZGVzKF91cmwucGF0aG5hbWUpKSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc2VudHJ5LnN0YXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgbmFtZTogdXJsXG4gICAgfSk7XG4gICAgY29uc3Qgc3BhbiA9IHRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgb3A6IFwiaHR0cFwiXG4gICAgfSk7IC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFNwYW5cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBpbml0KTtcbiAgICBzcGFuLmZpbmlzaCgpOyAvLyBSZW1lbWJlciB0aGF0IG9ubHkgZmluaXNoZWQgc3BhbnMgd2lsbCBiZSBzZW50IHdpdGggdGhlIHRyYW5zYWN0aW9uXG5cbiAgICB0cmFuc2FjdGlvbi5maW5pc2goKTsgLy8gRmluaXNoaW5nIHRoZSB0cmFuc2FjdGlvbiB3aWxsIHNlbmQgaXQgdG8gU2VudHJ5XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgcmV0dXJuIGZldGNoKHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlIZWFkZXJzKCkge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChhcGlLZXkpIGhlYWRlcnNbZ2F0ZXdheUF1dGhIZWFkZXJdID0gYXBpS2V5O1xuICBpZiAoZW1iZWRIb3N0KSBoZWFkZXJzW2dhdGV3YXlFbWJlZEhvc3RIZWFkZXJdID0gZW1iZWRIb3N0O1xuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgbG9nLmluZm8oYFJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICBsb2cuaW5mbyhgVXJsOiAke3Jlc3BvbnNlLnVybH1gKTtcbn1cbmZ1bmN0aW9uIGxvZ1RyYWNpbmdIZWFkZXIocmVzcG9uc2UpIHtcbiAgY29uc3QgdHJhY2luZ0hlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC13ZWIzLWNvcnJlbGF0aW9uLWlkXCIpO1xuICBpZiAodHJhY2luZ0hlYWRlcikgbG9nLmluZm8oYFJlcXVlc3QgdHJhY2luZyB3aXRoIHRyYWNlSUQgPSAke3RyYWNpbmdIZWFkZXJ9YCk7XG59XG5jb25zdCBwcm9taXNlVGltZW91dCA9IGFzeW5jIChtcywgcHJvbWlzZSkgPT4ge1xuICBsZXQgdGltZW91dEZ1bmMgPSBudWxsO1xuICB0cnkge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVGltZWQgb3V0IGluICR7bXN9bXNgKSk7XG4gICAgICB9LCBtcyk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lb3V0XSk7XG4gICAgLy8gcHJvbWlzZS5yYWNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCByZXNvbHZlZCBwcm9taXNlXG4gICAgLy8gdGhlbiB3ZSBjbGVhciB0aGUgdGltZW91dFxuICAgIGlmICh0aW1lb3V0RnVuYyAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dEZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBjbGVhciB0aGUgdGltZW91dFxuICAgIGlmICh0aW1lb3V0RnVuYyAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dEZ1bmMpO1xuICAgIH1cbiAgICAvLyByZXRocm93IHRoZSBvcmlnaW5hbCBlcnJvclxuICAgIHRocm93IGVycjtcbiAgfVxufTtcbmNvbnN0IGdldCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7fVxuICB9O1xuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcG9zdCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIlxuICB9KTtcblxuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2VUaW1lb3V0KGN1c3RvbU9wdGlvbnMudGltZW91dCB8fCA2MDAwMCwgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIGlmIChjdXN0b21PcHRpb25zLmxvZ1RyYWNpbmdIZWFkZXIpIHtcbiAgICAgIGxvZ1RyYWNpbmdIZWFkZXIocmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9XG4gICAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gICAgdGhyb3cgcmVzcG9uc2U7XG4gIH0pKTtcbn07XG5jb25zdCBwYXRjaCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIlBBVENIXCJcbiAgfSk7XG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcHV0ID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiUFVUXCJcbiAgfSk7XG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcmVtb3ZlID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgfSk7XG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBnZW5lcmF0ZUpzb25SUENPYmplY3QgPSAobWV0aG9kLCBwYXJhbWV0ZXJzKSA9PiAoe1xuICBqc29ucnBjOiBcIjIuMFwiLFxuICBtZXRob2QsXG4gIGlkOiAxMCxcbiAgcGFyYW1zOiBwYXJhbWV0ZXJzXG59KTtcbmNvbnN0IHByb21pc2VSYWNlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNjAwMDA7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW2dldCh1cmwsIG9wdGlvbnMpLCBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInRpbWVkIG91dFwiKSk7XG4gICAgfSwgdGltZW91dCk7XG4gIH0pXSk7XG59O1xuXG5leHBvcnQgeyBjbGVhckFQSUtleSwgY2xlYXJFbWJlZEhvc3QsIGVuYWJsZVNlbnRyeVRyYWNpbmcsIGdhdGV3YXlBdXRoSGVhZGVyLCBnYXRld2F5RW1iZWRIb3N0SGVhZGVyLCBnZW5lcmF0ZUpzb25SUENPYmplY3QsIGdldCwgZ2V0QVBJS2V5LCBnZXRFbWJlZEhvc3QsIHBhdGNoLCBwb3N0LCBwcm9taXNlUmFjZSwgcHJvbWlzZVRpbWVvdXQsIHB1dCwgcmVtb3ZlLCBzZXRBUElLZXksIHNldEVtYmVkSG9zdCwgc2V0TG9nTGV2ZWwgfTtcbiJdLCJuYW1lcyI6WyJfb2JqZWN0U3ByZWFkIiwibWVyZ2UiLCJsb2dMZXZlbCIsImxldmVscyIsImxvZyIsImdldExvZ2dlciIsInNldExldmVsIiwiSU5GTyIsImFwaUtleSIsImVtYmVkSG9zdCIsImdhdGV3YXlBdXRoSGVhZGVyIiwiZ2F0ZXdheUVtYmVkSG9zdEhlYWRlciIsInNlbnRyeSIsInRyYWNpbmdPcmlnaW5zIiwidHJhY2luZ1BhdGhzIiwiZW5hYmxlU2VudHJ5VHJhY2luZyIsIl9zZW50cnkiLCJfdHJhY2luZ09yaWdpbnMiLCJfdHJhY2luZ1BhdGhzIiwicHVzaCIsInNldEVtYmVkSG9zdCIsImVtYmVkSG9zdF8iLCJjbGVhckVtYmVkSG9zdCIsImdldEVtYmVkSG9zdCIsInNldEFQSUtleSIsImFwaUtleV8iLCJjbGVhckFQSUtleSIsImdldEFQSUtleSIsInNldExvZ0xldmVsIiwibGV2ZWwiLCJmZXRjaEFuZFRyYWNlIiwidXJsIiwiaW5pdCIsIl91cmwiLCJVUkwiLCJlcnJvciIsImluY2x1ZGVzIiwib3JpZ2luIiwicGF0aG5hbWUiLCJ0cmFuc2FjdGlvbiIsInN0YXJ0VHJhbnNhY3Rpb24iLCJuYW1lIiwic3BhbiIsInN0YXJ0Q2hpbGQiLCJvcCIsInJlc3BvbnNlIiwiZmV0Y2giLCJmaW5pc2giLCJnZXRBcGlLZXlIZWFkZXJzIiwiaGVhZGVycyIsImRlYnVnTG9nUmVzcG9uc2UiLCJpbmZvIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImxvZ1RyYWNpbmdIZWFkZXIiLCJ0cmFjaW5nSGVhZGVyIiwiZ2V0IiwicHJvbWlzZVRpbWVvdXQiLCJtcyIsInByb21pc2UiLCJ0aW1lb3V0RnVuYyIsInRpbWVvdXQiLCJQcm9taXNlIiwiX3Jlc29sdmUiLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJyZXN1bHQiLCJyYWNlIiwiY2xlYXJUaW1lb3V0IiwiZXJyIiwib3B0aW9uc18iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJjdXN0b21PcHRpb25zIiwiZGVmYXVsdE9wdGlvbnMiLCJtb2RlIiwidXNlQVBJS2V5Iiwib3B0aW9ucyIsIm1ldGhvZCIsIm9rIiwicmVzcG9uc2VDb250ZW50VHlwZSIsImpzb24iLCJ0ZXh0IiwicG9zdCIsImRhdGEiLCJpc1VybEVuY29kZWREYXRhIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0aGVuIiwicGF0Y2giLCJwdXQiLCJyZW1vdmUiLCJnZW5lcmF0ZUpzb25SUENPYmplY3QiLCJwYXJhbWV0ZXJzIiwianNvbnJwYyIsImlkIiwicGFyYW1zIiwicHJvbWlzZVJhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptData: () => (/* binding */ decryptData),\n/* harmony export */   \"default\": () => (/* binding */ MetadataStorageLayer),\n/* harmony export */   ec: () => (/* binding */ ec),\n/* harmony export */   encParamsBufToHex: () => (/* binding */ encParamsBufToHex),\n/* harmony export */   encParamsHexToBuf: () => (/* binding */ encParamsHexToBuf),\n/* harmony export */   encryptAndSetData: () => (/* binding */ encryptAndSetData),\n/* harmony export */   encryptData: () => (/* binding */ encryptData),\n/* harmony export */   getAndDecryptData: () => (/* binding */ getAndDecryptData),\n/* harmony export */   getDeviceShare: () => (/* binding */ getDeviceShare),\n/* harmony export */   getTorusShare: () => (/* binding */ getTorusShare),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   setDeviceShare: () => (/* binding */ setDeviceShare),\n/* harmony export */   setTorusShare: () => (/* binding */ setTorusShare)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json-stable-stringify */ \"(ssr)/./node_modules/json-stable-stringify/index.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/esm/keccak.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n\n\n\n\n\n\n\nfunction keccak256(a) {\n    return Buffer.from((0,ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__.keccak256)(a));\n}\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_4__.ec(\"secp256k1\");\nclass MetadataStorageLayer {\n    // ms\n    constructor(){\n        let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n        let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"metadataHost\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"serverTimeOffset\", void 0);\n        this.metadataHost = metadataHost;\n        this.serverTimeOffset = serverTimeOffset;\n    }\n    static setAPIKey(apiKey) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setAPIKey)(apiKey);\n    }\n    static setEmbedHost(embedHost) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setEmbedHost)(embedHost);\n    }\n    generateMetadataParams(message, privateKeyHex) {\n        var _sig$recoveryParam$to, _sig$recoveryParam;\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        const setData = {\n            data: message,\n            timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n        };\n        const sig = key.sign(keccak256(Buffer.from(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(setData), \"utf8\")));\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64),\n            set_data: setData,\n            signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : \"00\"), \"hex\").toString(\"base64\")\n        };\n    }\n    generatePubKeyParams(privateKeyHex) {\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64)\n        };\n    }\n    async setMetadata(data, namespace, options) {\n        const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, data), {}, {\n            namespace\n        }) : data;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/set`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n    async getMetadata(pubKey, namespace, options) {\n        const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, pubKey), {}, {\n            namespace\n        }) : pubKey;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/get`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n}\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n    return {\n        iv: Buffer.from(encParamsHex.iv, \"hex\"),\n        ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n        ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n        mac: Buffer.from(encParamsHex.mac, \"hex\")\n    };\n}\nfunction encParamsBufToHex(encParams) {\n    return {\n        iv: Buffer.from(encParams.iv).toString(\"hex\"),\n        ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n        ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n        mac: Buffer.from(encParams.mac).toString(\"hex\")\n    };\n}\nasync function encryptData(privKeyHex, d) {\n    const serializedDec = JSON.stringify(d);\n    const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n    const encParams = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)((0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.getPublic)(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n    const encParamsHex = encParamsBufToHex(encParams);\n    const sData = JSON.stringify(encParamsHex);\n    return sData;\n}\nasync function decryptData(privKeyHex, d) {\n    const encParamsHex = JSON.parse(d);\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(privKeyHex);\n    const serializedBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedDec = serializedBuf.toString(\"utf-8\");\n    const data = JSON.parse(serializedDec);\n    return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n    const keyPair = ec.keyFromPrivate(privKeyHex, \"hex\");\n    const pubKey = keyPair.getPublic();\n    const serializedData = await m.getMetadata({\n        pub_key_X: pubKey.getX().toString(16, 64),\n        pub_key_Y: pubKey.getY().toString(16, 64)\n    }, namespace);\n    if (!serializedData) {\n        return null;\n    }\n    const data = await decryptData(privKeyHex, serializedData);\n    return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n    const sData = await encryptData(privKeyHex, d);\n    const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n    await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n    const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = refKeyPair.getPrivate();\n    const pubKey = ec.keyFromPublic({\n        x: webAuthnPubKey.pub_key_X,\n        y: webAuthnPubKey.pub_key_Y\n    });\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    let d = {};\n    if (data) d = data;\n    const serializedSubspaceData = JSON.stringify(subspaceData);\n    const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n    const encSubspaceData = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n    const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n    d[subspace] = encSubspaceDataHex;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n    const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = keyPair.getPrivate();\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    let d = {};\n    if (data) d = data;\n    d[subspace] = subspaceData;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    if (!data) return null;\n    const encParamsHex = data[subspace];\n    if (!encParamsHex) return null;\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n    const privKey = keyPair.getPrivate();\n    const serializedSubspaceDataBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n    const subspaceData = JSON.parse(serializedSubspaceData);\n    return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    if (data) return data[subspace];\n    return null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzL2Rpc3QvbWV0YWRhdGFIZWxwZXJzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDRztBQUNJO0FBQzFCO0FBQ1I7QUFDa0M7QUFDTjtBQUVsRSxTQUFTUSxVQUFVSyxDQUFDO0lBQ2xCLE9BQU9DLE9BQU9DLElBQUksQ0FBQ04sdUVBQVdBLENBQUNJO0FBQ2pDO0FBQ0EsTUFBTVAsS0FBSyxJQUFJQyx3Q0FBSUEsQ0FBQztBQUVwQixNQUFNUztJQUNKLEtBQUs7SUFFTEMsYUFBYztRQUNaLElBQUlDLGVBQWVDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3ZGLElBQUlHLG1CQUFtQkgsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDM0ZsQiw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEtBQUs7UUFDM0NBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxvQkFBb0IsS0FBSztRQUMvQyxJQUFJLENBQUNpQixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUdBO0lBQzFCO0lBQ0EsT0FBT3BCLFVBQVVxQixNQUFNLEVBQUU7UUFDdkJyQixrRUFBU0EsQ0FBQ3FCO0lBQ1o7SUFDQSxPQUFPcEIsYUFBYXFCLFNBQVMsRUFBRTtRQUM3QnJCLHFFQUFZQSxDQUFDcUI7SUFDZjtJQUNBQyx1QkFBdUJDLE9BQU8sRUFBRUMsYUFBYSxFQUFFO1FBQzdDLElBQUlDLHVCQUF1QkM7UUFDM0IsTUFBTUMsTUFBTXhCLEdBQUd5QixjQUFjLENBQUNKLGVBQWU7UUFDN0MsTUFBTUssVUFBVTtZQUNkQyxNQUFNUDtZQUNOUSxXQUFXQyxLQUFLQyxLQUFLLENB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QUFNcUQsZUFBZWhCLEtBQUtJLEtBQUssQ0FBQ2tCO0lBQ2hDLE9BQU9OO0FBQ1Q7QUFDQSxlQUFlYSxlQUFlckIsQ0FBQyxFQUFFTSxjQUFjLEVBQUVDLFFBQVE7SUFDdkQsTUFBTTFELE9BQU8sTUFBTWtELGtCQUFrQkMsR0FBR00sZ0JBQWdCM0I7SUFDeEQsSUFBSTlCLE1BQU0sT0FBT0EsSUFBSSxDQUFDMEQsU0FBUztJQUMvQixPQUFPO0FBQ1Q7QUFFOE4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xb2duaXRhLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvbWV0YWRhdGEtaGVscGVycy9kaXN0L21ldGFkYXRhSGVscGVycy5lc20uanM/NDViNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IHNldEFQSUtleSwgc2V0RW1iZWRIb3N0LCBwb3N0IH0gZnJvbSAnQHRvcnVzbGFicy9odHRwLWhlbHBlcnMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdqc29uLXN0YWJsZS1zdHJpbmdpZnknO1xuaW1wb3J0IHsgZWMgYXMgZWMkMSB9IGZyb20gJ2VsbGlwdGljJztcbmltcG9ydCB7IGtlY2NhazI1NiBhcyBrZWNjYWsyNTYkMSB9IGZyb20gJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnO1xuaW1wb3J0IHsgZW5jcnlwdCwgZ2V0UHVibGljLCBkZWNyeXB0IH0gZnJvbSAnQHRvcnVzbGFicy9lY2NyeXB0byc7XG5cbmZ1bmN0aW9uIGtlY2NhazI1NihhKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShrZWNjYWsyNTYkMShhKSk7XG59XG5jb25zdCBlYyA9IG5ldyBlYyQxKFwic2VjcDI1NmsxXCIpO1xuXG5jbGFzcyBNZXRhZGF0YVN0b3JhZ2VMYXllciB7XG4gIC8vIG1zXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG1ldGFkYXRhSG9zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJodHRwczovL21ldGFkYXRhLnRvci51c1wiO1xuICAgIGxldCBzZXJ2ZXJUaW1lT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhSG9zdFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcnZlclRpbWVPZmZzZXRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLm1ldGFkYXRhSG9zdCA9IG1ldGFkYXRhSG9zdDtcbiAgICB0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBzZXJ2ZXJUaW1lT2Zmc2V0O1xuICB9XG4gIHN0YXRpYyBzZXRBUElLZXkoYXBpS2V5KSB7XG4gICAgc2V0QVBJS2V5KGFwaUtleSk7XG4gIH1cbiAgc3RhdGljIHNldEVtYmVkSG9zdChlbWJlZEhvc3QpIHtcbiAgICBzZXRFbWJlZEhvc3QoZW1iZWRIb3N0KTtcbiAgfVxuICBnZW5lcmF0ZU1ldGFkYXRhUGFyYW1zKG1lc3NhZ2UsIHByaXZhdGVLZXlIZXgpIHtcbiAgICB2YXIgX3NpZyRyZWNvdmVyeVBhcmFtJHRvLCBfc2lnJHJlY292ZXJ5UGFyYW07XG4gICAgY29uc3Qga2V5ID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUhleCwgXCJoZXhcIik7XG4gICAgY29uc3Qgc2V0RGF0YSA9IHtcbiAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICB0aW1lc3RhbXA6IE1hdGguZmxvb3IodGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ICsgRGF0ZS5ub3coKSAvIDEwMDApLnRvU3RyaW5nKDE2KVxuICAgIH07XG4gICAgY29uc3Qgc2lnID0ga2V5LnNpZ24oa2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHN0cmluZ2lmeShzZXREYXRhKSwgXCJ1dGY4XCIpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yl9rZXlfWDoga2V5LmdldFB1YmxpYygpLmdldFgoKS50b1N0cmluZygxNiwgNjQpLFxuICAgICAgcHViX2tleV9ZOiBrZXkuZ2V0UHVibGljKCkuZ2V0WSgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgICBzZXRfZGF0YTogc2V0RGF0YSxcbiAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnIudG9TdHJpbmcoMTYsIDY0KSArIHNpZy5zLnRvU3RyaW5nKDE2LCA2NCkgKyAoKF9zaWckcmVjb3ZlcnlQYXJhbSR0byA9IChfc2lnJHJlY292ZXJ5UGFyYW0gPSBzaWcucmVjb3ZlcnlQYXJhbSkgPT09IG51bGwgfHwgX3NpZyRyZWNvdmVyeVBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2lnJHJlY292ZXJ5UGFyYW0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKS5zbGljZSgtMikpICE9PSBudWxsICYmIF9zaWckcmVjb3ZlcnlQYXJhbSR0byAhPT0gdm9pZCAwID8gX3NpZyRyZWNvdmVyeVBhcmFtJHRvIDogXCIwMFwiKSwgXCJoZXhcIikudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICB9O1xuICB9XG4gIGdlbmVyYXRlUHViS2V5UGFyYW1zKHByaXZhdGVLZXlIZXgpIHtcbiAgICBjb25zdCBrZXkgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5SGV4LCBcImhleFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViX2tleV9YOiBrZXkuZ2V0UHVibGljKCkuZ2V0WCgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgICBwdWJfa2V5X1k6IGtleS5nZXRQdWJsaWMoKS5nZXRZKCkudG9TdHJpbmcoMTYsIDY0KVxuICAgIH07XG4gIH1cbiAgYXN5bmMgc2V0TWV0YWRhdGEoZGF0YSwgbmFtZXNwYWNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmFtZXNwYWNlICE9PSBudWxsID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkYXRhKSwge30sIHtcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pIDogZGF0YTtcbiAgICBjb25zdCBtZXRhZGF0YVJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLm1ldGFkYXRhSG9zdH0vc2V0YCwgcGFyYW1zLCBvcHRpb25zLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0YWRhdGFSZXNwb25zZS5tZXNzYWdlO1xuICB9XG4gIGFzeW5jIGdldE1ldGFkYXRhKHB1YktleSwgbmFtZXNwYWNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmFtZXNwYWNlICE9PSBudWxsID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwdWJLZXkpLCB7fSwge1xuICAgICAgbmFtZXNwYWNlXG4gICAgfSkgOiBwdWJLZXk7XG4gICAgY29uc3QgbWV0YWRhdGFSZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5tZXRhZGF0YUhvc3R9L2dldGAsIHBhcmFtcywgb3B0aW9ucywge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhUmVzcG9uc2UubWVzc2FnZTtcbiAgfVxufVxuXG5jb25zdCBXRUJBVVRITl9UT1JVU19TSEFSRSA9IFwid2ViYXV0aG5fdG9ydXNfc2hhcmVcIjtcbmNvbnN0IFdFQkFVVEhOX0RFVklDRV9TSEFSRSA9IFwid2ViYXV0aG5fZGV2aWNlX3NoYXJlXCI7XG5mdW5jdGlvbiBlbmNQYXJhbXNIZXhUb0J1ZihlbmNQYXJhbXNIZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpdjogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4Lml2LCBcImhleFwiKSxcbiAgICBlcGhlbVB1YmxpY0tleTogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4LmVwaGVtUHVibGljS2V5LCBcImhleFwiKSxcbiAgICBjaXBoZXJ0ZXh0OiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXguY2lwaGVydGV4dCwgXCJoZXhcIiksXG4gICAgbWFjOiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXgubWFjLCBcImhleFwiKVxuICB9O1xufVxuZnVuY3Rpb24gZW5jUGFyYW1zQnVmVG9IZXgoZW5jUGFyYW1zKSB7XG4gIHJldHVybiB7XG4gICAgaXY6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5pdikudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgZXBoZW1QdWJsaWNLZXk6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5lcGhlbVB1YmxpY0tleSkudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgY2lwaGVydGV4dDogQnVmZmVyLmZyb20oZW5jUGFyYW1zLmNpcGhlcnRleHQpLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIG1hYzogQnVmZmVyLmZyb20oZW5jUGFyYW1zLm1hYykudG9TdHJpbmcoXCJoZXhcIilcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHREYXRhKHByaXZLZXlIZXgsIGQpIHtcbiAgY29uc3Qgc2VyaWFsaXplZERlYyA9IEpTT04uc3RyaW5naWZ5KGQpO1xuICBjb25zdCBzZXJpYWxpemVkQnVmID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZERlYywgXCJ1dGYtOFwiKTtcbiAgY29uc3QgZW5jUGFyYW1zID0gYXdhaXQgZW5jcnlwdChnZXRQdWJsaWMoQnVmZmVyLmZyb20ocHJpdktleUhleCwgXCJoZXhcIikpLCBzZXJpYWxpemVkQnVmKTtcbiAgY29uc3QgZW5jUGFyYW1zSGV4ID0gZW5jUGFyYW1zQnVmVG9IZXgoZW5jUGFyYW1zKTtcbiAgY29uc3Qgc0RhdGEgPSBKU09OLnN0cmluZ2lmeShlbmNQYXJhbXNIZXgpO1xuICByZXR1cm4gc0RhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0RGF0YShwcml2S2V5SGV4LCBkKSB7XG4gIGNvbnN0IGVuY1BhcmFtc0hleCA9IEpTT04ucGFyc2UoZCk7XG4gIGNvbnN0IGVuY1BhcmFtcyA9IGVuY1BhcmFtc0hleFRvQnVmKGVuY1BhcmFtc0hleCk7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2S2V5SGV4KTtcbiAgY29uc3Qgc2VyaWFsaXplZEJ1ZiA9IGF3YWl0IGRlY3J5cHQoQnVmZmVyLmZyb20oa2V5UGFpci5nZXRQcml2YXRlKCkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBcImhleFwiKSwgZW5jUGFyYW1zKTtcbiAgY29uc3Qgc2VyaWFsaXplZERlYyA9IHNlcmlhbGl6ZWRCdWYudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZERlYyk7XG4gIHJldHVybiBkYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QW5kRGVjcnlwdERhdGEobSwgcHJpdktleUhleCwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2S2V5SGV4LCBcImhleFwiKTtcbiAgY29uc3QgcHViS2V5ID0ga2V5UGFpci5nZXRQdWJsaWMoKTtcbiAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBhd2FpdCBtLmdldE1ldGFkYXRhKHtcbiAgICBwdWJfa2V5X1g6IHB1YktleS5nZXRYKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICBwdWJfa2V5X1k6IHB1YktleS5nZXRZKCkudG9TdHJpbmcoMTYsIDY0KVxuICB9LCBuYW1lc3BhY2UpO1xuICBpZiAoIXNlcmlhbGl6ZWREYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGF3YWl0IGRlY3J5cHREYXRhKHByaXZLZXlIZXgsIHNlcmlhbGl6ZWREYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0QW5kU2V0RGF0YShtLCBwcml2S2V5SGV4LCBkLCBuYW1lc3BhY2UpIHtcbiAgY29uc3Qgc0RhdGEgPSBhd2FpdCBlbmNyeXB0RGF0YShwcml2S2V5SGV4LCBkKTtcbiAgY29uc3QgbWV0YWRhdGFQYXJhbXMgPSBtLmdlbmVyYXRlTWV0YWRhdGFQYXJhbXMoc0RhdGEsIHByaXZLZXlIZXgpO1xuICBhd2FpdCBtLnNldE1ldGFkYXRhKG1ldGFkYXRhUGFyYW1zLCBuYW1lc3BhY2UpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0VG9ydXNTaGFyZShtLCB3ZWJBdXRoblB1YktleSwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlLCBzdWJzcGFjZURhdGEpIHtcbiAgY29uc3QgcmVmS2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHdlYkF1dGhuUmVmSGV4KTtcbiAgY29uc3QgcHJpdktleSA9IHJlZktleVBhaXIuZ2V0UHJpdmF0ZSgpO1xuICBjb25zdCBwdWJLZXkgPSBlYy5rZXlGcm9tUHVibGljKHtcbiAgICB4OiB3ZWJBdXRoblB1YktleS5wdWJfa2V5X1gsXG4gICAgeTogd2ViQXV0aG5QdWJLZXkucHViX2tleV9ZXG4gIH0pO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0QW5kRGVjcnlwdERhdGEobSwgd2ViQXV0aG5SZWZIZXgsIFdFQkFVVEhOX1RPUlVTX1NIQVJFKTtcbiAgbGV0IGQgPSB7fTtcbiAgaWYgKGRhdGEpIGQgPSBkYXRhO1xuICBjb25zdCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhID0gSlNPTi5zdHJpbmdpZnkoc3Vic3BhY2VEYXRhKTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1ZiA9IEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWRTdWJzcGFjZURhdGEsIFwidXRmLThcIik7XG4gIGNvbnN0IGVuY1N1YnNwYWNlRGF0YSA9IGF3YWl0IGVuY3J5cHQoQnVmZmVyLmZyb20ocHViS2V5LmdldFB1YmxpYyhcImhleFwiKSwgXCJoZXhcIiksIHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYpO1xuICBjb25zdCBlbmNTdWJzcGFjZURhdGFIZXggPSBlbmNQYXJhbXNCdWZUb0hleChlbmNTdWJzcGFjZURhdGEpO1xuICBkW3N1YnNwYWNlXSA9IGVuY1N1YnNwYWNlRGF0YUhleDtcbiAgYXdhaXQgZW5jcnlwdEFuZFNldERhdGEobSwgcHJpdktleS50b1N0cmluZyhcImhleFwiLCA2NCksIGQsIFdFQkFVVEhOX1RPUlVTX1NIQVJFKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldERldmljZVNoYXJlKG0sIHdlYkF1dGhuUmVmSGV4LCBzdWJzcGFjZSwgc3Vic3BhY2VEYXRhKSB7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZSh3ZWJBdXRoblJlZkhleCk7XG4gIGNvbnN0IHByaXZLZXkgPSBrZXlQYWlyLmdldFByaXZhdGUoKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9ERVZJQ0VfU0hBUkUpO1xuICBsZXQgZCA9IHt9O1xuICBpZiAoZGF0YSkgZCA9IGRhdGE7XG4gIGRbc3Vic3BhY2VdID0gc3Vic3BhY2VEYXRhO1xuICBhd2FpdCBlbmNyeXB0QW5kU2V0RGF0YShtLCBwcml2S2V5LnRvU3RyaW5nKFwiaGV4XCIsIDY0KSwgZCwgV0VCQVVUSE5fREVWSUNFX1NIQVJFKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFRvcnVzU2hhcmUobSwgd2ViQXV0aG5LZXlIZXgsIHdlYkF1dGhuUmVmSGV4LCBzdWJzcGFjZSkge1xuICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0QW5kRGVjcnlwdERhdGEobSwgd2ViQXV0aG5SZWZIZXgsIFdFQkFVVEhOX1RPUlVTX1NIQVJFKTtcbiAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgZW5jUGFyYW1zSGV4ID0gZGF0YVtzdWJzcGFjZV07XG4gIGlmICghZW5jUGFyYW1zSGV4KSByZXR1cm4gbnVsbDtcbiAgY29uc3QgZW5jUGFyYW1zID0gZW5jUGFyYW1zSGV4VG9CdWYoZW5jUGFyYW1zSGV4KTtcbiAgY29uc3Qga2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHdlYkF1dGhuS2V5SGV4KTtcbiAgY29uc3QgcHJpdktleSA9IGtleVBhaXIuZ2V0UHJpdmF0ZSgpO1xuICBjb25zdCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmID0gYXdhaXQgZGVjcnlwdChCdWZmZXIuZnJvbShwcml2S2V5LnRvU3RyaW5nKFwiaGV4XCIsIDY0KSwgXCJoZXhcIiksIGVuY1BhcmFtcyk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGEgPSBzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmLnRvU3RyaW5nKFwidXRmLThcIik7XG4gIGNvbnN0IHN1YnNwYWNlRGF0YSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZFN1YnNwYWNlRGF0YSk7XG4gIHJldHVybiBzdWJzcGFjZURhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBnZXREZXZpY2VTaGFyZShtLCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UpIHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9ERVZJQ0VfU0hBUkUpO1xuICBpZiAoZGF0YSkgcmV0dXJuIGRhdGFbc3Vic3BhY2VdO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgZGVjcnlwdERhdGEsIE1ldGFkYXRhU3RvcmFnZUxheWVyIGFzIGRlZmF1bHQsIGVjLCBlbmNQYXJhbXNCdWZUb0hleCwgZW5jUGFyYW1zSGV4VG9CdWYsIGVuY3J5cHRBbmRTZXREYXRhLCBlbmNyeXB0RGF0YSwgZ2V0QW5kRGVjcnlwdERhdGEsIGdldERldmljZVNoYXJlLCBnZXRUb3J1c1NoYXJlLCBrZWNjYWsyNTYsIHNldERldmljZVNoYXJlLCBzZXRUb3J1c1NoYXJlIH07XG4iXSwibmFtZXMiOlsiX29iamVjdFNwcmVhZCIsIl9kZWZpbmVQcm9wZXJ0eSIsInNldEFQSUtleSIsInNldEVtYmVkSG9zdCIsInBvc3QiLCJzdHJpbmdpZnkiLCJlYyIsImVjJDEiLCJrZWNjYWsyNTYiLCJrZWNjYWsyNTYkMSIsImVuY3J5cHQiLCJnZXRQdWJsaWMiLCJkZWNyeXB0IiwiYSIsIkJ1ZmZlciIsImZyb20iLCJNZXRhZGF0YVN0b3JhZ2VMYXllciIsImNvbnN0cnVjdG9yIiwibWV0YWRhdGFIb3N0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwic2VydmVyVGltZU9mZnNldCIsImFwaUtleSIsImVtYmVkSG9zdCIsImdlbmVyYXRlTWV0YWRhdGFQYXJhbXMiLCJtZXNzYWdlIiwicHJpdmF0ZUtleUhleCIsIl9zaWckcmVjb3ZlcnlQYXJhbSR0byIsIl9zaWckcmVjb3ZlcnlQYXJhbSIsImtleSIsImtleUZyb21Qcml2YXRlIiwic2V0RGF0YSIsImRhdGEiLCJ0aW1lc3RhbXAiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJzaWciLCJzaWduIiwicHViX2tleV9YIiwiZ2V0WCIsInB1Yl9rZXlfWSIsImdldFkiLCJzZXRfZGF0YSIsInNpZ25hdHVyZSIsInIiLCJzIiwicmVjb3ZlcnlQYXJhbSIsInBhZFN0YXJ0Iiwic2xpY2UiLCJnZW5lcmF0ZVB1YktleVBhcmFtcyIsInNldE1ldGFkYXRhIiwibmFtZXNwYWNlIiwib3B0aW9ucyIsInBhcmFtcyIsIm1ldGFkYXRhUmVzcG9uc2UiLCJ1c2VBUElLZXkiLCJnZXRNZXRhZGF0YSIsInB1YktleSIsIldFQkFVVEhOX1RPUlVTX1NIQVJFIiwiV0VCQVVUSE5fREVWSUNFX1NIQVJFIiwiZW5jUGFyYW1zSGV4VG9CdWYiLCJlbmNQYXJhbXNIZXgiLCJpdiIsImVwaGVtUHVibGljS2V5IiwiY2lwaGVydGV4dCIsIm1hYyIsImVuY1BhcmFtc0J1ZlRvSGV4IiwiZW5jUGFyYW1zIiwiZW5jcnlwdERhdGEiLCJwcml2S2V5SGV4IiwiZCIsInNlcmlhbGl6ZWREZWMiLCJKU09OIiwic2VyaWFsaXplZEJ1ZiIsInNEYXRhIiwiZGVjcnlwdERhdGEiLCJwYXJzZSIsImtleVBhaXIiLCJnZXRQcml2YXRlIiwiZ2V0QW5kRGVjcnlwdERhdGEiLCJtIiwic2VyaWFsaXplZERhdGEiLCJlbmNyeXB0QW5kU2V0RGF0YSIsIm1ldGFkYXRhUGFyYW1zIiwic2V0VG9ydXNTaGFyZSIsIndlYkF1dGhuUHViS2V5Iiwid2ViQXV0aG5SZWZIZXgiLCJzdWJzcGFjZSIsInN1YnNwYWNlRGF0YSIsInJlZktleVBhaXIiLCJwcml2S2V5Iiwia2V5RnJvbVB1YmxpYyIsIngiLCJ5Iiwic2VyaWFsaXplZFN1YnNwYWNlRGF0YSIsInNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYiLCJlbmNTdWJzcGFjZURhdGEiLCJlbmNTdWJzcGFjZURhdGFIZXgiLCJzZXREZXZpY2VTaGFyZSIsImdldFRvcnVzU2hhcmUiLCJ3ZWJBdXRobktleUhleCIsImdldERldmljZVNoYXJlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePostMessageStream: () => (/* binding */ BasePostMessageStream),\n/* harmony export */   EthereumProviderError: () => (/* binding */ EthereumProviderError),\n/* harmony export */   IGNORE_SUBSTREAM: () => (/* binding */ IGNORE_SUBSTREAM),\n/* harmony export */   JRPCEngine: () => (/* binding */ JRPCEngine),\n/* harmony export */   JSON_RPC_SERVER_ERROR_MESSAGE: () => (/* binding */ JSON_RPC_SERVER_ERROR_MESSAGE),\n/* harmony export */   JsonRpcError: () => (/* binding */ JsonRpcError),\n/* harmony export */   ObjectMultiplex: () => (/* binding */ ObjectMultiplex),\n/* harmony export */   PostMessageStream: () => (/* binding */ PostMessageStream),\n/* harmony export */   SafeEventEmitter: () => (/* binding */ SafeEventEmitter),\n/* harmony export */   SerializableError: () => (/* binding */ SerializableError),\n/* harmony export */   Substream: () => (/* binding */ Substream),\n/* harmony export */   createAsyncMiddleware: () => (/* binding */ createAsyncMiddleware),\n/* harmony export */   createEngineStream: () => (/* binding */ createEngineStream),\n/* harmony export */   createErrorMiddleware: () => (/* binding */ createErrorMiddleware),\n/* harmony export */   createIdRemapMiddleware: () => (/* binding */ createIdRemapMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createScaffoldMiddleware: () => (/* binding */ createScaffoldMiddleware),\n/* harmony export */   createStreamMiddleware: () => (/* binding */ createStreamMiddleware),\n/* harmony export */   dataHasCause: () => (/* binding */ dataHasCause),\n/* harmony export */   errorCodes: () => (/* binding */ errorCodes),\n/* harmony export */   errorValues: () => (/* binding */ errorValues),\n/* harmony export */   getMessageFromCode: () => (/* binding */ getMessageFromCode),\n/* harmony export */   getRpcPromiseCallback: () => (/* binding */ getRpcPromiseCallback),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isValidCode: () => (/* binding */ isValidCode),\n/* harmony export */   isValidString: () => (/* binding */ isValidString),\n/* harmony export */   mergeMiddleware: () => (/* binding */ mergeMiddleware),\n/* harmony export */   providerAsMiddleware: () => (/* binding */ providerAsMiddleware),\n/* harmony export */   providerErrors: () => (/* binding */ providerErrors),\n/* harmony export */   providerFromEngine: () => (/* binding */ providerFromEngine),\n/* harmony export */   providerFromMiddleware: () => (/* binding */ providerFromMiddleware),\n/* harmony export */   rpcErrors: () => (/* binding */ rpcErrors),\n/* harmony export */   serializeCause: () => (/* binding */ serializeCause),\n/* harmony export */   serializeError: () => (/* binding */ serializeError),\n/* harmony export */   setupMultiplex: () => (/* binding */ setupMultiplex)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/lib/ours/index.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readable_stream__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/./node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! end-of-stream */ \"(ssr)/./node_modules/end-of-stream/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! once */ \"(ssr)/./node_modules/once/once.js\");\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\nfunction noop() {\n    return undefined;\n}\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { name, target, targetWindow = window, targetOrigin = \"*\" } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_init\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_haveSyn\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetOrigin\", void 0);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_onMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_synIntervalId\", void 0);\n        if (!name || !target) {\n            throw new Error(\"Invalid input.\");\n        }\n        this._init = false;\n        this._haveSyn = false;\n        this._name = name;\n        this._target = target; // target origin\n        this._targetWindow = targetWindow;\n        this._targetOrigin = targetOrigin;\n        this._onMessage = this.onMessage.bind(this);\n        this._synIntervalId = null;\n        window.addEventListener(\"message\", this._onMessage, false);\n        this._handShake();\n    }\n    _break() {\n        this.cork();\n        this._write(BRK, null, noop);\n        this._haveSyn = false;\n        this._init = false;\n    }\n    _handShake() {\n        this._write(SYN, null, noop);\n        this.cork();\n    }\n    _onData(data) {\n        if (!this._init) {\n            // listen for handshake\n            if (data === SYN) {\n                this._haveSyn = true;\n                this._write(ACK, null, noop);\n            } else if (data === ACK) {\n                this._init = true;\n                if (!this._haveSyn) {\n                    this._write(ACK, null, noop);\n                }\n                this.uncork();\n            }\n        } else if (data === BRK) {\n            this._break();\n        } else {\n            // forward message\n            try {\n                this.push(data);\n            } catch (err) {\n                this.emit(\"error\", err);\n            }\n        }\n    }\n    _postMessage(data) {\n        const originConstraint = this._targetOrigin;\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n    onMessage(event) {\n        const message = event.data;\n        // validate message\n        if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n            return;\n        }\n        this._onData(message.data);\n    }\n    _read() {\n        return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _write(data, _, cb) {\n        this._postMessage(data);\n        cb();\n    }\n    _destroy() {\n        window.removeEventListener(\"message\", this._onMessage, false);\n    }\n}\nconst errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\nconst errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\nconst FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nconst JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */ function isValidCode(code) {\n    return Number.isInteger(code);\n}\nfunction isValidString(value) {\n    return typeof value === \"string\" && value.length > 0;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */ function isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */ function isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */ function isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n}\nfunction isJsonRpcError(value) {\n    const castValue = value;\n    if (!castValue) return false;\n    if (!isValidCode(castValue.code) || !isValidString(castValue.message)) return false;\n    if (castValue.stack && !isValidString(castValue.stack)) return false;\n    return true;\n}\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */ function getMessageFromCode(code) {\n    let fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n    if (isValidCode(code)) {\n        const codeString = code.toString();\n        if (Object.hasOwn(errorValues, codeString)) {\n            return errorValues[codeString].message;\n        }\n        if (isJsonRpcServerError(code)) {\n            return JSON_RPC_SERVER_ERROR_MESSAGE;\n        }\n    }\n    return fallbackMessage;\n}\nconst FALLBACK_ERROR = {\n    code: FALLBACK_ERROR_CODE,\n    message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nfunction isValidJson(str) {\n    try {\n        JSON.parse(JSON.stringify(str, (strKey, strVal)=>{\n            if (strKey === \"__proto__\" || strKey === \"constructor\") {\n                throw new Error(\"Not valid json\");\n            }\n            if (typeof strVal === \"function\" || typeof strVal === \"symbol\") {\n                throw new Error(\"Not valid json\");\n            }\n            return strVal;\n        }), (propKey, propValue)=>{\n            // Strip __proto__ and constructor properties to prevent prototype pollution.\n            if (propKey === \"__proto__\" || propKey === \"constructor\") {\n                return undefined;\n            }\n            return propValue;\n        });\n    // this means, it's a valid json so far\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */ function serializeObject(object) {\n    return Object.getOwnPropertyNames(object).reduce((acc, key)=>{\n        const value = object[key];\n        if (isValidJson(value)) {\n            acc[key] = value;\n        }\n        return acc;\n    }, {});\n}\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */ function serializeCause(error) {\n    if (Array.isArray(error)) {\n        return error.map((entry)=>{\n            if (isValidJson(entry)) {\n                return entry;\n            } else if (isObject(entry)) {\n                return serializeObject(entry);\n            }\n            return null;\n        });\n    } else if (isObject(error)) {\n        return serializeObject(error);\n    }\n    if (isValidJson(error)) {\n        return error;\n    }\n    return null;\n}\n/**\n * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON serializable fallback error.\n * @returns A JSON serializable error object.\n */ function buildError(error, fallbackError) {\n    // If an error specifies a `serialize` function, we call it and return the result.\n    if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n        return error.serialize();\n    }\n    if (isJsonRpcError(error)) {\n        return error;\n    }\n    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n    const cause = serializeCause(error);\n    const fallbackWithCause = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, fallbackError), {}, {\n        data: {\n            cause\n        }\n    });\n    return fallbackWithCause;\n}\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @returns The serialized error.\n */ function serializeError(error) {\n    let { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isJsonRpcError(fallbackError)) {\n        throw new Error(\"Must provide fallback error with integer number code and string message.\");\n    }\n    const serialized = buildError(error, fallbackError);\n    if (!shouldIncludeStack) {\n        delete serialized.stack;\n    }\n    return serialized;\n}\n/**\n * Returns true if supplied error data has a usable `cause` property; false otherwise.\n *\n * @param data - Optional data to validate.\n * @returns Whether cause property is present and an object.\n */ function dataHasCause(data) {\n    return isObject(data) && Object.hasOwn(data, \"cause\") && isObject(data.cause);\n}\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */ function isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */ function stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n}\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */ class JsonRpcError extends Error {\n    constructor(code, message, data){\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a non-empty string.');\n        }\n        if (dataHasCause(data)) {\n            super(message, {\n                cause: data.cause\n            });\n            // Browser backwards-compatibility fallback\n            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n            if (!Object.hasOwn(this, \"cause\")) {\n                Object.assign(this, {\n                    cause: data.cause\n                });\n            }\n        } else {\n            super(message);\n            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        }\n        if (data !== undefined) {\n            this.data = data;\n        }\n        this.code = code;\n        this.cause = data === null || data === void 0 ? void 0 : data.cause;\n    }\n    /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */ serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message\n        };\n        if (this.data !== undefined) {\n            // `this.data` is not guaranteed to be a plain object, but this simplifies\n            // the type guard below. We can safely cast it because we know it's a\n            // JSON-serializable value.\n            serialized.data = this.data;\n            if (isPlainObject(this.data)) {\n                serialized.data.cause = serializeCause(this.data.cause);\n            }\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */ toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()(this.serialize(), stringifyReplacer, 2);\n    }\n}\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ class EthereumProviderError extends JsonRpcError {\n    /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */ constructor(code, message, data){\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        super(code, message, data);\n    }\n}\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */ function parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n            const { message, data } = arg;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message !== null && message !== void 0 ? message : undefined,\n                data\n            ];\n        }\n    }\n    return [];\n}\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */ function getJsonRpcError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new JsonRpcError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */ function getEthProviderError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new EthereumProviderError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\nconst rpcErrors = {\n    /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ parse: (arg)=>getJsonRpcError(errorCodes.rpc.parse, arg),\n    /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidRequest: (arg)=>getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n    /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidParams: (arg)=>getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n    /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ methodNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n    /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ internal: (arg)=>getJsonRpcError(errorCodes.rpc.internal, arg),\n    /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ server: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n        }\n        const { code } = opts;\n        if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n            throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n        }\n        return getJsonRpcError(code, opts);\n    },\n    /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidInput: (arg)=>getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n    /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ resourceNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n    /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ resourceUnavailable: (arg)=>getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n    /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ transactionRejected: (arg)=>getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n    /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ methodNotSupported: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n    /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ limitExceeded: (arg)=>getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nconst providerErrors = {\n    /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ userRejectedRequest: (arg)=>{\n        return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n    },\n    /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ unauthorized: (arg)=>{\n        return getEthProviderError(errorCodes.provider.unauthorized, arg);\n    },\n    /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ unsupportedMethod: (arg)=>{\n        return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n    },\n    /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ disconnected: (arg)=>{\n        return getEthProviderError(errorCodes.provider.disconnected, arg);\n    },\n    /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ chainDisconnected: (arg)=>{\n        return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n    },\n    /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ custom: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n        }\n        const { code, message, data } = opts;\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        return new EthereumProviderError(code, message, data);\n    }\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */ function safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    } catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(()=>{\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for(let i = 0; i < n; i += 1){\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter {\n    emit(type) {\n        let doError = type === \"error\";\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        } else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === \"function\") {\n            safeApply(handler, this, args);\n        } else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for(let i = 0; i < len; i += 1){\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nclass SerializableError extends Error {\n    constructor(_ref){\n        let { code, message, data } = _ref;\n        if (!Number.isInteger(code)) {\n            throw new Error(\"code must be an integer\");\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error(\"message must be string\");\n        }\n        super(message);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        this.code = code;\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n    toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()({\n            code: this.code,\n            message: this.message,\n            data: this.data,\n            stack: this.stack\n        });\n    }\n}\nconst getRpcPromiseCallback = function(resolve, reject) {\n    let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return (error, response)=>{\n        if (error || response.error) {\n            reject(error || response.error);\n        } else if (!unwrapResult || Array.isArray(response)) {\n            resolve(response);\n        } else {\n            resolve(response.result);\n        }\n    };\n};\nfunction createErrorMiddleware(log) {\n    return (req, res, next, end)=>{\n        try {\n            // json-rpc-engine will terminate the request when it notices this error\n            if (typeof req.method !== \"string\" || !req.method) {\n                res.error = new SerializableError({\n                    code: -32603,\n                    message: \"invalid method\"\n                });\n                end();\n                return;\n            }\n            next((done)=>{\n                const { error } = res;\n                if (!error) {\n                    return done();\n                }\n                log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n                return done();\n            });\n        } catch (error) {\n            log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n            res.error = new SerializableError({\n                code: -32603,\n                message: error.message\n            });\n            end();\n        }\n    };\n}\nfunction createStreamMiddleware() {\n    const idMap = {};\n    function readNoop() {\n        return false;\n    }\n    const events = new SafeEventEmitter();\n    function processResponse(res) {\n        const context = idMap[res.id];\n        if (!context) {\n            throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n        }\n        delete idMap[res.id];\n        // copy whole res onto original res\n        Object.assign(context.res, res);\n        // run callback on empty stack,\n        // prevent internal stream-handler from catching errors\n        setTimeout(context.end);\n    }\n    function processNotification(res) {\n        events.emit(\"notification\", res);\n    }\n    function processMessage(res, _encoding, cb) {\n        let err;\n        try {\n            const isNotification = !res.id;\n            if (isNotification) {\n                processNotification(res);\n            } else {\n                processResponse(res);\n            }\n        } catch (_err) {\n            err = _err;\n        }\n        // continue processing stream\n        cb(err);\n    }\n    const stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read: readNoop,\n        write: processMessage\n    });\n    const middleware = (req, res, next, end)=>{\n        // write req to stream\n        stream.push(req);\n        // register request on id map\n        idMap[req.id] = {\n            req,\n            res,\n            next,\n            end\n        };\n    };\n    return {\n        events,\n        middleware,\n        stream\n    };\n}\nfunction createScaffoldMiddleware(handlers) {\n    return (req, res, next, end)=>{\n        const handler = handlers[req.method];\n        // if no handler, return\n        if (handler === undefined) {\n            return next();\n        }\n        // if handler is fn, call as middleware\n        if (typeof handler === \"function\") {\n            return handler(req, res, next, end);\n        }\n        // if handler is some other value, use as result\n        res.result = handler;\n        return end();\n    };\n}\nfunction createIdRemapMiddleware() {\n    return (req, res, next, _end)=>{\n        const originalId = req.id;\n        const newId = Math.random().toString(36).slice(2);\n        req.id = newId;\n        res.id = newId;\n        next((done)=>{\n            req.id = originalId;\n            res.id = originalId;\n            done();\n        });\n    };\n}\nfunction createLoggerMiddleware(logger) {\n    return (req, res, next, _)=>{\n        logger.debug(\"REQ\", req, \"RES\", res);\n        next();\n    };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n    return async (req, res, next, end)=>{\n        // nextPromise is the key to the implementation\n        // it is resolved by the return handler passed to the\n        // \"next\" function\n        let resolveNextPromise;\n        const nextPromise = new Promise((resolve)=>{\n            resolveNextPromise = resolve;\n        });\n        let returnHandlerCallback = null;\n        let nextWasCalled = false;\n        // This will be called by the consumer's async middleware.\n        const asyncNext = async ()=>{\n            nextWasCalled = true;\n            // We pass a return handler to next(). When it is called by the engine,\n            // the consumer's async middleware will resume executing.\n            next((runReturnHandlersCallback)=>{\n                // This callback comes from JRPCEngine._runReturnHandlers\n                returnHandlerCallback = runReturnHandlersCallback;\n                resolveNextPromise();\n            });\n            await nextPromise;\n        };\n        try {\n            await asyncMiddleware(req, res, asyncNext);\n            if (nextWasCalled) {\n                await nextPromise; // we must wait until the return handler is called\n                returnHandlerCallback(null);\n            } else {\n                end(null);\n            }\n        } catch (err) {\n            const error = err;\n            if (returnHandlerCallback) {\n                returnHandlerCallback(error);\n            } else {\n                end(error);\n            }\n        }\n    };\n}\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */ class JRPCEngine extends SafeEventEmitter {\n    constructor(){\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_middleware\", void 0);\n        this._middleware = [];\n    }\n    /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */ static async _runAllMiddleware(req, res, middlewareStack) {\n        const returnHandlers = [];\n        let error = null;\n        let isComplete = false;\n        // Go down stack of middleware, call and collect optional returnHandlers\n        for (const middleware of middlewareStack){\n            [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n            if (isComplete) {\n                break;\n            }\n        }\n        return [\n            error,\n            isComplete,\n            returnHandlers.reverse()\n        ];\n    }\n    /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * and a boolean indicating whether the request should end.\n   */ static _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise((resolve)=>{\n            const end = (err)=>{\n                const error = err || res.error;\n                if (error) {\n                    if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n                    res.error = serializeError(error, {\n                        shouldIncludeStack: true,\n                        fallbackError: {\n                            message: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()),\n                            code: (error === null || error === void 0 ? void 0 : error.code) || -32603,\n                            stack: (error === null || error === void 0 ? void 0 : error.stack) || \"Stack trace is not available.\",\n                            data: (error === null || error === void 0 ? void 0 : error.data) || (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString())\n                        }\n                    });\n                }\n                // True indicates that the request should end\n                resolve([\n                    error,\n                    true\n                ]);\n            };\n            const next = (returnHandler)=>{\n                if (res.error) {\n                    end(res.error);\n                } else {\n                    if (returnHandler) {\n                        if (typeof returnHandler !== \"function\") {\n                            end(new SerializableError({\n                                code: -32603,\n                                message: \"JRPCEngine: 'next' return handlers must be functions\"\n                            }));\n                        }\n                        returnHandlers.push(returnHandler);\n                    }\n                    // False indicates that the request should not end\n                    resolve([\n                        null,\n                        false\n                    ]);\n                }\n            };\n            try {\n                middleware(req, res, next, end);\n            } catch (error) {\n                end(error);\n            }\n        });\n    }\n    /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */ static async _runReturnHandlers(handlers) {\n        for (const handler of handlers){\n            await new Promise((resolve, reject)=>{\n                handler((err)=>err ? reject(err) : resolve());\n            });\n        }\n    }\n    /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */ static _checkForCompletion(_req, res, isComplete) {\n        if (!(\"result\" in res) && !(\"error\" in res)) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Response has no error or result for request\"\n            });\n        }\n        if (!isComplete) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Nothing ended request\"\n            });\n        }\n    }\n    /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */ push(middleware) {\n        this._middleware.push(middleware);\n    }\n    /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @param callback - An error-first callback that will receive the response.\n   */ /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @param callback - An error-first callback that will receive the array of\n   * responses.\n   */ /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @returns A promise that resolves with the response, or rejects with an\n   * error.\n   */ /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @returns A promise that resolves with the array of responses, or rejects\n   * with an error.\n   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handle(req, cb) {\n        if (cb && typeof cb !== \"function\") {\n            throw new Error('\"callback\" must be a function if provided.');\n        }\n        if (Array.isArray(req)) {\n            if (cb) {\n                return this._handleBatch(req, cb);\n            }\n            return this._handleBatch(req);\n        }\n        if (cb) {\n            return this._handle(req, cb);\n        }\n        return this._promiseHandle(req);\n    }\n    /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */ asMiddleware() {\n        return async (req, res, next, end)=>{\n            try {\n                const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n                if (isComplete) {\n                    await JRPCEngine._runReturnHandlers(returnHandlers);\n                    return end(middlewareError);\n                }\n                return next(async (handlerCallback)=>{\n                    try {\n                        await JRPCEngine._runReturnHandlers(returnHandlers);\n                    } catch (error) {\n                        return handlerCallback(error);\n                    }\n                    return handlerCallback();\n                });\n            } catch (error) {\n                return end(error);\n            }\n        };\n    }\n    /**\n   * Like _handle, but for batch requests.\n   */ /**\n   * Like _handle, but for batch requests.\n   */ async _handleBatch(reqs, cb) {\n        // The order here is important\n        try {\n            // 2. Wait for all requests to finish, or throw on some kind of fatal\n            // error\n            const responses = await Promise.all(// 1. Begin executing each request in the order received\n            reqs.map(this._promiseHandle.bind(this)));\n            // 3. Return batch response\n            if (cb) {\n                return cb(null, responses);\n            }\n            return responses;\n        } catch (error) {\n            if (cb) {\n                return cb(error);\n            }\n            throw error;\n        }\n    }\n    /**\n   * A promise-wrapped _handle.\n   */ _promiseHandle(req) {\n        return new Promise((resolve, reject)=>{\n            this._handle(req, (_err, res)=>{\n                // There will always be a response, and it will always have any error\n                // that is caught and propagated.\n                if (_err && res === undefined) {\n                    reject(_err);\n                } else resolve(res);\n            }).catch(reject);\n        });\n    }\n    /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */ async _handle(callerReq, cb) {\n        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"request must be plain object\"\n            });\n            return cb(error, {\n                id: undefined,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        if (typeof callerReq.method !== \"string\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"method must be string\"\n            });\n            return cb(error, {\n                id: callerReq.id,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, callerReq);\n        const res = {\n            id: req.id,\n            jsonrpc: req.jsonrpc\n        };\n        let error = null;\n        try {\n            await this._processRequest(req, res);\n        } catch (_error) {\n            // A request handler error, a re-thrown middleware error, or something\n            // unexpected.\n            error = _error;\n        }\n        if (error) {\n            // Ensure no result is present on an errored response\n            delete res.result;\n            if (!res.error) {\n                var _error2, _error3, _error4, _error5, _error6, _error7, _error8;\n                if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n                res.error = serializeError(error, {\n                    shouldIncludeStack: true,\n                    fallbackError: {\n                        message: ((_error2 = error) === null || _error2 === void 0 ? void 0 : _error2.message) || ((_error3 = error) === null || _error3 === void 0 ? void 0 : _error3.toString()),\n                        code: ((_error4 = error) === null || _error4 === void 0 ? void 0 : _error4.code) || -32603,\n                        stack: ((_error5 = error) === null || _error5 === void 0 ? void 0 : _error5.stack) || \"Stack trace is not available.\",\n                        data: ((_error6 = error) === null || _error6 === void 0 ? void 0 : _error6.data) || ((_error7 = error) === null || _error7 === void 0 ? void 0 : _error7.message) || ((_error8 = error) === null || _error8 === void 0 ? void 0 : _error8.toString())\n                    }\n                });\n            }\n        }\n        return cb(error, res);\n    }\n    /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */ async _processRequest(req, res) {\n        const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n        // Throw if \"end\" was not called, or if the response has neither a result\n        // nor an error.\n        JRPCEngine._checkForCompletion(req, res, isComplete);\n        // The return handlers should run even if an error was encountered during\n        // middleware processing.\n        await JRPCEngine._runReturnHandlers(returnHandlers);\n        // Now we re-throw the middleware processing error, if any, to catch it\n        // further up the call chain.\n        if (error) {\n            throw error;\n        }\n    }\n}\nfunction mergeMiddleware(middlewareStack) {\n    const engine = new JRPCEngine();\n    middlewareStack.forEach((middleware)=>engine.push(middleware));\n    return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n    if (!opts || !opts.engine) {\n        throw new Error(\"Missing engine parameter!\");\n    }\n    const { engine } = opts;\n    // eslint-disable-next-line prefer-const\n    let stream;\n    function read() {\n        return undefined;\n    }\n    function write(req, _encoding, cb) {\n        engine.handle(req, (_err, res)=>{\n            stream.push(res);\n        });\n        cb();\n    }\n    stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read,\n        write\n    });\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            stream.push(message);\n        });\n    }\n    return stream;\n}\nfunction providerFromEngine(engine) {\n    const provider = new SafeEventEmitter();\n    // handle both rpc send methods\n    provider.sendAsync = async (req)=>{\n        const res = await engine.handle(req);\n        if (res.error) {\n            var _res$error, _res$error2, _res$error3, _res$error4, _res$error5, _res$error6, _res$error7;\n            if (typeof res.error === \"object\" && Object.keys(res.error).includes(\"stack\") === false) res.error.stack = \"Stack trace is not available.\";\n            const err = serializeError(res.error, {\n                fallbackError: {\n                    message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.toString()),\n                    code: ((_res$error3 = res.error) === null || _res$error3 === void 0 ? void 0 : _res$error3.code) || -32603,\n                    stack: ((_res$error4 = res.error) === null || _res$error4 === void 0 ? void 0 : _res$error4.stack) || \"Stack trace is not available.\",\n                    data: ((_res$error5 = res.error) === null || _res$error5 === void 0 ? void 0 : _res$error5.data) || ((_res$error6 = res.error) === null || _res$error6 === void 0 ? void 0 : _res$error6.message) || ((_res$error7 = res.error) === null || _res$error7 === void 0 ? void 0 : _res$error7.toString())\n                },\n                shouldIncludeStack: true\n            });\n            throw rpcErrors.internal(err);\n        }\n        return res.result;\n    };\n    provider.send = (req, callback)=>{\n        if (typeof callback !== \"function\") {\n            throw new Error('Must provide callback to \"send\" method.');\n        }\n        engine.handle(req, callback);\n    };\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            provider.emit(\"data\", null, message);\n        });\n    }\n    provider.request = async (args)=>{\n        const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, args), {}, {\n            id: Math.random().toString(36).slice(2),\n            jsonrpc: \"2.0\"\n        });\n        const res = await provider.sendAsync(req);\n        return res;\n    };\n    return provider;\n}\nfunction providerFromMiddleware(middleware) {\n    const engine = new JRPCEngine();\n    engine.push(middleware);\n    const provider = providerFromEngine(engine);\n    return provider;\n}\nfunction providerAsMiddleware(provider) {\n    return async (req, res, _next, end)=>{\n        // send request to provider\n        try {\n            const providerRes = await provider.sendAsync(req);\n            res.result = providerRes;\n            return end();\n        } catch (error) {\n            return end(error);\n        }\n    };\n}\nclass Substream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { parent, name } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_parent\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        this._parent = parent;\n        this._name = name;\n    }\n    /**\n   * Explicitly sets read operations to a no-op.\n   */ _read() {\n        return undefined;\n    }\n    /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */ _write(chunk, _encoding, callback) {\n        this._parent.push({\n            name: this._name,\n            data: chunk\n        });\n        callback();\n    }\n}\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(){\n        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, opts), {}, {\n            objectMode: true\n        }));\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_substreams\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"getStream\", void 0);\n        this._substreams = {};\n    }\n    createStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // create substream\n        const substream = new Substream({\n            parent: this,\n            name\n        });\n        this._substreams[name] = substream;\n        // listen for parent stream to end\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        anyStreamEnd(this, (_error)=>substream.destroy(_error || undefined));\n        return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n    ignoreStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // set\n        this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n    _read() {\n        return undefined;\n    }\n    _write(chunk, _encoding, callback) {\n        const { name, data } = chunk;\n        if (!name) {\n            window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n            return callback();\n        }\n        // get corresponding substream\n        const substream = this._substreams[name];\n        if (!substream) {\n            window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n            return callback();\n        }\n        // push data into substream\n        if (substream !== IGNORE_SUBSTREAM) {\n            substream.push(data);\n        }\n        return callback();\n    }\n}\n// util\nfunction anyStreamEnd(stream, _cb) {\n    const cb = once__WEBPACK_IMPORTED_MODULE_6___default()(_cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        readable: false\n    }, cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        writable: false\n    }, cb);\n}\nfunction setupMultiplex(stream) {\n    const mux = new ObjectMultiplex();\n    mux.getStream = function streamHelper(name) {\n        if (this._substreams[name]) {\n            return this._substreams[name];\n        }\n        return this.createStream(name);\n    };\n    pump__WEBPACK_IMPORTED_MODULE_7___default()(stream, mux, stream, (err)=>{\n        if (err) window.console.error(err);\n    });\n    return mux;\n}\nclass PostMessageStream extends BasePostMessageStream {\n    _postMessage(data) {\n        let originConstraint = this._targetOrigin;\n        if (typeof data === \"object\") {\n            const dataObj = data;\n            if (typeof dataObj.data === \"object\") {\n                const dataObjData = dataObj.data;\n                if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n                    const dataObjDataParam = dataObjData.params[0];\n                    if (dataObjDataParam._origin) {\n                        originConstraint = dataObjDataParam._origin;\n                    }\n                    // add a constraint for the response\n                    dataObjDataParam._origin = window.location.origin;\n                }\n            }\n        }\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9kaXN0L29wZW5sb2dpbkpycGMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDM0I7QUFDTztBQUNpQjtBQUMzQjtBQUNOO0FBQ1I7QUFDQTtBQUV4QixTQUFTUTtJQUNQLE9BQU9DO0FBQ1Q7QUFDQSxNQUFNQyxNQUFNO0FBQ1osTUFBTUMsTUFBTTtBQUNaLE1BQU1DLE1BQU07QUFDWixNQUFNQyw4QkFBOEJaLG1EQUFNQTtJQUN4Q2EsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUksRUFDRkMsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLGVBQWVDLE1BQU0sRUFDckJDLGVBQWUsR0FBRyxFQUNuQixHQUFHTDtRQUNKLEtBQUssQ0FBQztZQUNKTSxZQUFZO1FBQ2Q7UUFDQXJCLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxXQUFXLEtBQUs7UUFDdENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsS0FBSztRQUM1Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDLDhEQUE4RDtRQUM5REEsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGNBQWMsS0FBSztRQUN6Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGtCQUFrQixLQUFLO1FBQzdDLElBQUksQ0FBQ2dCLFFBQVEsQ0FBQ0MsUUFBUTtZQUNwQixNQUFNLElBQUlLLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FB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QUFHN1IsT0FBTzhSLFFBQVEsQ0FBQ2hRLE1BQU07Z0JBQ25EO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ3RCLGFBQWEsQ0FBQ21CLFdBQVcsQ0FBQztZQUM3QjdCLFFBQVEsSUFBSSxDQUFDUyxPQUFPO1lBQ3BCYTtRQUNGLEdBQUdNO0lBQ0w7QUFDRjtBQUVpcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xb2duaXRhLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvZGlzdC9vcGVubG9naW5KcnBjLmVzbS5qcz84YWE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBEdXBsZXggfSBmcm9tICdyZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHNhZmVTdHJpbmdpZnkgZnJvbSAnZmFzdC1zYWZlLXN0cmluZ2lmeSc7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBlb3MgZnJvbSAnZW5kLW9mLXN0cmVhbSc7XG5pbXBvcnQgb25jZSBmcm9tICdvbmNlJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuXG5mdW5jdGlvbiBub29wKCkge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY29uc3QgU1lOID0gXCJTWU5cIjtcbmNvbnN0IEFDSyA9IFwiQUNLXCI7XG5jb25zdCBCUksgPSBcIkJSS1wiO1xuY2xhc3MgQmFzZVBvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBuYW1lLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGFyZ2V0V2luZG93ID0gd2luZG93LFxuICAgICAgdGFyZ2V0T3JpZ2luID0gXCIqXCJcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2luaXRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGF2ZVN5blwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRXaW5kb3dcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0T3JpZ2luXCIsIHZvaWQgMCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25NZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N5bkludGVydmFsSWRcIiwgdm9pZCAwKTtcbiAgICBpZiAoIW5hbWUgfHwgIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dC5cIik7XG4gICAgfVxuICAgIHRoaXMuX2luaXQgPSBmYWxzZTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0OyAvLyB0YXJnZXQgb3JpZ2luXG4gICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gdGFyZ2V0V2luZG93O1xuICAgIHRoaXMuX3RhcmdldE9yaWdpbiA9IHRhcmdldE9yaWdpbjtcbiAgICB0aGlzLl9vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N5bkludGVydmFsSWQgPSBudWxsO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICB0aGlzLl9oYW5kU2hha2UoKTtcbiAgfVxuICBfYnJlYWsoKSB7XG4gICAgdGhpcy5jb3JrKCk7XG4gICAgdGhpcy5fd3JpdGUoQlJLLCBudWxsLCBub29wKTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdCA9IGZhbHNlO1xuICB9XG4gIF9oYW5kU2hha2UoKSB7XG4gICAgdGhpcy5fd3JpdGUoU1lOLCBudWxsLCBub29wKTtcbiAgICB0aGlzLmNvcmsoKTtcbiAgfVxuICBfb25EYXRhKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2luaXQpIHtcbiAgICAgIC8vIGxpc3RlbiBmb3IgaGFuZHNoYWtlXG4gICAgICBpZiAoZGF0YSA9PT0gU1lOKSB7XG4gICAgICAgIHRoaXMuX2hhdmVTeW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBBQ0spIHtcbiAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5faGF2ZVN5bikge1xuICAgICAgICAgIHRoaXMuX3dyaXRlKEFDSywgbnVsbCwgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmNvcmsoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IEJSSykge1xuICAgICAgdGhpcy5fYnJlYWsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yd2FyZCBtZXNzYWdlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Bvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBvcmlnaW5Db25zdHJhaW50ID0gdGhpcy5fdGFyZ2V0T3JpZ2luO1xuICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGRhdGFcbiAgICB9LCBvcmlnaW5Db25zdHJhaW50KTtcbiAgfVxuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcblxuICAgIC8vIHZhbGlkYXRlIG1lc3NhZ2VcbiAgICBpZiAodGhpcy5fdGFyZ2V0T3JpZ2luICE9PSBcIipcIiAmJiBldmVudC5vcmlnaW4gIT09IHRoaXMuX3RhcmdldE9yaWdpbiB8fCBldmVudC5zb3VyY2UgIT09IHRoaXMuX3RhcmdldFdpbmRvdyB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlLnRhcmdldCAhPT0gdGhpcy5fbmFtZSB8fCAhbWVzc2FnZS5kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX29uRGF0YShtZXNzYWdlLmRhdGEpO1xuICB9XG4gIF9yZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBfd3JpdGUoZGF0YSwgXywgY2IpIHtcbiAgICB0aGlzLl9wb3N0TWVzc2FnZShkYXRhKTtcbiAgICBjYigpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG5jb25zdCBlcnJvckNvZGVzID0ge1xuICBycGM6IHtcbiAgICBpbnZhbGlkSW5wdXQ6IC0zMjAwMCxcbiAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXG4gICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogLTMyMDAyLFxuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IC0zMjAwMyxcbiAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcbiAgICBsaW1pdEV4Y2VlZGVkOiAtMzIwMDUsXG4gICAgcGFyc2U6IC0zMjcwMCxcbiAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxuICAgIG1ldGhvZE5vdEZvdW5kOiAtMzI2MDEsXG4gICAgaW52YWxpZFBhcmFtczogLTMyNjAyLFxuICAgIGludGVybmFsOiAtMzI2MDNcbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxuICAgIHVuYXV0aG9yaXplZDogNDEwMCxcbiAgICB1bnN1cHBvcnRlZE1ldGhvZDogNDIwMCxcbiAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IDQ5MDFcbiAgfVxufTtcbmNvbnN0IGVycm9yVmFsdWVzID0ge1xuICBcIi0zMjcwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LlwiXG4gIH0sXG4gIFwiLTMyNjAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuXCJcbiAgfSxcbiAgXCItMzI2MDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuXCJcbiAgfSxcbiAgXCItMzI2MDJcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLlwiXG4gIH0sXG4gIFwiLTMyNjAzXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIEpTT04tUlBDIGVycm9yLlwiXG4gIH0sXG4gIFwiLTMyMDAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBpbnB1dC5cIlxuICB9LFxuICBcIi0zMjAwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlc291cmNlIG5vdCBmb3VuZC5cIlxuICB9LFxuICBcIi0zMjAwMlwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlc291cmNlIHVuYXZhaWxhYmxlLlwiXG4gIH0sXG4gIFwiLTMyMDAzXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gcmVqZWN0ZWQuXCJcbiAgfSxcbiAgXCItMzIwMDRcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJNZXRob2Qgbm90IHN1cHBvcnRlZC5cIlxuICB9LFxuICBcIi0zMjAwNVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlcXVlc3QgbGltaXQgZXhjZWVkZWQuXCJcbiAgfSxcbiAgXCI0MDAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC5cIlxuICB9LFxuICBcIjQxMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci5cIlxuICB9LFxuICBcIjQyMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuXCJcbiAgfSxcbiAgXCI0OTAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuXCJcbiAgfSxcbiAgXCI0OTAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uXCJcbiAgfVxufTtcblxuY29uc3QgRkFMTEJBQ0tfRVJST1JfQ09ERSA9IGVycm9yQ29kZXMucnBjLmludGVybmFsO1xuY29uc3QgRkFMTEJBQ0tfTUVTU0FHRSA9IFwiVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC5cIjtcbmNvbnN0IEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFID0gXCJVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuXCI7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cbiAqIEEgY29kZSBpcyB2YWxpZCBpZiBpdCBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiBjb2RlIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciB7QGxpbmsgUnVudGltZU9iamVjdH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGhhcyBhIHJ1bnRpbWUgdHlwZSBvZiBgb2JqZWN0YCBhbmQgaXNcbiAqIG5laXRoZXIgYG51bGxgIG5vciBhbiBgQXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFuIG9iamVjdCBpcyB0aGUgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsXG4gKiBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBwbGFpbiAoZS5nLiBmdW5jdGlvbikuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBjb2RlIGlzIGEgdmFsaWQgSlNPTi1SUEMgc2VydmVyIGVycm9yIGNvZGUuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgYSB2YWxpZCBKU09OLVJQQyBzZXJ2ZXIgZXJyb3IgY29kZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAtMzIwOTkgJiYgY29kZSA8PSAtMzIwMDA7XG59XG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICBjb25zdCBjYXN0VmFsdWUgPSB2YWx1ZTtcbiAgaWYgKCFjYXN0VmFsdWUpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc1ZhbGlkQ29kZShjYXN0VmFsdWUuY29kZSkgfHwgIWlzVmFsaWRTdHJpbmcoY2FzdFZhbHVlLm1lc3NhZ2UpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChjYXN0VmFsdWUuc3RhY2sgJiYgIWlzVmFsaWRTdHJpbmcoY2FzdFZhbHVlLnN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtZXNzYWdlIGZvciBhIGdpdmVuIGNvZGUsIG9yIGEgZmFsbGJhY2sgbWVzc2FnZSBpZiB0aGUgY29kZSBoYXNcbiAqIG5vIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHBhcmFtIGZhbGxiYWNrTWVzc2FnZSAtIFRoZSBmYWxsYmFjayBtZXNzYWdlIHRvIHVzZSBpZiB0aGUgY29kZSBoYXMgbm9cbiAqIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBtZXNzYWdlIGZvciB0aGUgZ2l2ZW4gY29kZSwgb3IgdGhlIGZhbGxiYWNrIG1lc3NhZ2UgaWYgdGhlIGNvZGVcbiAqIGhhcyBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSB7XG4gIGxldCBmYWxsYmFja01lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEZBTExCQUNLX01FU1NBR0U7XG4gIGlmIChpc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgaWYgKE9iamVjdC5oYXNPd24oZXJyb3JWYWx1ZXMsIGNvZGVTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10ubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgICByZXR1cm4gSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG59XG5jb25zdCBGQUxMQkFDS19FUlJPUiA9IHtcbiAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgbWVzc2FnZTogZ2V0TWVzc2FnZUZyb21Db2RlKEZBTExCQUNLX0VSUk9SX0NPREUpXG59O1xuZnVuY3Rpb24gaXNWYWxpZEpzb24oc3RyKSB7XG4gIHRyeSB7XG4gICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdHIsIChzdHJLZXksIHN0clZhbCkgPT4ge1xuICAgICAgaWYgKHN0cktleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBzdHJLZXkgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgdmFsaWQganNvblwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc3RyVmFsID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHN0clZhbCA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgdmFsaWQganNvblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJWYWw7XG4gICAgfSksIChwcm9wS2V5LCBwcm9wVmFsdWUpID0+IHtcbiAgICAgIC8vIFN0cmlwIF9fcHJvdG9fXyBhbmQgY29uc3RydWN0b3IgcHJvcGVydGllcyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgICBpZiAocHJvcEtleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBwcm9wS2V5ID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wVmFsdWU7XG4gICAgfSk7XG4gICAgLy8gdGhpcyBtZWFucywgaXQncyBhIHZhbGlkIGpzb24gc28gZmFyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgYWxsIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgaW4gcXVlc3Rpb24uXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgaWYgKGlzVmFsaWRKc29uKHZhbHVlKSkge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYW4gdW5rbm93biBlcnJvciB0byBiZSB1c2VkIGFzIHRoZSBgY2F1c2VgIGluIGEgZmFsbGJhY2sgZXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIHVua25vd24gZXJyb3IuXG4gKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCBjb250YWluaW5nIGFzIG11Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGVycm9yIGFzIHBvc3NpYmxlLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVDYXVzZShlcnJvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3IubWFwKGVudHJ5ID0+IHtcbiAgICAgIGlmIChpc1ZhbGlkSnNvbihlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChlcnJvcikpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGVycm9yKTtcbiAgfVxuICBpZiAoaXNWYWxpZEpzb24oZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCBnaXZlbiBhbiBlcnJvciBhbmQgYSBKU09OIHNlcmlhbGl6YWJsZSBgZmFsbGJhY2tFcnJvcmBcbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgaW4gcXVlc3Rpb24uXG4gKiBAcGFyYW0gZmFsbGJhY2tFcnJvciAtIEEgSlNPTiBzZXJpYWxpemFibGUgZmFsbGJhY2sgZXJyb3IuXG4gKiBAcmV0dXJucyBBIEpTT04gc2VyaWFsaXphYmxlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRFcnJvcihlcnJvciwgZmFsbGJhY2tFcnJvcikge1xuICAvLyBJZiBhbiBlcnJvciBzcGVjaWZpZXMgYSBgc2VyaWFsaXplYCBmdW5jdGlvbiwgd2UgY2FsbCBpdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJzZXJpYWxpemVcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3Iuc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gIH1cbiAgaWYgKGlzSnNvblJwY0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIElmIHRoZSBlcnJvciBkb2VzIG5vdCBtYXRjaCB0aGUgSnNvblJwY0Vycm9yIHR5cGUsIHVzZSB0aGUgZmFsbGJhY2sgZXJyb3IsIGJ1dCB0cnkgdG8gaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgYXMgYGNhdXNlYC5cbiAgY29uc3QgY2F1c2UgPSBzZXJpYWxpemVDYXVzZShlcnJvcik7XG4gIGNvbnN0IGZhbGxiYWNrV2l0aENhdXNlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBmYWxsYmFja0Vycm9yKSwge30sIHtcbiAgICBkYXRhOiB7XG4gICAgICBjYXVzZVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmYWxsYmFja1dpdGhDYXVzZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgb24gdGhlXG4gKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLmNhdXNlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMuZmFsbGJhY2tFcnJvciAtIFRoZSBlcnJvciB0byByZXR1cm4gaWYgdGhlIGdpdmVuIGVycm9yIGlzXG4gKiBub3QgY29tcGF0aWJsZS4gU2hvdWxkIGJlIGEgSlNPTiBzZXJpYWxpemFibGUgdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaG91bGRJbmNsdWRlU3RhY2sgLSBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIGVycm9yJ3Mgc3RhY2tcbiAqIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IpIHtcbiAgbGV0IHtcbiAgICBmYWxsYmFja0Vycm9yID0gRkFMTEJBQ0tfRVJST1IsXG4gICAgc2hvdWxkSW5jbHVkZVN0YWNrID0gdHJ1ZVxuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKCFpc0pzb25ScGNFcnJvcihmYWxsYmFja0Vycm9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBmYWxsYmFjayBlcnJvciB3aXRoIGludGVnZXIgbnVtYmVyIGNvZGUgYW5kIHN0cmluZyBtZXNzYWdlLlwiKTtcbiAgfVxuICBjb25zdCBzZXJpYWxpemVkID0gYnVpbGRFcnJvcihlcnJvciwgZmFsbGJhY2tFcnJvcik7XG4gIGlmICghc2hvdWxkSW5jbHVkZVN0YWNrKSB7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHN1cHBsaWVkIGVycm9yIGRhdGEgaGFzIGEgdXNhYmxlIGBjYXVzZWAgcHJvcGVydHk7IGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIE9wdGlvbmFsIGRhdGEgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIGNhdXNlIHByb3BlcnR5IGlzIHByZXNlbnQgYW5kIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGF0YUhhc0NhdXNlKGRhdGEpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGRhdGEpICYmIE9iamVjdC5oYXNPd24oZGF0YSwgXCJjYXVzZVwiKSAmJiBpc09iamVjdChkYXRhLmNhdXNlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gY29kZSBpcyBhIHZhbGlkIEpTT04tUlBDIGVycm9yIGNvZGUuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgY29kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGNvZGUgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuXG4vKipcbiAqIEEgSlNPTiByZXBsYWNlciBmdW5jdGlvbiB0aGF0IG9taXRzIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIF8gLSBUaGUga2V5IGJlaW5nIHJlcGxhY2VkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHJlcGxhY2VkLlxuICogQHJldHVybnMgVGhlIHZhbHVlIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJbQ2lyY3VsYXJdXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBFcnJvciBzdWJjbGFzcyBpbXBsZW1lbnRpbmcgSlNPTiBSUEMgMi4wIGVycm9ycyBhbmQgRXRoZXJldW0gUlBDIGVycm9yc1xuICogcGVyIEVJUC0xNDc0LlxuICpcbiAqIFBlcm1pdHMgYW55IGludGVnZXIgZXJyb3IgY29kZS5cbiAqL1xuY2xhc3MgSnNvblJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBpZiAoZGF0YUhhc0NhdXNlKGRhdGEpKSB7XG4gICAgICBzdXBlcihtZXNzYWdlLCB7XG4gICAgICAgIGNhdXNlOiBkYXRhLmNhdXNlXG4gICAgICB9KTtcblxuICAgICAgLy8gQnJvd3NlciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmYWxsYmFja1xuICAgICAgLy8gVGhlIGBjYXVzZWAgZGVmaW5pdGlvbiBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRzY29uZmlnIGxpYiBhbmQvb3IgdGFyZ2V0IGhhdmUgY2hhbmdlZCB0byA+PWVzMjAyMlxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2F1c2VcIiwgdm9pZCAwKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICAgIGlmICghT2JqZWN0Lmhhc093bih0aGlzLCBcImNhdXNlXCIpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgIGNhdXNlOiBkYXRhLmNhdXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIC8vIFRoZSBgY2F1c2VgIGRlZmluaXRpb24gY2FuIGJlIHJlbW92ZWQgd2hlbiB0c2NvbmZpZyBsaWIgYW5kL29yIHRhcmdldCBoYXZlIGNoYW5nZWQgdG8gPj1lczIwMjJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHZvaWQgMCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5jYXVzZSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jYXVzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVycm9yIGFzIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBgdGhpcy5kYXRhYCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBhIHBsYWluIG9iamVjdCwgYnV0IHRoaXMgc2ltcGxpZmllc1xuICAgICAgLy8gdGhlIHR5cGUgZ3VhcmQgYmVsb3cuIFdlIGNhbiBzYWZlbHkgY2FzdCBpdCBiZWNhdXNlIHdlIGtub3cgaXQncyBhXG4gICAgICAvLyBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRoaXMuZGF0YSkpIHtcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhLmNhdXNlID0gc2VyaWFsaXplQ2F1c2UodGhpcy5kYXRhLmNhdXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IsIG9taXR0aW5nIGFueSBjaXJjdWxhclxuICAgKiByZWZlcmVuY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvci5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KHRoaXMuc2VyaWFsaXplKCksIHN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBFdGhlcmV1bSBQcm92aWRlciBlcnJvcnMgcGVyIEVJUC0xMTkzLlxuICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIDEwMDAgPD0gNDk5OSBdIHJhbmdlLlxuICovXG5jbGFzcyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgZXh0ZW5kcyBKc29uUnBjRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIFByb3ZpZGVyIEpTT04tUlBDIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gY29kZSAtIFRoZSBKU09OLVJQQyBlcnJvciBjb2RlLiBNdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlXG4gICAqIGAxMDAwIDw9IG4gPD0gNDk5OWAgcmFuZ2UuXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIEpTT04tUlBDIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBkYXRhIC0gT3B0aW9uYWwgZGF0YSB0byBpbmNsdWRlIGluIHRoZSBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIWlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogMTAwMCA8PSBjb2RlIDw9IDQ5OTknKTtcbiAgICB9XG4gICAgc3VwZXIoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYW4gZXJyb3IgbWVzc2FnZSBhbmQgb3B0aW9uYWwgZGF0YSBmcm9tIGFuIG9wdGlvbnMgYmFnLlxuICpcbiAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgZXJyb3IgbWVzc2FnZSBhbmQgb3B0aW9uYWwgZGF0YS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcHRzKGFyZykge1xuICBpZiAoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbYXJnXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBkYXRhXG4gICAgICB9ID0gYXJnO1xuICAgICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzcGVjaWZ5IHN0cmluZyBtZXNzYWdlLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogdW5kZWZpbmVkLCBkYXRhXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIEdldCBhIGdlbmVyaWMgSlNPTi1SUEMgZXJyb3IgY2xhc3MgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gZ2V0SnNvblJwY0Vycm9yKGNvZGUsIGFyZykge1xuICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcbiAgcmV0dXJuIG5ldyBKc29uUnBjRXJyb3IoY29kZSwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgZXJyb3IgY2xhc3MgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RXRoUHJvdmlkZXJFcnJvcihjb2RlLCBhcmcpIHtcbiAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5jb25zdCBycGNFcnJvcnMgPSB7XG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgUGFyc2UgKC0zMjcwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgcGFyc2U6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucGFyc2UsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBSZXF1ZXN0ICgtMzI2MDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludmFsaWRSZXF1ZXN0OiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUGFyYW1zICgtMzI2MDIpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludmFsaWRQYXJhbXM6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhIEpTT04gUlBDIDIuMCBNZXRob2QgTm90IEZvdW5kICgtMzI2MDEpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIG1ldGhvZE5vdEZvdW5kOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludGVybmFsOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludGVybmFsLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFNlcnZlciBlcnJvci5cbiAgICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIC0zMjA5OSA8PSAtMzIwMDUgXSByYW5nZS5cbiAgICogQ29kZXMgLTMyMDAwIHRocm91Z2ggLTMyMDA0IGFyZSByZXNlcnZlZCBieSBFSVAtMTQ3NC5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBUaGUgZXJyb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHNlcnZlcjogb3B0cyA9PiB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29kZVxuICAgIH0gPSBvcHRzO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSB8fCBjb2RlID4gLTMyMDA1IHx8IGNvZGUgPCAtMzIwOTkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogLTMyMDk5IDw9IGNvZGUgPD0gLTMyMDA1Jyk7XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uUnBjRXJyb3IoY29kZSwgb3B0cyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgSW52YWxpZCBJbnB1dCAoLTMyMDAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBpbnZhbGlkSW5wdXQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZElucHV0LCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIE5vdCBGb3VuZCAoLTMyMDAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICByZXNvdXJjZU5vdEZvdW5kOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnJlc291cmNlTm90Rm91bmQsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgVW5hdmFpbGFibGUgKC0zMjAwMikgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgcmVzb3VyY2VVbmF2YWlsYWJsZTogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFRyYW5zYWN0aW9uIFJlamVjdGVkICgtMzIwMDMpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMudHJhbnNhY3Rpb25SZWplY3RlZCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBNZXRob2QgTm90IFN1cHBvcnRlZCAoLTMyMDA0KSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBtZXRob2ROb3RTdXBwb3J0ZWQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubWV0aG9kTm90U3VwcG9ydGVkLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIExpbWl0IEV4Y2VlZGVkICgtMzIwMDUpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGxpbWl0RXhjZWVkZWQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubGltaXRFeGNlZWRlZCwgYXJnKVxufTtcbmNvbnN0IHByb3ZpZGVyRXJyb3JzID0ge1xuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVzZXIgUmVqZWN0ZWQgUmVxdWVzdCAoNDAwMSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgdXNlclJlamVjdGVkUmVxdWVzdDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5hdXRob3JpemVkICg0MTAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB1bmF1dGhvcml6ZWQ6IGFyZyA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWQsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5zdXBwb3J0ZWQgTWV0aG9kICg0MjAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB1bnN1cHBvcnRlZE1ldGhvZDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVuc3VwcG9ydGVkTWV0aG9kLCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIE5vdCBDb25uZWN0ZWQgKDQ5MDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICovXG4gIGRpc2Nvbm5lY3RlZDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBDaGFpbiBOb3QgQ29ubmVjdGVkICg0OTAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBjaGFpbkRpc2Nvbm5lY3RlZDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGEgY3VzdG9tIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBlcnJvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgY3VzdG9tOiBvcHRzID0+IHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YVxuICAgIH0gPSBvcHRzO1xuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5mdW5jdGlvbiBzYWZlQXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncykge1xuICB0cnkge1xuICAgIFJlZmxlY3QuYXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRocm93IGVycm9yIGFmdGVyIHRpbWVvdXQgc28gYXMgbm90IHRvIGludGVycnVwdCB0aGUgc3RhY2tcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIpIHtcbiAgY29uc3QgbiA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cbmNsYXNzIFNhZmVFdmVudEVtaXR0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBlbWl0KHR5cGUpIHtcbiAgICBsZXQgZG9FcnJvciA9IHR5cGUgPT09IFwiZXJyb3JcIjtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKCFkb0Vycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgbGV0IGVyO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBbZXJdID0gYXJncztcbiAgICAgIH1cbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVW5oYW5kbGVkIGVycm9yLiR7ZXIgPyBgICgke2VyLm1lc3NhZ2V9KWAgOiBcIlwifWApO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzYWZlQXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2FmZUFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmNsYXNzIFNlcmlhbGl6YWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YVxuICAgIH0gPSBfcmVmO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29kZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVzc2FnZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICBsZXQgdW53cmFwUmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICByZXR1cm4gKGVycm9yLCByZXNwb25zZSkgPT4ge1xuICAgIGlmIChlcnJvciB8fCByZXNwb25zZS5lcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKTtcbiAgICB9IGVsc2UgaWYgKCF1bndyYXBSZXN1bHQgfHwgQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yTWlkZGxld2FyZShsb2cpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGpzb24tcnBjLWVuZ2luZSB3aWxsIHRlcm1pbmF0ZSB0aGUgcmVxdWVzdCB3aGVuIGl0IG5vdGljZXMgdGhpcyBlcnJvclxuICAgICAgaWYgKHR5cGVvZiByZXEubWV0aG9kICE9PSBcInN0cmluZ1wiIHx8ICFyZXEubWV0aG9kKSB7XG4gICAgICAgIHJlcy5lcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiaW52YWxpZCBtZXRob2RcIlxuICAgICAgICB9KTtcbiAgICAgICAgZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5leHQoZG9uZSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9ID0gcmVzO1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuZXJyb3IoYE9wZW5Mb2dpbiAtIFJQQyBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoYE9wZW5Mb2dpbiAtIFJQQyBFcnJvciB0aHJvd246ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICByZXMuZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpIHtcbiAgY29uc3QgaWRNYXAgPSB7fTtcbiAgZnVuY3Rpb24gcmVhZE5vb3AoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGV2ZW50cyA9IG5ldyBTYWZlRXZlbnRFbWl0dGVyKCk7XG4gIGZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZShyZXMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gaWRNYXBbcmVzLmlkXTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyZWFtTWlkZGxld2FyZSAtIFVua25vd24gcmVzcG9uc2UgaWQgXCIke3Jlcy5pZH1cImApO1xuICAgIH1cbiAgICBkZWxldGUgaWRNYXBbcmVzLmlkXTtcbiAgICAvLyBjb3B5IHdob2xlIHJlcyBvbnRvIG9yaWdpbmFsIHJlc1xuICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5yZXMsIHJlcyk7XG4gICAgLy8gcnVuIGNhbGxiYWNrIG9uIGVtcHR5IHN0YWNrLFxuICAgIC8vIHByZXZlbnQgaW50ZXJuYWwgc3RyZWFtLWhhbmRsZXIgZnJvbSBjYXRjaGluZyBlcnJvcnNcbiAgICBzZXRUaW1lb3V0KGNvbnRleHQuZW5kKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcykge1xuICAgIGV2ZW50cy5lbWl0KFwibm90aWZpY2F0aW9uXCIsIHJlcyk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2UocmVzLCBfZW5jb2RpbmcsIGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXNOb3RpZmljYXRpb24gPSAhcmVzLmlkO1xuICAgICAgaWYgKGlzTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHByb2Nlc3NOb3RpZmljYXRpb24ocmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NSZXNwb25zZShyZXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIGVyciA9IF9lcnI7XG4gICAgfVxuICAgIC8vIGNvbnRpbnVlIHByb2Nlc3Npbmcgc3RyZWFtXG4gICAgY2IoZXJyKTtcbiAgfVxuICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4KHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIHJlYWQ6IHJlYWROb29wLFxuICAgIHdyaXRlOiBwcm9jZXNzTWVzc2FnZVxuICB9KTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgLy8gd3JpdGUgcmVxIHRvIHN0cmVhbVxuICAgIHN0cmVhbS5wdXNoKHJlcSk7XG4gICAgLy8gcmVnaXN0ZXIgcmVxdWVzdCBvbiBpZCBtYXBcbiAgICBpZE1hcFtyZXEuaWRdID0ge1xuICAgICAgcmVxLFxuICAgICAgcmVzLFxuICAgICAgbmV4dCxcbiAgICAgIGVuZFxuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgZXZlbnRzLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RyZWFtXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoaGFuZGxlcnMpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3JlcS5tZXRob2RdO1xuICAgIC8vIGlmIG5vIGhhbmRsZXIsIHJldHVyblxuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICAgIC8vIGlmIGhhbmRsZXIgaXMgZm4sIGNhbGwgYXMgbWlkZGxld2FyZVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcihyZXEsIHJlcywgbmV4dCwgZW5kKTtcbiAgICB9XG4gICAgLy8gaWYgaGFuZGxlciBpcyBzb21lIG90aGVyIHZhbHVlLCB1c2UgYXMgcmVzdWx0XG4gICAgcmVzLnJlc3VsdCA9IGhhbmRsZXI7XG4gICAgcmV0dXJuIGVuZCgpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUoKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIF9lbmQpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbElkID0gcmVxLmlkO1xuICAgIGNvbnN0IG5ld0lkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gICAgcmVxLmlkID0gbmV3SWQ7XG4gICAgcmVzLmlkID0gbmV3SWQ7XG4gICAgbmV4dChkb25lID0+IHtcbiAgICAgIHJlcS5pZCA9IG9yaWdpbmFsSWQ7XG4gICAgICByZXMuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyTWlkZGxld2FyZShsb2dnZXIpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgXykgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlJFUVwiLCByZXEsIFwiUkVTXCIsIHJlcyk7XG4gICAgbmV4dCgpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jTWlkZGxld2FyZSkge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAvLyBuZXh0UHJvbWlzZSBpcyB0aGUga2V5IHRvIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGl0IGlzIHJlc29sdmVkIGJ5IHRoZSByZXR1cm4gaGFuZGxlciBwYXNzZWQgdG8gdGhlXG4gICAgLy8gXCJuZXh0XCIgZnVuY3Rpb25cbiAgICBsZXQgcmVzb2x2ZU5leHRQcm9taXNlO1xuICAgIGNvbnN0IG5leHRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXNvbHZlTmV4dFByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXR1cm5IYW5kbGVyQ2FsbGJhY2sgPSBudWxsO1xuICAgIGxldCBuZXh0V2FzQ2FsbGVkID0gZmFsc2U7XG5cbiAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUuXG4gICAgY29uc3QgYXN5bmNOZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgbmV4dFdhc0NhbGxlZCA9IHRydWU7XG5cbiAgICAgIC8vIFdlIHBhc3MgYSByZXR1cm4gaGFuZGxlciB0byBuZXh0KCkuIFdoZW4gaXQgaXMgY2FsbGVkIGJ5IHRoZSBlbmdpbmUsXG4gICAgICAvLyB0aGUgY29uc3VtZXIncyBhc3luYyBtaWRkbGV3YXJlIHdpbGwgcmVzdW1lIGV4ZWN1dGluZy5cblxuICAgICAgbmV4dChydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrID0+IHtcbiAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBjb21lcyBmcm9tIEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzXG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayA9IHJ1blJldHVybkhhbmRsZXJzQ2FsbGJhY2s7XG4gICAgICAgIHJlc29sdmVOZXh0UHJvbWlzZSgpO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBuZXh0UHJvbWlzZTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhc3luY01pZGRsZXdhcmUocmVxLCByZXMsIGFzeW5jTmV4dCk7XG4gICAgICBpZiAobmV4dFdhc0NhbGxlZCkge1xuICAgICAgICBhd2FpdCBuZXh0UHJvbWlzZTsgLy8gd2UgbXVzdCB3YWl0IHVudGlsIHRoZSByZXR1cm4gaGFuZGxlciBpcyBjYWxsZWRcbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kKG51bGwpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAocmV0dXJuSGFuZGxlckNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBIEpTT04tUlBDIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHByb2Nlc3Nvci5cbiAqIEdpdmUgaXQgYSBzdGFjayBvZiBtaWRkbGV3YXJlLCBwYXNzIGl0IHJlcXVlc3RzLCBhbmQgZ2V0IGJhY2sgcmVzcG9uc2VzLlxuICovXG5jbGFzcyBKUlBDRW5naW5lIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21pZGRsZXdhcmVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9taWRkbGV3YXJlID0gW107XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsbHkgZXhlY3V0ZXMgdGhlIGdpdmVuIHN0YWNrIG9mIG1pZGRsZXdhcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdXRpb24sXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZCwgYW5kIGFuIGFycmF5IG9mXG4gICAqIG1pZGRsZXdhcmUtZGVmaW5lZCByZXR1cm4gaGFuZGxlcnMuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmVTdGFjaykge1xuICAgIGNvbnN0IHJldHVybkhhbmRsZXJzID0gW107XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBsZXQgaXNDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLy8gR28gZG93biBzdGFjayBvZiBtaWRkbGV3YXJlLCBjYWxsIGFuZCBjb2xsZWN0IG9wdGlvbmFsIHJldHVybkhhbmRsZXJzXG4gICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG1pZGRsZXdhcmVTdGFjaykge1xuICAgICAgW2Vycm9yLCBpc0NvbXBsZXRlXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmUsIHJldHVybkhhbmRsZXJzKTtcbiAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2Vycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVycy5yZXZlcnNlKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYW4gaW5kaXZpZHVhbCBtaWRkbGV3YXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbnkgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIG1pZGRsZXdhcmUgZXhlY3V0aW9uLFxuICAgKiBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgZW5kLlxuICAgKi9cbiAgc3RhdGljIF9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGVuZCA9IGVyciA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyIHx8IHJlcy5lcnJvcjtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhlcnJvcikuaW5jbHVkZXMoXCJzdGFja1wiKSA9PT0gZmFsc2UpIGVycm9yLnN0YWNrID0gXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiO1xuICAgICAgICAgIHJlcy5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICBzaG91bGRJbmNsdWRlU3RhY2s6IHRydWUsXG4gICAgICAgICAgICBmYWxsYmFja0Vycm9yOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgfHwgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgY29kZTogKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5jb2RlKSB8fCAtMzI2MDMsXG4gICAgICAgICAgICAgIHN0YWNrOiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnN0YWNrKSB8fCBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICAgICAgICAgIGRhdGE6IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuZGF0YSkgfHwgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSB8fCAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdCBzaG91bGQgZW5kXG4gICAgICAgIHJlc29sdmUoW2Vycm9yLCB0cnVlXSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgbmV4dCA9IHJldHVybkhhbmRsZXIgPT4ge1xuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgZW5kKHJlcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJldHVybkhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0dXJuSGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGVuZChuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkpSUENFbmdpbmU6ICduZXh0JyByZXR1cm4gaGFuZGxlcnMgbXVzdCBiZSBmdW5jdGlvbnNcIlxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5IYW5kbGVycy5wdXNoKHJldHVybkhhbmRsZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHNob3VsZCBub3QgZW5kXG4gICAgICAgICAgcmVzb2x2ZShbbnVsbCwgZmFsc2VdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGx5IGV4ZWN1dGVzIGFycmF5IG9mIHJldHVybiBoYW5kbGVycy4gVGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGFyZVxuICAgKiBhc3N1bWVkIHRvIGJlIGluIHRoZWlyIHNjb3BlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIF9ydW5SZXR1cm5IYW5kbGVycyhoYW5kbGVycykge1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBoYW5kbGVyKGVyciA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdCBub3IgYW4gZXJyb3IsIG9yIGlmXG4gICAqIHRoZSBcImlzQ29tcGxldGVcIiBmbGFnIGlzIGZhbHN5LlxuICAgKi9cbiAgc3RhdGljIF9jaGVja0ZvckNvbXBsZXRpb24oX3JlcSwgcmVzLCBpc0NvbXBsZXRlKSB7XG4gICAgaWYgKCEoXCJyZXN1bHRcIiBpbiByZXMpICYmICEoXCJlcnJvclwiIGluIHJlcykpIHtcbiAgICAgIHRocm93IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJSZXNwb25zZSBoYXMgbm8gZXJyb3Igb3IgcmVzdWx0IGZvciByZXF1ZXN0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgIHRocm93IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJOb3RoaW5nIGVuZGVkIHJlcXVlc3RcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gdGhlIGVuZ2luZSdzIG1pZGRsZXdhcmUgc3RhY2suXG4gICAqXG4gICAqIEBwYXJhbSBtaWRkbGV3YXJlIC0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gYWRkLlxuICAgKi9cbiAgcHVzaChtaWRkbGV3YXJlKSB7XG4gICAgdGhpcy5fbWlkZGxld2FyZS5wdXNoKG1pZGRsZXdhcmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEpTT04tUlBDIHJlcXVlc3QsIGFuZCByZXR1cm4gYSByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIHRoZSByZXNwb25zZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBhcnJheSBvZiBKU09OLVJQQyByZXF1ZXN0cywgYW5kIHJldHVybiBhbiBhcnJheSBvZiByZXNwb25zZXMuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3RzIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGFycmF5IG9mXG4gICAqIHJlc3BvbnNlcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEpTT04tUlBDIHJlcXVlc3QsIGFuZCByZXR1cm4gYSByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB0byBoYW5kbGUuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlLCBvciByZWplY3RzIHdpdGggYW5cbiAgICogZXJyb3IuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gYXJyYXkgb2YgSlNPTi1SUEMgcmVxdWVzdHMsIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgcmVzcG9uc2VzLlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0cyB0byBoYW5kbGUuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGFycmF5IG9mIHJlc3BvbnNlcywgb3IgcmVqZWN0c1xuICAgKiB3aXRoIGFuIGVycm9yLlxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBoYW5kbGUocmVxLCBjYikge1xuICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNhbGxiYWNrXCIgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEpKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSwgY2IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSk7XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZShyZXEsIGNiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VIYW5kbGUocmVxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgZW5naW5lIGFzIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwdXNoZWQgdG8gb3RoZXJcbiAgICogZW5naW5lcy5cbiAgICpcbiAgICogQHJldHVybnMgVGhpcyBlbmdpbmUgYXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgYXNNaWRkbGV3YXJlKCkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW21pZGRsZXdhcmVFcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnNdID0gYXdhaXQgSlJQQ0VuZ2luZS5fcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgdGhpcy5fbWlkZGxld2FyZSk7XG4gICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgYXdhaXQgSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuICAgICAgICAgIHJldHVybiBlbmQobWlkZGxld2FyZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dChhc3luYyBoYW5kbGVyQ2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFuZGxlckNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaWtlIF9oYW5kbGUsIGJ1dCBmb3IgYmF0Y2ggcmVxdWVzdHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBMaWtlIF9oYW5kbGUsIGJ1dCBmb3IgYmF0Y2ggcmVxdWVzdHMuXG4gICAqL1xuXG4gIGFzeW5jIF9oYW5kbGVCYXRjaChyZXFzLCBjYikge1xuICAgIC8vIFRoZSBvcmRlciBoZXJlIGlzIGltcG9ydGFudFxuICAgIHRyeSB7XG4gICAgICAvLyAyLiBXYWl0IGZvciBhbGwgcmVxdWVzdHMgdG8gZmluaXNoLCBvciB0aHJvdyBvbiBzb21lIGtpbmQgb2YgZmF0YWxcbiAgICAgIC8vIGVycm9yXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIC8vIDEuIEJlZ2luIGV4ZWN1dGluZyBlYWNoIHJlcXVlc3QgaW4gdGhlIG9yZGVyIHJlY2VpdmVkXG4gICAgICByZXFzLm1hcCh0aGlzLl9wcm9taXNlSGFuZGxlLmJpbmQodGhpcykpKTtcblxuICAgICAgLy8gMy4gUmV0dXJuIGJhdGNoIHJlc3BvbnNlXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlc3BvbnNlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHByb21pc2Utd3JhcHBlZCBfaGFuZGxlLlxuICAgKi9cbiAgX3Byb21pc2VIYW5kbGUocmVxKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZShyZXEsIChfZXJyLCByZXMpID0+IHtcbiAgICAgICAgLy8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYSByZXNwb25zZSwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhdmUgYW55IGVycm9yXG4gICAgICAgIC8vIHRoYXQgaXMgY2F1Z2h0IGFuZCBwcm9wYWdhdGVkLlxuICAgICAgICBpZiAoX2VyciAmJiByZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlamVjdChfZXJyKTtcbiAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSByZXF1ZXN0IG9iamVjdCBpcyB2YWxpZCwgcHJvY2Vzc2VzIGl0LCBhbmQgcGFzc2VzIGFueVxuICAgKiBlcnJvciBhbmQgdGhlIHJlc3BvbnNlIG9iamVjdCB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAqXG4gICAqIERvZXMgbm90IHJlamVjdC5cbiAgICovXG4gIGFzeW5jIF9oYW5kbGUoY2FsbGVyUmVxLCBjYikge1xuICAgIGlmICghY2FsbGVyUmVxIHx8IEFycmF5LmlzQXJyYXkoY2FsbGVyUmVxKSB8fCB0eXBlb2YgY2FsbGVyUmVxICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJyZXF1ZXN0IG11c3QgYmUgcGxhaW4gb2JqZWN0XCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNiKGVycm9yLCB7XG4gICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsZXJSZXEubWV0aG9kICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJtZXRob2QgbXVzdCBiZSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2IoZXJyb3IsIHtcbiAgICAgICAgaWQ6IGNhbGxlclJlcS5pZCxcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSBfb2JqZWN0U3ByZWFkKHt9LCBjYWxsZXJSZXEpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGlkOiByZXEuaWQsXG4gICAgICBqc29ucnBjOiByZXEuanNvbnJwY1xuICAgIH07XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc1JlcXVlc3QocmVxLCByZXMpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgLy8gQSByZXF1ZXN0IGhhbmRsZXIgZXJyb3IsIGEgcmUtdGhyb3duIG1pZGRsZXdhcmUgZXJyb3IsIG9yIHNvbWV0aGluZ1xuICAgICAgLy8gdW5leHBlY3RlZC5cbiAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIC8vIEVuc3VyZSBubyByZXN1bHQgaXMgcHJlc2VudCBvbiBhbiBlcnJvcmVkIHJlc3BvbnNlXG4gICAgICBkZWxldGUgcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzLmVycm9yKSB7XG4gICAgICAgIHZhciBfZXJyb3IyLCBfZXJyb3IzLCBfZXJyb3I0LCBfZXJyb3I1LCBfZXJyb3I2LCBfZXJyb3I3LCBfZXJyb3I4O1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKGVycm9yKS5pbmNsdWRlcyhcInN0YWNrXCIpID09PSBmYWxzZSkgZXJyb3Iuc3RhY2sgPSBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCI7XG4gICAgICAgIHJlcy5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7XG4gICAgICAgICAgc2hvdWxkSW5jbHVkZVN0YWNrOiB0cnVlLFxuICAgICAgICAgIGZhbGxiYWNrRXJyb3I6IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICgoX2Vycm9yMiA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3IyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3IyLm1lc3NhZ2UpIHx8ICgoX2Vycm9yMyA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3IzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3IzLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgY29kZTogKChfZXJyb3I0ID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjQuY29kZSkgfHwgLTMyNjAzLFxuICAgICAgICAgICAgc3RhY2s6ICgoX2Vycm9yNSA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3I1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3I1LnN0YWNrKSB8fCBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICAgICAgICBkYXRhOiAoKF9lcnJvcjYgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yNi5kYXRhKSB8fCAoKF9lcnJvcjcgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yNy5tZXNzYWdlKSB8fCAoKF9lcnJvcjggPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yOC50b1N0cmluZygpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYihlcnJvciwgcmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGdpdmVuIHJlcXVlc3QgYW5kIHJlc3BvbnNlLCBydW5zIGFsbCBtaWRkbGV3YXJlIGFuZCB0aGVpciByZXR1cm5cbiAgICogaGFuZGxlcnMsIGlmIGFueSwgYW5kIGVuc3VyZXMgdGhhdCBpbnRlcm5hbCByZXF1ZXN0IHByb2Nlc3Npbmcgc2VtYW50aWNzXG4gICAqIGFyZSBzYXRpc2ZpZWQuXG4gICAqL1xuICBhc3luYyBfcHJvY2Vzc1JlcXVlc3QocmVxLCByZXMpIHtcbiAgICBjb25zdCBbZXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIHRoaXMuX21pZGRsZXdhcmUpO1xuXG4gICAgLy8gVGhyb3cgaWYgXCJlbmRcIiB3YXMgbm90IGNhbGxlZCwgb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0XG4gICAgLy8gbm9yIGFuIGVycm9yLlxuICAgIEpSUENFbmdpbmUuX2NoZWNrRm9yQ29tcGxldGlvbihyZXEsIHJlcywgaXNDb21wbGV0ZSk7XG5cbiAgICAvLyBUaGUgcmV0dXJuIGhhbmRsZXJzIHNob3VsZCBydW4gZXZlbiBpZiBhbiBlcnJvciB3YXMgZW5jb3VudGVyZWQgZHVyaW5nXG4gICAgLy8gbWlkZGxld2FyZSBwcm9jZXNzaW5nLlxuICAgIGF3YWl0IEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcblxuICAgIC8vIE5vdyB3ZSByZS10aHJvdyB0aGUgbWlkZGxld2FyZSBwcm9jZXNzaW5nIGVycm9yLCBpZiBhbnksIHRvIGNhdGNoIGl0XG4gICAgLy8gZnVydGhlciB1cCB0aGUgY2FsbCBjaGFpbi5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VNaWRkbGV3YXJlKG1pZGRsZXdhcmVTdGFjaykge1xuICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICBtaWRkbGV3YXJlU3RhY2suZm9yRWFjaChtaWRkbGV3YXJlID0+IGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpKTtcbiAgcmV0dXJuIGVuZ2luZS5hc01pZGRsZXdhcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuZ2luZVN0cmVhbShvcHRzKSB7XG4gIGlmICghb3B0cyB8fCAhb3B0cy5lbmdpbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVuZ2luZSBwYXJhbWV0ZXIhXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBlbmdpbmVcbiAgfSA9IG9wdHM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHN0cmVhbTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlKHJlcSwgX2VuY29kaW5nLCBjYikge1xuICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XG4gICAgICBzdHJlYW0ucHVzaChyZXMpO1xuICAgIH0pO1xuICAgIGNiKCk7XG4gIH1cbiAgc3RyZWFtID0gbmV3IER1cGxleCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICByZWFkLFxuICAgIHdyaXRlXG4gIH0pO1xuXG4gIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICBpZiAoZW5naW5lLm9uKSB7XG4gICAgZW5naW5lLm9uKFwibm90aWZpY2F0aW9uXCIsIG1lc3NhZ2UgPT4ge1xuICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0cmVhbTtcbn1cbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgU2FmZUV2ZW50RW1pdHRlcigpO1xuICAvLyBoYW5kbGUgYm90aCBycGMgc2VuZCBtZXRob2RzXG4gIHByb3ZpZGVyLnNlbmRBc3luYyA9IGFzeW5jIHJlcSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZW5naW5lLmhhbmRsZShyZXEpO1xuICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgIHZhciBfcmVzJGVycm9yLCBfcmVzJGVycm9yMiwgX3JlcyRlcnJvcjMsIF9yZXMkZXJyb3I0LCBfcmVzJGVycm9yNSwgX3JlcyRlcnJvcjYsIF9yZXMkZXJyb3I3O1xuICAgICAgaWYgKHR5cGVvZiByZXMuZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMocmVzLmVycm9yKS5pbmNsdWRlcyhcInN0YWNrXCIpID09PSBmYWxzZSkgcmVzLmVycm9yLnN0YWNrID0gXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiO1xuICAgICAgY29uc3QgZXJyID0gc2VyaWFsaXplRXJyb3IocmVzLmVycm9yLCB7XG4gICAgICAgIGZhbGxiYWNrRXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiAoKF9yZXMkZXJyb3IgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3IubWVzc2FnZSkgfHwgKChfcmVzJGVycm9yMiA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3IyLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIGNvZGU6ICgoX3JlcyRlcnJvcjMgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3IzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yMy5jb2RlKSB8fCAtMzI2MDMsXG4gICAgICAgICAgc3RhY2s6ICgoX3JlcyRlcnJvcjQgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3I0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yNC5zdGFjaykgfHwgXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiLFxuICAgICAgICAgIGRhdGE6ICgoX3JlcyRlcnJvcjUgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3I1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yNS5kYXRhKSB8fCAoKF9yZXMkZXJyb3I2ID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjYubWVzc2FnZSkgfHwgKChfcmVzJGVycm9yNyA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3I3LnRvU3RyaW5nKCkpXG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEluY2x1ZGVTdGFjazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH07XG4gIHByb3ZpZGVyLnNlbmQgPSAocmVxLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgY2FsbGJhY2sgdG8gXCJzZW5kXCIgbWV0aG9kLicpO1xuICAgIH1cbiAgICBlbmdpbmUuaGFuZGxlKHJlcSwgY2FsbGJhY2spO1xuICB9O1xuICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgaWYgKGVuZ2luZS5vbikge1xuICAgIGVuZ2luZS5vbihcIm5vdGlmaWNhdGlvblwiLCBtZXNzYWdlID0+IHtcbiAgICAgIHByb3ZpZGVyLmVtaXQoXCJkYXRhXCIsIG51bGwsIG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIHByb3ZpZGVyLnJlcXVlc3QgPSBhc3luYyBhcmdzID0+IHtcbiAgICBjb25zdCByZXEgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFyZ3MpLCB7fSwge1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxuICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHByb3ZpZGVyLnNlbmRBc3luYyhyZXEpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJldHVybiBwcm92aWRlcjtcbn1cbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUobWlkZGxld2FyZSkge1xuICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICBlbmdpbmUucHVzaChtaWRkbGV3YXJlKTtcbiAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKTtcbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm92aWRlclJlcyA9IGF3YWl0IHByb3ZpZGVyLnNlbmRBc3luYyhyZXEpO1xuICAgICAgcmVzLnJlc3VsdCA9IHByb3ZpZGVyUmVzO1xuICAgICAgcmV0dXJuIGVuZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgICB9XG4gIH07XG59XG5cbmNsYXNzIFN1YnN0cmVhbSBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgcGFyZW50LFxuICAgICAgbmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFyZW50XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25hbWVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGljaXRseSBzZXRzIHJlYWQgb3BlcmF0aW9ucyB0byBhIG5vLW9wLlxuICAgKi9cbiAgX3JlYWQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkYXRhIHNob3VsZCBiZSB3cml0dGVuIHRvIHRoaXMgd3JpdGFibGUgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0gY2h1bmsgLSBBcmJpdHJhcnkgb2JqZWN0IHRvIHdyaXRlXG4gICAqIEBwYXJhbSBlbmNvZGluZyAtIEVuY29kaW5nIHRvIHVzZSB3aGVuIHdyaXRpbmcgcGF5bG9hZFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsZWQgd2hlbiB3cml0aW5nIGlzIGNvbXBsZXRlIG9yIGFuIGVycm9yIG9jY3Vyc1xuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcGFyZW50LnB1c2goe1xuICAgICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICAgIGRhdGE6IGNodW5rXG4gICAgfSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5jb25zdCBJR05PUkVfU1VCU1RSRUFNID0gU3ltYm9sKFwiSUdOT1JFX1NVQlNUUkVBTVwiKTtcbmNsYXNzIE9iamVjdE11bHRpcGxleCBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdHMpLCB7fSwge1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgIH0pKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Vic3RyZWFtc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFN0cmVhbVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fTtcbiAgfVxuICBjcmVhdGVTdHJlYW0obmFtZSkge1xuICAgIC8vIHZhbGlkYXRlIG5hbWVcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdE11bHRpcGxleCAtIG5hbWUgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBzdWJzdHJlYW1cbiAgICBjb25zdCBzdWJzdHJlYW0gPSBuZXcgU3Vic3RyZWFtKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gc3Vic3RyZWFtO1xuXG4gICAgLy8gbGlzdGVuIGZvciBwYXJlbnQgc3RyZWFtIHRvIGVuZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBhbnlTdHJlYW1FbmQodGhpcywgX2Vycm9yID0+IHN1YnN0cmVhbS5kZXN0cm95KF9lcnJvciB8fCB1bmRlZmluZWQpKTtcbiAgICByZXR1cm4gc3Vic3RyZWFtO1xuICB9XG5cbiAgLy8gaWdub3JlIHN0cmVhbXMgKGRvbnQgZGlzcGxheSBvcnBoYW5lZCBkYXRhIHdhcm5pbmcpXG4gIGlnbm9yZVN0cmVhbShuYW1lKSB7XG4gICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIC8vIHNldFxuICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBJR05PUkVfU1VCU1RSRUFNO1xuICB9XG4gIF9yZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGRhdGFcbiAgICB9ID0gY2h1bms7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuKGBPYmplY3RNdWx0aXBsZXggLSBtYWxmb3JtZWQgY2h1bmsgd2l0aG91dCBuYW1lIFwiJHtjaHVua31cImApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGNvcnJlc3BvbmRpbmcgc3Vic3RyZWFtXG4gICAgY29uc3Qgc3Vic3RyZWFtID0gdGhpcy5fc3Vic3RyZWFtc1tuYW1lXTtcbiAgICBpZiAoIXN1YnN0cmVhbSkge1xuICAgICAgd2luZG93LmNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gb3JwaGFuZWQgZGF0YSBmb3Igc3RyZWFtIFwiJHtuYW1lfVwiYCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvLyBwdXNoIGRhdGEgaW50byBzdWJzdHJlYW1cbiAgICBpZiAoc3Vic3RyZWFtICE9PSBJR05PUkVfU1VCU1RSRUFNKSB7XG4gICAgICBzdWJzdHJlYW0ucHVzaChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLy8gdXRpbFxuZnVuY3Rpb24gYW55U3RyZWFtRW5kKHN0cmVhbSwgX2NiKSB7XG4gIGNvbnN0IGNiID0gb25jZShfY2IpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IGZhbHNlXG4gIH0sIGNiKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LCBjYik7XG59XG5mdW5jdGlvbiBzZXR1cE11bHRpcGxleChzdHJlYW0pIHtcbiAgY29uc3QgbXV4ID0gbmV3IE9iamVjdE11bHRpcGxleCgpO1xuICBtdXguZ2V0U3RyZWFtID0gZnVuY3Rpb24gc3RyZWFtSGVscGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0cmVhbShuYW1lKTtcbiAgfTtcbiAgcHVtcChzdHJlYW0sIG11eCwgc3RyZWFtLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHdpbmRvdy5jb25zb2xlLmVycm9yKGVycik7XG4gIH0pO1xuICByZXR1cm4gbXV4O1xufVxuXG5jbGFzcyBQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSB7XG4gIF9wb3N0TWVzc2FnZShkYXRhKSB7XG4gICAgbGV0IG9yaWdpbkNvbnN0cmFpbnQgPSB0aGlzLl90YXJnZXRPcmlnaW47XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBkYXRhT2JqID0gZGF0YTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YU9iai5kYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGFPYmpEYXRhID0gZGF0YU9iai5kYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhT2JqRGF0YS5wYXJhbXMpICYmIGRhdGFPYmpEYXRhLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZGF0YU9iakRhdGFQYXJhbSA9IGRhdGFPYmpEYXRhLnBhcmFtc1swXTtcbiAgICAgICAgICBpZiAoZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luKSB7XG4gICAgICAgICAgICBvcmlnaW5Db25zdHJhaW50ID0gZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCBhIGNvbnN0cmFpbnQgZm9yIHRoZSByZXNwb25zZVxuICAgICAgICAgIGRhdGFPYmpEYXRhUGFyYW0uX29yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdGFyZ2V0V2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgZGF0YVxuICAgIH0sIG9yaWdpbkNvbnN0cmFpbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSwgRXRoZXJldW1Qcm92aWRlckVycm9yLCBJR05PUkVfU1VCU1RSRUFNLCBKUlBDRW5naW5lLCBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSwgSnNvblJwY0Vycm9yLCBPYmplY3RNdWx0aXBsZXgsIFBvc3RNZXNzYWdlU3RyZWFtLCBTYWZlRXZlbnRFbWl0dGVyLCBTZXJpYWxpemFibGVFcnJvciwgU3Vic3RyZWFtLCBjcmVhdGVBc3luY01pZGRsZXdhcmUsIGNyZWF0ZUVuZ2luZVN0cmVhbSwgY3JlYXRlRXJyb3JNaWRkbGV3YXJlLCBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSwgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSwgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlLCBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlLCBkYXRhSGFzQ2F1c2UsIGVycm9yQ29kZXMsIGVycm9yVmFsdWVzLCBnZXRNZXNzYWdlRnJvbUNvZGUsIGdldFJwY1Byb21pc2VDYWxsYmFjaywgaXNPYmplY3QsIGlzUGxhaW5PYmplY3QsIGlzVmFsaWRDb2RlLCBpc1ZhbGlkU3RyaW5nLCBtZXJnZU1pZGRsZXdhcmUsIHByb3ZpZGVyQXNNaWRkbGV3YXJlLCBwcm92aWRlckVycm9ycywgcHJvdmlkZXJGcm9tRW5naW5lLCBwcm92aWRlckZyb21NaWRkbGV3YXJlLCBycGNFcnJvcnMsIHNlcmlhbGl6ZUNhdXNlLCBzZXJpYWxpemVFcnJvciwgc2V0dXBNdWx0aXBsZXggfTtcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJEdXBsZXgiLCJzYWZlU3RyaW5naWZ5IiwiX29iamVjdFNwcmVhZCIsIkV2ZW50RW1pdHRlciIsImVvcyIsIm9uY2UiLCJwdW1wIiwibm9vcCIsInVuZGVmaW5lZCIsIlNZTiIsIkFDSyIsIkJSSyIsIkJhc2VQb3N0TWVzc2FnZVN0cmVhbSIsImNvbnN0cnVjdG9yIiwiX3JlZiIsIm5hbWUiLCJ0YXJnZXQiLCJ0YXJnZXRXaW5kb3ciLCJ3aW5kb3ciLCJ0YXJnZXRPcmlnaW4iLCJvYmplY3RNb2RlIiwiRXJyb3IiLCJfaW5pdCIsIl9oYXZlU3luIiwiX25hbWUiLCJfdGFyZ2V0IiwiX3RhcmdldFdpbmRvdyIsIl90YXJnZXRPcmlnaW4iLCJfb25NZXNzYWdlIiwib25NZXNzYWdlIiwiYmluZCIsIl9zeW5JbnRlcnZhbElkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9oYW5kU2hha2UiLCJfYnJlYWsiLCJjb3JrIiwiX3dyaXRlIiwiX29uRGF0YSIsImRhdGEiLCJ1bmNvcmsiLCJwdXNoIiwiZXJyIiwiZW1pdCIsIl9wb3N0TWVzc2FnZSIsIm9yaWdpbkNvbnN0cmFpbnQiLCJwb3N0TWVzc2FnZSIsImV2ZW50IiwibWVzc2FnZSIsIm9yaWdpbiIsInNvdXJjZSIsIl9yZWFkIiwiXyIsImNiIiwiX2Rlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXJyb3JDb2RlcyIsInJwYyIsImludmFsaWRJbnB1dCIsInJlc291cmNlTm90Rm91bmQiLCJyZXNvdXJjZVVuYXZhaWxhYmxlIiwidHJhbnNhY3Rpb25SZWplY3RlZCIsIm1ldGhvZE5vdFN1cHBvcnRlZCIsImxpbWl0RXhjZWVkZWQiLCJwYXJzZSIsImludmFsaWRSZXF1ZXN0IiwibWV0aG9kTm90Rm91bmQiLCJpbnZhbGlkUGFyYW1zIiwiaW50ZXJuYWwiLCJwcm92aWRlciIsInVzZXJSZWplY3RlZFJlcXVlc3QiLCJ1bmF1dGhvcml6ZWQiLCJ1bnN1cHBvcnRlZE1ldGhvZCIsImRpc2Nvbm5lY3RlZCIsImNoYWluRGlzY29ubmVjdGVkIiwiZXJyb3JWYWx1ZXMiLCJzdGFuZGFyZCIsIkZBTExCQUNLX0VSUk9SX0NPREUiLCJGQUxMQkFDS19NRVNTQUdFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UiLCJpc1ZhbGlkQ29kZSIsImNvZGUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpc1ZhbGlkU3RyaW5nIiwidmFsdWUiLCJsZW5ndGgiLCJpc09iamVjdCIsIkJvb2xlYW4iLCJBcnJheSIsImlzQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwicHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImlzSnNvblJwY1NlcnZlckVycm9yIiwiaXNKc29uUnBjRXJyb3IiLCJjYXN0VmFsdWUiLCJzdGFjayIsImdldE1lc3NhZ2VGcm9tQ29kZSIsImZhbGxiYWNrTWVzc2FnZSIsImFyZ3VtZW50cyIsImNvZGVTdHJpbmciLCJ0b1N0cmluZyIsImhhc093biIsIkZBTExCQUNLX0VSUk9SIiwiaXNWYWxpZEpzb24iLCJzdHIiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RyS2V5Iiwic3RyVmFsIiwicHJvcEtleSIsInByb3BWYWx1ZSIsImUiLCJzZXJpYWxpemVPYmplY3QiLCJvYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicmVkdWNlIiwiYWNjIiwia2V5Iiwic2VyaWFsaXplQ2F1c2UiLCJlcnJvciIsIm1hcCIsImVudHJ5IiwiYnVpbGRFcnJvciIsImZhbGxiYWNrRXJyb3IiLCJzZXJpYWxpemUiLCJjYXVzZSIsImZhbGxiYWNrV2l0aENhdXNlIiwic2VyaWFsaXplRXJyb3IiLCJzaG91bGRJbmNsdWRlU3RhY2siLCJzZXJpYWxpemVkIiwiZGF0YUhhc0NhdXNlIiwiaXNWYWxpZEV0aFByb3ZpZGVyQ29kZSIsInN0cmluZ2lmeVJlcGxhY2VyIiwiSnNvblJwY0Vycm9yIiwiYXNzaWduIiwiRXRoZXJldW1Qcm92aWRlckVycm9yIiwicGFyc2VPcHRzIiwiYXJnIiwiZ2V0SnNvblJwY0Vycm9yIiwiZ2V0RXRoUHJvdmlkZXJFcnJvciIsInJwY0Vycm9ycyIsInNlcnZlciIsIm9wdHMiLCJwcm92aWRlckVycm9ycyIsImN1c3RvbSIsInNhZmVBcHBseSIsImhhbmRsZXIiLCJjb250ZXh0IiwiYXJncyIsIlJlZmxlY3QiLCJhcHBseSIsInNldFRpbWVvdXQiLCJhcnJheUNsb25lIiwiYXJyIiwibiIsImNvcHkiLCJpIiwiU2FmZUV2ZW50RW1pdHRlciIsInR5cGUiLCJkb0Vycm9yIiwiZXZlbnRzIiwiX2V2ZW50cyIsIl9sZW4iLCJfa2V5IiwiZXIiLCJsZW4iLCJsaXN0ZW5lcnMiLCJTZXJpYWxpemFibGVFcnJvciIsImdldFJwY1Byb21pc2VDYWxsYmFjayIsInJlc29sdmUiLCJyZWplY3QiLCJ1bndyYXBSZXN1bHQiLCJyZXNwb25zZSIsInJlc3VsdCIsImNyZWF0ZUVycm9yTWlkZGxld2FyZSIsImxvZyIsInJlcSIsInJlcyIsIm5leHQiLCJlbmQiLCJtZXRob2QiLCJkb25lIiwiY3JlYXRlU3RyZWFtTWlkZGxld2FyZSIsImlkTWFwIiwicmVhZE5vb3AiLCJwcm9jZXNzUmVzcG9uc2UiLCJpZCIsInByb2Nlc3NOb3RpZmljYXRpb24iLCJwcm9jZXNzTWVzc2FnZSIsIl9lbmNvZGluZyIsImlzTm90aWZpY2F0aW9uIiwiX2VyciIsInN0cmVhbSIsInJlYWQiLCJ3cml0ZSIsIm1pZGRsZXdhcmUiLCJjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUiLCJoYW5kbGVycyIsImNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlIiwiX2VuZCIsIm9yaWdpbmFsSWQiLCJuZXdJZCIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsImNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUiLCJsb2dnZXIiLCJkZWJ1ZyIsImNyZWF0ZUFzeW5jTWlkZGxld2FyZSIsImFzeW5jTWlkZGxld2FyZSIsInJlc29sdmVOZXh0UHJvbWlzZSIsIm5leHRQcm9taXNlIiwiUHJvbWlzZSIsInJldHVybkhhbmRsZXJDYWxsYmFjayIsIm5leHRXYXNDYWxsZWQiLCJhc3luY05leHQiLCJydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrIiwiSlJQQ0VuZ2luZSIsIl9taWRkbGV3YXJlIiwiX3J1bkFsbE1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlU3RhY2siLCJyZXR1cm5IYW5kbGVycyIsImlzQ29tcGxldGUiLCJfcnVuTWlkZGxld2FyZSIsInJldmVyc2UiLCJrZXlzIiwiaW5jbHVkZXMiLCJyZXR1cm5IYW5kbGVyIiwiX3J1blJldHVybkhhbmRsZXJzIiwiX2NoZWNrRm9yQ29tcGxldGlvbiIsIl9yZXEiLCJoYW5kbGUiLCJfaGFuZGxlQmF0Y2giLCJfaGFuZGxlIiwiX3Byb21pc2VIYW5kbGUiLCJhc01pZGRsZXdhcmUiLCJtaWRkbGV3YXJlRXJyb3IiLCJoYW5kbGVyQ2FsbGJhY2siLCJyZXFzIiwicmVzcG9uc2VzIiwiYWxsIiwiY2F0Y2giLCJjYWxsZXJSZXEiLCJqc29ucnBjIiwiX3Byb2Nlc3NSZXF1ZXN0IiwiX2Vycm9yIiwiX2Vycm9yMiIsIl9lcnJvcjMiLCJfZXJyb3I0IiwiX2Vycm9yNSIsIl9lcnJvcjYiLCJfZXJyb3I3IiwiX2Vycm9yOCIsIm1lcmdlTWlkZGxld2FyZSIsImVuZ2luZSIsImZvckVhY2giLCJjcmVhdGVFbmdpbmVTdHJlYW0iLCJvbiIsInByb3ZpZGVyRnJvbUVuZ2luZSIsInNlbmRBc3luYyIsIl9yZXMkZXJyb3IiLCJfcmVzJGVycm9yMiIsIl9yZXMkZXJyb3IzIiwiX3JlcyRlcnJvcjQiLCJfcmVzJGVycm9yNSIsIl9yZXMkZXJyb3I2IiwiX3JlcyRlcnJvcjciLCJzZW5kIiwiY2FsbGJhY2siLCJyZXF1ZXN0IiwicHJvdmlkZXJGcm9tTWlkZGxld2FyZSIsInByb3ZpZGVyQXNNaWRkbGV3YXJlIiwiX25leHQiLCJwcm92aWRlclJlcyIsIlN1YnN0cmVhbSIsInBhcmVudCIsIl9wYXJlbnQiLCJjaHVuayIsIklHTk9SRV9TVUJTVFJFQU0iLCJTeW1ib2wiLCJPYmplY3RNdWx0aXBsZXgiLCJfc3Vic3RyZWFtcyIsImNyZWF0ZVN0cmVhbSIsInN1YnN0cmVhbSIsImFueVN0cmVhbUVuZCIsImRlc3Ryb3kiLCJpZ25vcmVTdHJlYW0iLCJjb25zb2xlIiwid2FybiIsIl9jYiIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJzZXR1cE11bHRpcGxleCIsIm11eCIsImdldFN0cmVhbSIsInN0cmVhbUhlbHBlciIsIlBvc3RNZXNzYWdlU3RyZWFtIiwiZGF0YU9iaiIsImRhdGFPYmpEYXRhIiwicGFyYW1zIiwiZGF0YU9iakRhdGFQYXJhbSIsIl9vcmlnaW4iLCJsb2NhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD_ENV: () => (/* binding */ BUILD_ENV),\n/* harmony export */   BrowserStorage: () => (/* binding */ BrowserStorage),\n/* harmony export */   LANGUAGES: () => (/* binding */ LANGUAGES),\n/* harmony export */   LANGUAGE_MAP: () => (/* binding */ LANGUAGE_MAP),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   MFA_FACTOR: () => (/* binding */ MFA_FACTOR),\n/* harmony export */   MFA_LEVELS: () => (/* binding */ MFA_LEVELS),\n/* harmony export */   MemoryStore: () => (/* binding */ MemoryStore),\n/* harmony export */   OPENLOGIN_ACTIONS: () => (/* binding */ OPENLOGIN_ACTIONS),\n/* harmony export */   OPENLOGIN_NETWORK: () => (/* binding */ OPENLOGIN_NETWORK),\n/* harmony export */   SUPPORTED_KEY_CURVES: () => (/* binding */ SUPPORTED_KEY_CURVES),\n/* harmony export */   THEME_MODES: () => (/* binding */ THEME_MODES),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   UX_MODE: () => (/* binding */ UX_MODE),\n/* harmony export */   applyWhiteLabelTheme: () => (/* binding */ applyWhiteLabelTheme),\n/* harmony export */   base64toJSON: () => (/* binding */ base64toJSON),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   generateWhiteLabelTheme: () => (/* binding */ generateWhiteLabelTheme),\n/* harmony export */   getColorsList: () => (/* binding */ getColorsList),\n/* harmony export */   jsonToBase64: () => (/* binding */ jsonToBase64),\n/* harmony export */   safeatob: () => (/* binding */ safeatob),\n/* harmony export */   safebtoa: () => (/* binding */ safebtoa),\n/* harmony export */   storageAvailable: () => (/* binding */ storageAvailable),\n/* harmony export */   storeKey: () => (/* binding */ storeKey)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url */ \"(ssr)/./node_modules/base64url/index.js\");\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(base64url__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/constants */ \"(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! color */ \"(ssr)/./node_modules/color/index.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(color__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\nconst base64url = (base64url__WEBPACK_IMPORTED_MODULE_1___default());\nfunction safebtoa(str) {\n    return base64url.encode(str);\n}\nfunction safeatob(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return base64url.decode(str);\n}\nfunction base64toJSON(b64str) {\n    return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n    return base64url.encode(JSON.stringify(json));\n}\nfunction storageAvailable(type) {\n    let storageExists = false;\n    let storageLength = 0;\n    let storage;\n    try {\n        storage = window[type];\n        storageExists = true;\n        storageLength = storage.length;\n        const x = \"__storage_test__\";\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    } catch (err) {\n        const error = err;\n        return error && // everything except Firefox\n        (error.code === 22 || // Firefox\n        error.code === 1014 || // test name field too, because code might not be present\n        // everything except Firefox\n        error.name === \"QuotaExceededError\" || // Firefox\n        error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n        storageExists && storageLength !== 0;\n    }\n}\nclass MemoryStore {\n    constructor(){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"store\", new Map());\n    }\n    getItem(key) {\n        return this.store.get(key) || null;\n    }\n    setItem(key, value) {\n        this.store.set(key, value);\n    }\n    removeItem(key) {\n        this.store.delete(key);\n    }\n}\nclass BrowserStorage {\n    constructor(storeKey, storage){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"storage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_storeKey\", void 0);\n        this.storage = storage;\n        this._storeKey = storeKey;\n        try {\n            if (!storage.getItem(storeKey)) {\n                this.resetStore();\n            }\n        } catch (error) {\n        // Storage is not available\n        }\n    }\n    static getInstance(key) {\n        let storageKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"local\";\n        if (!this.instanceMap.has(key)) {\n            let storage;\n            if (storageKey === \"local\" && storageAvailable(\"localStorage\")) {\n                storage = window.localStorage;\n            } else if (storageKey === \"session\" && storageAvailable(\"sessionStorage\")) {\n                storage = window.sessionStorage;\n            } else {\n                storage = new MemoryStore();\n            }\n            this.instanceMap.set(key, new this(key, storage));\n        }\n        return this.instanceMap.get(key);\n    }\n    toJSON() {\n        return this.storage.getItem(this._storeKey);\n    }\n    resetStore() {\n        const currStore = this.getStore();\n        this.storage.removeItem(this._storeKey);\n        return currStore;\n    }\n    getStore() {\n        return JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n    }\n    get(key) {\n        const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n        return store[key];\n    }\n    set(key, value) {\n        const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n        store[key] = value;\n        this.storage.setItem(this._storeKey, JSON.stringify(store));\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(BrowserStorage, \"instanceMap\", new Map());\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n    POPUP: \"popup\",\n    REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_NETWORK = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK), _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK);\nconst SUPPORTED_KEY_CURVES = {\n    SECP256K1: \"secp256k1\",\n    ED25519: \"ed25519\"\n};\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    FARCASTER: \"farcaster\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\",\n    SMS_PASSWORDLESS: \"sms_passwordless\",\n    WEBAUTHN: \"webauthn\",\n    JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n    DEFAULT: \"default\",\n    OPTIONAL: \"optional\",\n    MANDATORY: \"mandatory\",\n    NONE: \"none\"\n};\nconst OPENLOGIN_ACTIONS = {\n    LOGIN: \"login\",\n    ENABLE_MFA: \"enable_mfa\",\n    MANAGE_MFA: \"manage_mfa\",\n    MODIFY_SOCIAL_FACTOR: \"modify_social_factor\"\n};\nconst BUILD_ENV = {\n    PRODUCTION: \"production\",\n    DEVELOPMENT: \"development\",\n    STAGING: \"staging\",\n    TESTING: \"testing\"\n};\n/**\n * {@label loginProviderType}\n */ // autocomplete workaround https://github.com/microsoft/TypeScript/issues/29729\nconst LANGUAGES = {\n    en: \"en\",\n    ja: \"ja\",\n    ko: \"ko\",\n    de: \"de\",\n    zh: \"zh\",\n    es: \"es\",\n    fr: \"fr\",\n    pt: \"pt\",\n    nl: \"nl\",\n    tr: \"tr\"\n};\nconst LANGUAGE_MAP = {\n    en: \"english\",\n    ja: \"japanese\",\n    ko: \"korean\",\n    de: \"german\",\n    zh: \"mandarin\",\n    es: \"spanish\",\n    fr: \"french\",\n    pt: \"portuguese\",\n    nl: \"dutch\",\n    tr: \"turkish\"\n};\nconst THEME_MODES = {\n    light: \"light\",\n    dark: \"dark\",\n    auto: \"auto\"\n};\nconst MFA_FACTOR = {\n    DEVICE: \"deviceShareFactor\",\n    BACKUP_SHARE: \"backUpShareFactor\",\n    SOCIAL_BACKUP: \"socialBackupFactor\",\n    PASSWORD: \"passwordFactor\",\n    PASSKEYS: \"passkeysFactor\",\n    AUTHENTICATOR: \"authenticatorFactor\"\n};\nfunction getColorsList() {\n    let colorsAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n    let colorsShiftAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n    let mixColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"black\";\n    let rotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let saturation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;\n    let mainColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"#0346ff\";\n    const colorsList = [];\n    let step;\n    for(step = 0; step < colorsAmount; step += 1){\n        colorsList.push(color__WEBPACK_IMPORTED_MODULE_4___default()(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix(color__WEBPACK_IMPORTED_MODULE_4___default()(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());\n    }\n    return colorsList;\n}\nfunction generateWhiteLabelTheme(primary) {\n    const darkSet = getColorsList(3, 50, \"black\", 0, 20, primary);\n    const lightSet = getColorsList(6, 85, \"white\", 0, 20, primary);\n    return [\n        ...darkSet.reverse(),\n        primary,\n        ...lightSet\n    ];\n}\nfunction applyWhiteLabelTheme(rootElement, theme) {\n    if (theme.primary) {\n        const themeSet = generateWhiteLabelTheme(theme.primary);\n        rootElement.style.setProperty(\"--app-primary-900\", themeSet[0]);\n        rootElement.style.setProperty(\"--app-primary-800\", themeSet[1]);\n        rootElement.style.setProperty(\"--app-primary-700\", themeSet[2]);\n        rootElement.style.setProperty(\"--app-primary-600\", themeSet[3]);\n        rootElement.style.setProperty(\"--app-primary-500\", themeSet[4]);\n        rootElement.style.setProperty(\"--app-primary-400\", themeSet[5]);\n        rootElement.style.setProperty(\"--app-primary-300\", themeSet[6]);\n        rootElement.style.setProperty(\"--app-primary-200\", themeSet[7]);\n        rootElement.style.setProperty(\"--app-primary-100\", themeSet[8]);\n        rootElement.style.setProperty(\"--app-primary-50\", themeSet[9]);\n    }\n    if (theme.onPrimary) {\n        rootElement.style.setProperty(\"--app-on-primary\", theme.onPrimary);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvZGlzdC9vcGVubG9naW5VdGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUMvQjtBQUM0QjtBQUNtQjtBQUNBO0FBQzFEO0FBRTFCLE1BQU1NLFlBQVlMLGtEQUFZQTtBQUM5QixTQUFTTSxTQUFTQyxHQUFHO0lBQ25CLE9BQU9GLFVBQVVHLE1BQU0sQ0FBQ0Q7QUFDMUI7QUFDQSxTQUFTRSxTQUFTRixHQUFHO0lBQ25CLDZFQUE2RTtJQUM3RSxPQUFPRixVQUFVSyxNQUFNLENBQUNIO0FBQzFCO0FBQ0EsU0FBU0ksYUFBYUMsTUFBTTtJQUMxQixPQUFPQyxLQUFLQyxLQUFLLENBQUNULFVBQVVLLE1BQU0sQ0FBQ0U7QUFDckM7QUFDQSxTQUFTRyxhQUFhQyxJQUFJO0lBQ3hCLE9BQU9YLFVBQVVHLE1BQU0sQ0FBQ0ssS0FBS0ksU0FBUyxDQUFDRDtBQUN6QztBQUNBLFNBQVNFLGlCQUFpQkMsSUFBSTtJQUM1QixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDO0lBQ0osSUFBSTtRQUNGQSxVQUFVQyxNQUFNLENBQUNKLEtBQUs7UUFDdEJDLGdCQUFnQjtRQUNoQkMsZ0JBQWdCQyxRQUFRRSxNQUFNO1FBQzlCLE1BQU1DLElBQUk7UUFDVkgsUUFBUUksT0FBTyxDQUFDRCxHQUFHQTtRQUNuQkgsUUFBUUssVUFBVSxDQUFDRjtRQUNuQixPQUFPO0lBQ1QsRUFBRSxPQUFPRyxLQUFLO1FBQ1osTUFBTUMsUUFBUUQ7UUFDZCxPQUFPQyxTQUNQLDRCQUE0QjtRQUM1QkEsQ0FBQUEsTUFBTUMsSUFBSSxLQUFLLE1BQ2YsVUFBVTtRQUNWRCxNQUFNQyxJQUFJLEtBQUssUUFDZix5REFBeUQ7UUFDekQsNEJBQTRCO1FBQzVCRCxNQUFNRSxJQUFJLEtBQUssd0JBQ2YsVUFBVTtRQUNW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cUJGLFFBQVEsQ0FBQyxFQUFFO1FBQzlERixZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxxQkFBcUJGLFFBQVEsQ0FBQyxFQUFFO1FBQzlERixZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxvQkFBb0JGLFFBQVEsQ0FBQyxFQUFFO0lBQy9EO0lBQ0EsSUFBSUQsTUFBTUksU0FBUyxFQUFFO1FBQ25CTCxZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxvQkFBb0JILE1BQU1JLFNBQVM7SUFDbkU7QUFDRjtBQUUwViIsInNvdXJjZXMiOlsid2VicGFjazovL3FvZ25pdGEvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvZGlzdC9vcGVubG9naW5VdGlscy5lc20uanM/ZjkzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IGJhc2U2NHVybExpYiBmcm9tICdiYXNlNjR1cmwnO1xuaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCB7IFRPUlVTX1NBUFBISVJFX05FVFdPUkssIFRPUlVTX0xFR0FDWV9ORVRXT1JLIH0gZnJvbSAnQHRvcnVzbGFicy9jb25zdGFudHMnO1xuZXhwb3J0IHsgVE9SVVNfTEVHQUNZX05FVFdPUkssIFRPUlVTX1NBUFBISVJFX05FVFdPUksgfSBmcm9tICdAdG9ydXNsYWJzL2NvbnN0YW50cyc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuXG5jb25zdCBiYXNlNjR1cmwgPSBiYXNlNjR1cmxMaWI7XG5mdW5jdGlvbiBzYWZlYnRvYShzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHNhZmVhdG9iKHN0cikge1xuICAvLyBHb2luZyBiYWNrd2FyZHM6IGZyb20gYnl0ZXN0cmVhbSwgdG8gcGVyY2VudC1lbmNvZGluZywgdG8gb3JpZ2luYWwgc3RyaW5nLlxuICByZXR1cm4gYmFzZTY0dXJsLmRlY29kZShzdHIpO1xufVxuZnVuY3Rpb24gYmFzZTY0dG9KU09OKGI2NHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGI2NHN0cikpO1xufVxuZnVuY3Rpb24ganNvblRvQmFzZTY0KGpzb24pIHtcbiAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoanNvbikpO1xufVxuZnVuY3Rpb24gc3RvcmFnZUF2YWlsYWJsZSh0eXBlKSB7XG4gIGxldCBzdG9yYWdlRXhpc3RzID0gZmFsc2U7XG4gIGxldCBzdG9yYWdlTGVuZ3RoID0gMDtcbiAgbGV0IHN0b3JhZ2U7XG4gIHRyeSB7XG4gICAgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXTtcbiAgICBzdG9yYWdlRXhpc3RzID0gdHJ1ZTtcbiAgICBzdG9yYWdlTGVuZ3RoID0gc3RvcmFnZS5sZW5ndGg7XG4gICAgY29uc3QgeCA9IFwiX19zdG9yYWdlX3Rlc3RfX1wiO1xuICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KTtcbiAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgIHJldHVybiBlcnJvciAmJiAoXG4gICAgLy8gZXZlcnl0aGluZyBleGNlcHQgRmlyZWZveFxuICAgIGVycm9yLmNvZGUgPT09IDIyIHx8XG4gICAgLy8gRmlyZWZveFxuICAgIGVycm9yLmNvZGUgPT09IDEwMTQgfHxcbiAgICAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgZXJyb3IubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fFxuICAgIC8vIEZpcmVmb3hcbiAgICBlcnJvci5uYW1lID09PSBcIk5TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEXCIpICYmXG4gICAgLy8gYWNrbm93bGVkZ2UgUXVvdGFFeGNlZWRlZEVycm9yIG9ubHkgaWYgdGhlcmUncyBzb21ldGhpbmcgYWxyZWFkeSBzdG9yZWRcbiAgICBzdG9yYWdlRXhpc3RzICYmIHN0b3JhZ2VMZW5ndGggIT09IDA7XG4gIH1cbn1cblxuY2xhc3MgTWVtb3J5U3RvcmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZVwiLCBuZXcgTWFwKCkpO1xuICB9XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0KGtleSkgfHwgbnVsbDtcbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0b3JlLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHRoaXMuc3RvcmUuZGVsZXRlKGtleSk7XG4gIH1cbn1cbmNsYXNzIEJyb3dzZXJTdG9yYWdlIHtcbiAgY29uc3RydWN0b3Ioc3RvcmVLZXksIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0b3JlS2V5XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLl9zdG9yZUtleSA9IHN0b3JlS2V5O1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXN0b3JhZ2UuZ2V0SXRlbShzdG9yZUtleSkpIHtcbiAgICAgICAgdGhpcy5yZXNldFN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZVxuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2Uoa2V5KSB7XG4gICAgbGV0IHN0b3JhZ2VLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibG9jYWxcIjtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2VNYXAuaGFzKGtleSkpIHtcbiAgICAgIGxldCBzdG9yYWdlO1xuICAgICAgaWYgKHN0b3JhZ2VLZXkgPT09IFwibG9jYWxcIiAmJiBzdG9yYWdlQXZhaWxhYmxlKFwibG9jYWxTdG9yYWdlXCIpKSB7XG4gICAgICAgIHN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgfSBlbHNlIGlmIChzdG9yYWdlS2V5ID09PSBcInNlc3Npb25cIiAmJiBzdG9yYWdlQXZhaWxhYmxlKFwic2Vzc2lvblN0b3JhZ2VcIikpIHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JhZ2UgPSBuZXcgTWVtb3J5U3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zdGFuY2VNYXAuc2V0KGtleSwgbmV3IHRoaXMoa2V5LCBzdG9yYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlTWFwLmdldChrZXkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmVLZXkpO1xuICB9XG4gIHJlc2V0U3RvcmUoKSB7XG4gICAgY29uc3QgY3VyclN0b3JlID0gdGhpcy5nZXRTdG9yZSgpO1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuX3N0b3JlS2V5KTtcbiAgICByZXR1cm4gY3VyclN0b3JlO1xuICB9XG4gIGdldFN0b3JlKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuX3N0b3JlS2V5KSB8fCBcInt9XCIpO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBjb25zdCBzdG9yZSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmVLZXkpIHx8IFwie31cIik7XG4gICAgcmV0dXJuIHN0b3JlW2tleV07XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzdG9yZSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmVLZXkpIHx8IFwie31cIik7XG4gICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuX3N0b3JlS2V5LCBKU09OLnN0cmluZ2lmeShzdG9yZSkpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoQnJvd3NlclN0b3JhZ2UsIFwiaW5zdGFuY2VNYXBcIiwgbmV3IE1hcCgpKTtcblxuY29uc3Qgc3RvcmVLZXkgPSBcIm9wZW5sb2dpbl9zdG9yZVwiO1xuY29uc3QgVVhfTU9ERSA9IHtcbiAgUE9QVVA6IFwicG9wdXBcIixcbiAgUkVESVJFQ1Q6IFwicmVkaXJlY3RcIlxufTtcbmNvbnN0IE9QRU5MT0dJTl9ORVRXT1JLID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBUT1JVU19TQVBQSElSRV9ORVRXT1JLKSwgVE9SVVNfTEVHQUNZX05FVFdPUkspO1xuY29uc3QgU1VQUE9SVEVEX0tFWV9DVVJWRVMgPSB7XG4gIFNFQ1AyNTZLMTogXCJzZWNwMjU2azFcIixcbiAgRUQyNTUxOTogXCJlZDI1NTE5XCJcbn07XG5jb25zdCBMT0dJTl9QUk9WSURFUiA9IHtcbiAgR09PR0xFOiBcImdvb2dsZVwiLFxuICBGQUNFQk9PSzogXCJmYWNlYm9va1wiLFxuICBSRURESVQ6IFwicmVkZGl0XCIsXG4gIERJU0NPUkQ6IFwiZGlzY29yZFwiLFxuICBUV0lUQ0g6IFwidHdpdGNoXCIsXG4gIEFQUExFOiBcImFwcGxlXCIsXG4gIExJTkU6IFwibGluZVwiLFxuICBHSVRIVUI6IFwiZ2l0aHViXCIsXG4gIEtBS0FPOiBcImtha2FvXCIsXG4gIExJTktFRElOOiBcImxpbmtlZGluXCIsXG4gIFRXSVRURVI6IFwidHdpdHRlclwiLFxuICBXRUlCTzogXCJ3ZWlib1wiLFxuICBXRUNIQVQ6IFwid2VjaGF0XCIsXG4gIEZBUkNBU1RFUjogXCJmYXJjYXN0ZXJcIixcbiAgRU1BSUxfUEFTU1dPUkRMRVNTOiBcImVtYWlsX3Bhc3N3b3JkbGVzc1wiLFxuICBTTVNfUEFTU1dPUkRMRVNTOiBcInNtc19wYXNzd29yZGxlc3NcIixcbiAgV0VCQVVUSE46IFwid2ViYXV0aG5cIixcbiAgSldUOiBcImp3dFwiXG59O1xuY29uc3QgTUZBX0xFVkVMUyA9IHtcbiAgREVGQVVMVDogXCJkZWZhdWx0XCIsXG4gIE9QVElPTkFMOiBcIm9wdGlvbmFsXCIsXG4gIE1BTkRBVE9SWTogXCJtYW5kYXRvcnlcIixcbiAgTk9ORTogXCJub25lXCJcbn07XG5jb25zdCBPUEVOTE9HSU5fQUNUSU9OUyA9IHtcbiAgTE9HSU46IFwibG9naW5cIixcbiAgRU5BQkxFX01GQTogXCJlbmFibGVfbWZhXCIsXG4gIE1BTkFHRV9NRkE6IFwibWFuYWdlX21mYVwiLFxuICBNT0RJRllfU09DSUFMX0ZBQ1RPUjogXCJtb2RpZnlfc29jaWFsX2ZhY3RvclwiXG59O1xuY29uc3QgQlVJTERfRU5WID0ge1xuICBQUk9EVUNUSU9OOiBcInByb2R1Y3Rpb25cIixcbiAgREVWRUxPUE1FTlQ6IFwiZGV2ZWxvcG1lbnRcIixcbiAgU1RBR0lORzogXCJzdGFnaW5nXCIsXG4gIFRFU1RJTkc6IFwidGVzdGluZ1wiXG59O1xuXG4vKipcbiAqIHtAbGFiZWwgbG9naW5Qcm92aWRlclR5cGV9XG4gKi9cblxuLy8gYXV0b2NvbXBsZXRlIHdvcmthcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yOTcyOVxuXG5jb25zdCBMQU5HVUFHRVMgPSB7XG4gIGVuOiBcImVuXCIsXG4gIGphOiBcImphXCIsXG4gIGtvOiBcImtvXCIsXG4gIGRlOiBcImRlXCIsXG4gIHpoOiBcInpoXCIsXG4gIGVzOiBcImVzXCIsXG4gIGZyOiBcImZyXCIsXG4gIHB0OiBcInB0XCIsXG4gIG5sOiBcIm5sXCIsXG4gIHRyOiBcInRyXCJcbn07XG5jb25zdCBMQU5HVUFHRV9NQVAgPSB7XG4gIGVuOiBcImVuZ2xpc2hcIixcbiAgamE6IFwiamFwYW5lc2VcIixcbiAga286IFwia29yZWFuXCIsXG4gIGRlOiBcImdlcm1hblwiLFxuICB6aDogXCJtYW5kYXJpblwiLFxuICBlczogXCJzcGFuaXNoXCIsXG4gIGZyOiBcImZyZW5jaFwiLFxuICBwdDogXCJwb3J0dWd1ZXNlXCIsXG4gIG5sOiBcImR1dGNoXCIsXG4gIHRyOiBcInR1cmtpc2hcIlxufTtcbmNvbnN0IFRIRU1FX01PREVTID0ge1xuICBsaWdodDogXCJsaWdodFwiLFxuICBkYXJrOiBcImRhcmtcIixcbiAgYXV0bzogXCJhdXRvXCJcbn07XG5jb25zdCBNRkFfRkFDVE9SID0ge1xuICBERVZJQ0U6IFwiZGV2aWNlU2hhcmVGYWN0b3JcIixcbiAgQkFDS1VQX1NIQVJFOiBcImJhY2tVcFNoYXJlRmFjdG9yXCIsXG4gIFNPQ0lBTF9CQUNLVVA6IFwic29jaWFsQmFja3VwRmFjdG9yXCIsXG4gIFBBU1NXT1JEOiBcInBhc3N3b3JkRmFjdG9yXCIsXG4gIFBBU1NLRVlTOiBcInBhc3NrZXlzRmFjdG9yXCIsXG4gIEFVVEhFTlRJQ0FUT1I6IFwiYXV0aGVudGljYXRvckZhY3RvclwiXG59O1xuXG5mdW5jdGlvbiBnZXRDb2xvcnNMaXN0KCkge1xuICBsZXQgY29sb3JzQW1vdW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAzO1xuICBsZXQgY29sb3JzU2hpZnRBbW91bnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDUwO1xuICBsZXQgbWl4Q29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiYmxhY2tcIjtcbiAgbGV0IHJvdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgbGV0IHNhdHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDIwO1xuICBsZXQgbWFpbkNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBcIiMwMzQ2ZmZcIjtcbiAgY29uc3QgY29sb3JzTGlzdCA9IFtdO1xuICBsZXQgc3RlcDtcbiAgZm9yIChzdGVwID0gMDsgc3RlcCA8IGNvbG9yc0Ftb3VudDsgc3RlcCArPSAxKSB7XG4gICAgY29sb3JzTGlzdC5wdXNoKENvbG9yKG1haW5Db2xvcikucm90YXRlKChzdGVwICsgMSkgLyBjb2xvcnNBbW91bnQgKiAtcm90YXRlKS5zYXR1cmF0ZSgoc3RlcCArIDEpIC8gY29sb3JzQW1vdW50ICogKHNhdHVyYXRpb24gLyAxMDApKS5taXgoQ29sb3IobWl4Q29sb3IpLCBjb2xvcnNTaGlmdEFtb3VudCAvIDEwMCAqIChzdGVwICsgMSkgLyBjb2xvcnNBbW91bnQpLmhleCgpKTtcbiAgfVxuICByZXR1cm4gY29sb3JzTGlzdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlV2hpdGVMYWJlbFRoZW1lKHByaW1hcnkpIHtcbiAgY29uc3QgZGFya1NldCA9IGdldENvbG9yc0xpc3QoMywgNTAsIFwiYmxhY2tcIiwgMCwgMjAsIHByaW1hcnkpO1xuICBjb25zdCBsaWdodFNldCA9IGdldENvbG9yc0xpc3QoNiwgODUsIFwid2hpdGVcIiwgMCwgMjAsIHByaW1hcnkpO1xuICByZXR1cm4gWy4uLmRhcmtTZXQucmV2ZXJzZSgpLCBwcmltYXJ5LCAuLi5saWdodFNldF07XG59XG5mdW5jdGlvbiBhcHBseVdoaXRlTGFiZWxUaGVtZShyb290RWxlbWVudCwgdGhlbWUpIHtcbiAgaWYgKHRoZW1lLnByaW1hcnkpIHtcbiAgICBjb25zdCB0aGVtZVNldCA9IGdlbmVyYXRlV2hpdGVMYWJlbFRoZW1lKHRoZW1lLnByaW1hcnkpO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS05MDBcIiwgdGhlbWVTZXRbMF0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS04MDBcIiwgdGhlbWVTZXRbMV0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS03MDBcIiwgdGhlbWVTZXRbMl0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS02MDBcIiwgdGhlbWVTZXRbM10pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS01MDBcIiwgdGhlbWVTZXRbNF0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS00MDBcIiwgdGhlbWVTZXRbNV0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS0zMDBcIiwgdGhlbWVTZXRbNl0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS0yMDBcIiwgdGhlbWVTZXRbN10pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS0xMDBcIiwgdGhlbWVTZXRbOF0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS01MFwiLCB0aGVtZVNldFs5XSk7XG4gIH1cbiAgaWYgKHRoZW1lLm9uUHJpbWFyeSkge1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtb24tcHJpbWFyeVwiLCB0aGVtZS5vblByaW1hcnkpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJVSUxEX0VOViwgQnJvd3NlclN0b3JhZ2UsIExBTkdVQUdFUywgTEFOR1VBR0VfTUFQLCBMT0dJTl9QUk9WSURFUiwgTUZBX0ZBQ1RPUiwgTUZBX0xFVkVMUywgTWVtb3J5U3RvcmUsIE9QRU5MT0dJTl9BQ1RJT05TLCBPUEVOTE9HSU5fTkVUV09SSywgU1VQUE9SVEVEX0tFWV9DVVJWRVMsIFRIRU1FX01PREVTLCBVWF9NT0RFLCBhcHBseVdoaXRlTGFiZWxUaGVtZSwgYmFzZTY0dG9KU09OLCBiYXNlNjR1cmwsIGdlbmVyYXRlV2hpdGVMYWJlbFRoZW1lLCBnZXRDb2xvcnNMaXN0LCBqc29uVG9CYXNlNjQsIHNhZmVhdG9iLCBzYWZlYnRvYSwgc3RvcmFnZUF2YWlsYWJsZSwgc3RvcmVLZXkgfTtcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJiYXNlNjR1cmxMaWIiLCJfb2JqZWN0U3ByZWFkIiwiVE9SVVNfU0FQUEhJUkVfTkVUV09SSyIsIlRPUlVTX0xFR0FDWV9ORVRXT1JLIiwiQ29sb3IiLCJiYXNlNjR1cmwiLCJzYWZlYnRvYSIsInN0ciIsImVuY29kZSIsInNhZmVhdG9iIiwiZGVjb2RlIiwiYmFzZTY0dG9KU09OIiwiYjY0c3RyIiwiSlNPTiIsInBhcnNlIiwianNvblRvQmFzZTY0IiwianNvbiIsInN0cmluZ2lmeSIsInN0b3JhZ2VBdmFpbGFibGUiLCJ0eXBlIiwic3RvcmFnZUV4aXN0cyIsInN0b3JhZ2VMZW5ndGgiLCJzdG9yYWdlIiwid2luZG93IiwibGVuZ3RoIiwieCIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZXJyIiwiZXJyb3IiLCJjb2RlIiwibmFtZSIsIk1lbW9yeVN0b3JlIiwiY29uc3RydWN0b3IiLCJNYXAiLCJnZXRJdGVtIiwia2V5Iiwic3RvcmUiLCJnZXQiLCJ2YWx1ZSIsInNldCIsImRlbGV0ZSIsIkJyb3dzZXJTdG9yYWdlIiwic3RvcmVLZXkiLCJfc3RvcmVLZXkiLCJyZXNldFN0b3JlIiwiZ2V0SW5zdGFuY2UiLCJzdG9yYWdlS2V5IiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiaW5zdGFuY2VNYXAiLCJoYXMiLCJsb2NhbFN0b3JhZ2UiLCJzZXNzaW9uU3RvcmFnZSIsInRvSlNPTiIsImN1cnJTdG9yZSIsImdldFN0b3JlIiwiVVhfTU9ERSIsIlBPUFVQIiwiUkVESVJFQ1QiLCJPUEVOTE9HSU5fTkVUV09SSyIsIlNVUFBPUlRFRF9LRVlfQ1VSVkVTIiwiU0VDUDI1NksxIiwiRUQyNTUxOSIsIkxPR0lOX1BST1ZJREVSIiwiR09PR0xFIiwiRkFDRUJPT0siLCJSRURESVQiLCJESVNDT1JEIiwiVFdJVENIIiwiQVBQTEUiLCJMSU5FIiwiR0lUSFVCIiwiS0FLQU8iLCJMSU5LRURJTiIsIlRXSVRURVIiLCJXRUlCTyIsIldFQ0hBVCIsIkZBUkNBU1RFUiIsIkVNQUlMX1BBU1NXT1JETEVTUyIsIlNNU19QQVNTV09SRExFU1MiLCJXRUJBVVRITiIsIkpXVCIsIk1GQV9MRVZFTFMiLCJERUZBVUxUIiwiT1BUSU9OQUwiLCJNQU5EQVRPUlkiLCJOT05FIiwiT1BFTkxPR0lOX0FDVElPTlMiLCJMT0dJTiIsIkVOQUJMRV9NRkEiLCJNQU5BR0VfTUZBIiwiTU9ESUZZX1NPQ0lBTF9GQUNUT1IiLCJCVUlMRF9FTlYiLCJQUk9EVUNUSU9OIiwiREVWRUxPUE1FTlQiLCJTVEFHSU5HIiwiVEVTVElORyIsIkxBTkdVQUdFUyIsImVuIiwiamEiLCJrbyIsImRlIiwiemgiLCJlcyIsImZyIiwicHQiLCJubCIsInRyIiwiTEFOR1VBR0VfTUFQIiwiVEhFTUVfTU9ERVMiLCJsaWdodCIsImRhcmsiLCJhdXRvIiwiTUZBX0ZBQ1RPUiIsIkRFVklDRSIsIkJBQ0tVUF9TSEFSRSIsIlNPQ0lBTF9CQUNLVVAiLCJQQVNTV09SRCIsIlBBU1NLRVlTIiwiQVVUSEVOVElDQVRPUiIsImdldENvbG9yc0xpc3QiLCJjb2xvcnNBbW91bnQiLCJjb2xvcnNTaGlmdEFtb3VudCIsIm1peENvbG9yIiwicm90YXRlIiwic2F0dXJhdGlvbiIsIm1haW5Db2xvciIsImNvbG9yc0xpc3QiLCJzdGVwIiwicHVzaCIsInNhdHVyYXRlIiwibWl4IiwiaGV4IiwiZ2VuZXJhdGVXaGl0ZUxhYmVsVGhlbWUiLCJwcmltYXJ5IiwiZGFya1NldCIsImxpZ2h0U2V0IiwicmV2ZXJzZSIsImFwcGx5V2hpdGVMYWJlbFRoZW1lIiwicm9vdEVsZW1lbnQiLCJ0aGVtZSIsInRoZW1lU2V0Iiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsIm9uUHJpbWFyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUTTON_POSITION: () => (/* binding */ BUTTON_POSITION),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   TORUS_BUILD_ENV: () => (/* binding */ TORUS_BUILD_ENV),\n/* harmony export */   TorusInPageProvider: () => (/* binding */ TorusInPageProvider),\n/* harmony export */   \"default\": () => (/* binding */ Torus)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/base-controllers */ \"(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! eth-rpc-errors */ \"(ssr)/./node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__);\n\n\n\n\n\n\n\n\n\n\nvar version = \"2.1.0\";\n/* eslint-disable @typescript-eslint/no-explicit-any */ function isStream(stream) {\n    return stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\n}\nfunction isWritableStream(stream) {\n    return isStream(stream) && stream.writable !== false && typeof stream._write === \"function\" && typeof stream._writableState === \"object\";\n}\nfunction isReadableStream(stream) {\n    return isStream(stream) && stream.readable !== false && typeof stream._read === \"function\" && typeof stream._readableState === \"object\";\n}\nfunction isDuplexStream(stream) {\n    return isWritableStream(stream) && isReadableStream(stream);\n}\nvar messages = {\n    errors: {\n        disconnected: ()=>\"Torus: Lost connection to Torus.\",\n        permanentlyDisconnected: ()=>\"Torus: Disconnected from iframe. Page reload required.\",\n        unsupportedSync: (method)=>`Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,\n        invalidDuplexStream: ()=>\"Must provide a Node.js-style duplex stream.\",\n        invalidOptions: (maxEventListeners)=>`Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,\n        invalidRequestArgs: ()=>`Expected a single, non-array, object argument.`,\n        invalidRequestMethod: ()=>`'args.method' must be a non-empty string.`,\n        invalidRequestParams: ()=>`'args.params' must be an object or array if provided.`,\n        invalidLoggerObject: ()=>`'args.logger' must be an object if provided.`,\n        invalidLoggerMethod: (method)=>`'args.logger' must include required method '${method}'.`\n    },\n    info: {\n        connected: (chainId)=>`Torus: Connected to chain with ID \"${chainId}\".`\n    },\n    warnings: {}\n};\nconst PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nconst TORUS_BUILD_ENV = {\n    PRODUCTION: \"production\",\n    DEVELOPMENT: \"development\",\n    TESTING: \"testing\"\n};\nconst BUTTON_POSITION = {\n    BOTTOM_LEFT: \"bottom-left\",\n    TOP_LEFT: \"top-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    TOP_RIGHT: \"top-right\"\n};\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst translations = {\n    en: {\n        embed: {\n            continue: \"Continue\",\n            actionRequired: \"Authorization required\",\n            pendingAction: \"Click continue to proceed with your request in a popup\",\n            cookiesRequired: \"Cookies Required\",\n            enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n            clickHere: \"More Info\"\n        }\n    },\n    de: {\n        embed: {\n            continue: \"Fortsetzen\",\n            actionRequired: \"Autorisierung erforderlich\",\n            pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n            cookiesRequired: \"Cookies ben\\xf6tigt\",\n            enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n            clickHere: \"Mehr Info\"\n        }\n    },\n    ja: {\n        embed: {\n            continue: \"\",\n            actionRequired: \"\",\n            pendingAction: \"\",\n            cookiesRequired: \"\",\n            enableCookies: \"TorusCookie\",\n            clickHere: \"\"\n        }\n    },\n    ko: {\n        embed: {\n            continue: \"\",\n            actionRequired: \" \",\n            pendingAction: \"    .\",\n            cookiesRequired: \" \",\n            enableCookies: \"     Torus .\",\n            clickHere: \"  \"\n        }\n    },\n    zh: {\n        embed: {\n            continue: \"\",\n            actionRequired: \"\",\n            pendingAction: \"\",\n            cookiesRequired: \"Cookie\",\n            enableCookies: \"cookieTorus\",\n            clickHere: \"\"\n        }\n    }\n};\nvar configuration = {\n    supportedVerifierList: [\n        LOGIN_PROVIDER.GOOGLE,\n        LOGIN_PROVIDER.REDDIT,\n        LOGIN_PROVIDER.DISCORD\n    ],\n    api: \"https://api.tor.us\",\n    translations,\n    prodTorusUrl: \"\",\n    localStorageKeyPrefix: `torus-`\n};\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_8___default().getLogger(\"solana-embed\");\n// utility functions\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */ function createErrorMiddleware() {\n    return (req, res, next)=>{\n        // json-rpc-engine will terminate the request when it notices this error\n        if (typeof req.method !== \"string\" || !req.method) {\n            res.error = eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: `The request 'method' must be a non-empty string.`,\n                data: req\n            });\n        }\n        next((done)=>{\n            const { error } = res;\n            if (!error) {\n                return done();\n            }\n            log.error(`Torus - RPC Error: ${error.message}`, error);\n            return done();\n        });\n    };\n}\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */ function logStreamDisconnectWarning(remoteLabel, error, emitter) {\n    let warningMsg = `Torus: Lost connection to \"${remoteLabel}\".`;\n    if (error?.stack) {\n        warningMsg += `\\n${error.stack}`;\n    }\n    log.warn(warningMsg);\n    if (emitter && emitter.listenerCount(\"error\") > 0) {\n        emitter.emit(\"error\", warningMsg);\n    }\n}\nconst getWindowId = ()=>Math.random().toString(36).slice(2);\nconst getTorusUrl = async (buildEnv)=>{\n    let torusUrl;\n    let logLevel;\n    // const versionUsed = version;\n    // log.info(\"solana embed version used: \", versionUsed);\n    switch(buildEnv){\n        case \"testing\":\n            torusUrl = \"https://solana-testing.tor.us\";\n            logLevel = \"debug\";\n            break;\n        case \"development\":\n            torusUrl = \"http://localhost:8080\";\n            logLevel = \"debug\";\n            break;\n        default:\n            torusUrl = `https://solana.tor.us`;\n            logLevel = \"error\";\n            break;\n    }\n    return {\n        torusUrl,\n        logLevel\n    };\n};\nconst getUserLanguage = ()=>{\n    let userLanguage = window.navigator.language || \"en-US\";\n    const userLanguages = userLanguage.split(\"-\");\n    userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n    return userLanguage;\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 600,\n    width: 400\n};\nfunction storageAvailable(type) {\n    let storage;\n    try {\n        storage = window[type];\n        const x = \"__storage_test__\";\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    } catch (error) {\n        const e = error;\n        return e && // everything except Firefox\n        (e.code === 22 || // Firefox\n        e.code === 1014 || // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === \"QuotaExceededError\" || // Firefox\n        e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n        storage && storage.length !== 0;\n    }\n}\n/**\n * popup handler utils\n */ function getPopupFeatures(_ref) {\n    let { width: w, height: h } = _ref;\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nclass BaseProvider extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.SafeEventEmitter {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super();\n        /**\n     * Indicating that this provider is a Torus provider.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isTorus\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_rpcEngine\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"jsonRpcConnectionEvents\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_state\", void 0);\n        if (!isDuplexStream(connectionStream)) {\n            throw new Error(messages.errors.invalidDuplexStream());\n        }\n        this.isTorus = true;\n        this.setMaxListeners(maxEventListeners);\n        this._handleConnect = this._handleConnect.bind(this);\n        this._handleDisconnect = this._handleDisconnect.bind(this);\n        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n        this._rpcRequest = this._rpcRequest.bind(this);\n        this._initializeState = this._initializeState.bind(this);\n        this.request = this.request.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        // this.enable = this.enable.bind(this);\n        // setup connectionStream multiplexing\n        const mux = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.ObjectMultiplex();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"Torus\"));\n        // ignore phishing warning message (handled elsewhere)\n        mux.ignoreStream(\"phishing\");\n        // setup own event listeners\n        // connect to async provider\n        const jsonRpcConnection = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.createStreamMiddleware)();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"Torus RpcProvider\"));\n        // handle RPC requests via dapp-side rpc engine\n        const rpcEngine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.JRPCEngine();\n        rpcEngine.push((0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.createIdRemapMiddleware)());\n        rpcEngine.push(createErrorMiddleware());\n        rpcEngine.push((0,_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.createLoggerMiddleware)({\n            origin: location.origin\n        }));\n        rpcEngine.push(jsonRpcConnection.middleware);\n        this._rpcEngine = rpcEngine;\n        this.jsonRpcConnectionEvents = jsonRpcConnection.events;\n    }\n    /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   */ async request(args) {\n        if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestArgs(),\n                data: args\n            });\n        }\n        const { method, params } = args;\n        if (typeof method !== \"string\" || method.length === 0) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestMethod(),\n                data: args\n            });\n        }\n        if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestParams(),\n                data: args\n            });\n        }\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest({\n                method,\n                params\n            }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ send(payload, callback) {\n        this._rpcRequest(payload, callback);\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ sendAsync(payload) {\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest(payload, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits TorusInpageProvider#disconnect\n   */ _handleStreamDisconnect(streamName, error) {\n        logStreamDisconnectWarning(streamName, error, this);\n        this._handleDisconnect(false, error ? error.message : undefined);\n    }\n}\nconst htmlToElement = (html)=>{\n    const template = window.document.createElement(\"template\");\n    const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n    template.innerHTML = trimmedHtml;\n    return template.content.firstChild;\n};\nfunction isLegacyTransactionInstance(transaction) {\n    return transaction.version === undefined;\n}\nclass PopupHandler extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.SafeEventEmitter {\n    constructor(_ref){\n        let { url, target, features, timeout = 30000 } = _ref;\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"url\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"features\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"window\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"windowTimer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"iClosedWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"timeout\", void 0);\n        this.url = url;\n        this.target = target || \"_blank\";\n        this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\n        this.window = undefined;\n        this.windowTimer = undefined;\n        this.iClosedWindow = false;\n        this.timeout = timeout;\n        this._setupTimer();\n    }\n    _setupTimer() {\n        this.windowTimer = Number(setInterval(()=>{\n            if (this.window && this.window.closed) {\n                clearInterval(this.windowTimer);\n                setTimeout(()=>{\n                    if (!this.iClosedWindow) {\n                        this.emit(\"close\");\n                    }\n                    this.iClosedWindow = false;\n                    this.window = undefined;\n                }, this.timeout);\n            }\n            if (this.window === undefined) clearInterval(this.windowTimer);\n        }, 500));\n    }\n    open() {\n        this.window = window.open(this.url.href, this.target, this.features);\n        if (this.window?.focus) this.window.focus();\n        return Promise.resolve();\n    }\n    close() {\n        this.iClosedWindow = true;\n        if (this.window) this.window.close();\n    }\n    redirect(locationReplaceOnRedirect) {\n        if (locationReplaceOnRedirect) {\n            window.location.replace(this.url.href);\n        } else {\n            window.location.href = this.url.href;\n        }\n    }\n}\nclass TorusCommunicationProvider extends BaseProvider {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"embedTranslations\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"windowRefs\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"tryWindowHandle\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusIframe\", void 0);\n        this._state = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, TorusCommunicationProvider._defaultState);\n        // public state\n        this.torusUrl = \"\";\n        this.dappStorageKey = \"\";\n        const languageTranslations = configuration.translations[getUserLanguage()];\n        this.embedTranslations = languageTranslations.embed;\n        this.windowRefs = {};\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const notificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\n                const { isFullScreen, rid } = params;\n                this._displayIframe({\n                    isFull: isFullScreen,\n                    rid: rid\n                });\n            // TODO: remove this method when wallet adds versioning and stops supporting this method\n            } else if (method === \"create_window\") {\n                const { windowId, url } = params;\n                this._createPopupBlockAlert(windowId, url);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\n                this._handleCloseWindow(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\n                const { currentLoginProvider } = params;\n                this._state.isLoggedIn = true;\n                this._state.currentLoginProvider = currentLoginProvider;\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\n                this._state.isLoggedIn = false;\n                this._state.currentLoginProvider = null;\n                this._displayIframe();\n            }\n        };\n        this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\n    }\n    get isLoggedIn() {\n        return this._state.isLoggedIn;\n    }\n    get isIFrameFullScreen() {\n        return this._state.isIFrameFullScreen;\n    }\n    /**\n   * Returns whether the inPage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    async _initializeState(params) {\n        try {\n            const { torusUrl, dappStorageKey, torusAlertContainer, torusIframe } = params;\n            this.torusUrl = torusUrl;\n            this.dappStorageKey = dappStorageKey;\n            this.torusAlertContainer = torusAlertContainer;\n            this.torusIframe = torusIframe;\n            this.torusIframe.addEventListener(\"load\", ()=>{\n                // only do this if iframe is not full screen\n                if (!this._state.isIFrameFullScreen) this._displayIframe();\n            });\n            const { currentLoginProvider, isLoggedIn } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this._handleConnect(currentLoginProvider, isLoggedIn);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized communication state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    _handleWindow(windowId) {\n        let { url, target, features } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const finalUrl = new URL(url || `${this.torusUrl}/redirect?windowId=${windowId}`);\n        if (this.dappStorageKey) {\n            // If multiple instances, it returns the first one\n            if (finalUrl.hash) finalUrl.hash += `&dappStorageKey=${this.dappStorageKey}`;\n            else finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        const handledWindow = new PopupHandler({\n            url: finalUrl,\n            target,\n            features\n        });\n        handledWindow.open();\n        if (!handledWindow.window) {\n            this._createPopupBlockAlert(windowId, finalUrl.href);\n            return;\n        }\n        // Add to collection only if window is opened\n        this.windowRefs[windowId] = handledWindow;\n        // We tell the iframe that the window has been successfully opened\n        this.request({\n            method: \"opened_window\",\n            params: {\n                windowId\n            }\n        });\n        handledWindow.once(\"close\", ()=>{\n            // user closed the window\n            delete this.windowRefs[windowId];\n            this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\n                params: {\n                    windowId\n                }\n            });\n        });\n    }\n    _displayIframe() {\n        let { isFull = false, rid = \"\" } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const style = {};\n        // set phase\n        if (!isFull) {\n            style.display = this._state.torusWidgetVisibility ? \"block\" : \"none\";\n            style.height = \"70px\";\n            style.width = \"70px\";\n            switch(this._state.buttonPosition){\n                case BUTTON_POSITION.TOP_LEFT:\n                    style.top = \"0px\";\n                    style.left = \"0px\";\n                    style.right = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.TOP_RIGHT:\n                    style.top = \"0px\";\n                    style.right = \"0px\";\n                    style.left = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_RIGHT:\n                    style.bottom = \"0px\";\n                    style.right = \"0px\";\n                    style.top = \"auto\";\n                    style.left = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_LEFT:\n                default:\n                    style.bottom = \"0px\";\n                    style.left = \"0px\";\n                    style.top = \"auto\";\n                    style.right = \"auto\";\n                    break;\n            }\n        } else {\n            style.display = \"block\";\n            style.width = \"100%\";\n            style.height = \"100%\";\n            style.top = \"0px\";\n            style.right = \"0px\";\n            style.left = \"0px\";\n            style.bottom = \"0px\";\n        }\n        Object.assign(this.torusIframe.style, style);\n        this._state.isIFrameFullScreen = isFull;\n        this.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\n            params: {\n                isIFrameFullScreen: isFull,\n                rid\n            }\n        });\n    }\n    hideTorusButton() {\n        this._state.torusWidgetVisibility = false;\n        this._displayIframe();\n    }\n    showTorusButton() {\n        this._state.torusWidgetVisibility = true;\n        this._displayIframe();\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        const cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param currentLoginProvider - The login Provider\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(currentLoginProvider, isLoggedIn) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                currentLoginProvider,\n                isLoggedIn\n            });\n            log.debug(messages.info.connected(currentLoginProvider));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this._state.currentLoginProvider = null;\n                this._state.isLoggedIn = false;\n                this._state.torusWidgetVisibility = false;\n                this._state.isIFrameFullScreen = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    // Called if the iframe wants to close the window cause it is done processing the request\n    _handleCloseWindow(params) {\n        const { windowId } = params;\n        if (this.windowRefs[windowId]) {\n            this.windowRefs[windowId].close();\n            delete this.windowRefs[windowId];\n        }\n    }\n    async _createPopupBlockAlert(windowId, url) {\n        const logoUrl = this.getLogoUrl();\n        const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + `<div id=\"torusAlert__logo\"><img src=\"${logoUrl}\" /></div>` + \"<div>\" + `<h1 id=\"torusAlert__title\">${this.embedTranslations.actionRequired}</h1>` + `<p id=\"torusAlert__desc\">${this.embedTranslations.pendingAction}</p>` + \"</div>\" + \"</div>\");\n        const successAlert = htmlToElement(`<div><a id=\"torusAlert__btn\">${this.embedTranslations.continue}</a></div>`);\n        const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n        btnContainer.appendChild(successAlert);\n        torusAlert.appendChild(btnContainer);\n        const bindOnLoad = ()=>{\n            successAlert.addEventListener(\"click\", ()=>{\n                this._handleWindow(windowId, {\n                    url,\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                torusAlert.remove();\n                if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n            });\n        };\n        const attachOnLoad = ()=>{\n            this.torusAlertContainer.appendChild(torusAlert);\n        };\n        attachOnLoad();\n        bindOnLoad();\n        this.torusAlertContainer.style.display = \"block\";\n    }\n    getLogoUrl() {\n        const logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;\n        return logoUrl;\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(TorusCommunicationProvider, \"_defaultState\", {\n    buttonPosition: \"bottom-left\",\n    currentLoginProvider: null,\n    isIFrameFullScreen: false,\n    hasEmittedConnection: false,\n    torusWidgetVisibility: false,\n    initialized: false,\n    isLoggedIn: false,\n    isPermanentlyDisconnected: false,\n    isConnected: false\n});\nclass TorusInPageProvider extends BaseProvider {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        /**\n     * The chain ID of the currently connected Solana chain.\n     * See [chainId.network]{@link https://chainid.network} for more information.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"chainId\", void 0);\n        /**\n     * The user's currently selected Solana address.\n     * If null, Torus is either locked or the user has not permitted any\n     * addresses to be viewed.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"selectedAddress\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"tryWindowHandle\", void 0);\n        this._state = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, TorusInPageProvider._defaultState);\n        // public state\n        this.selectedAddress = null;\n        this.chainId = null;\n        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n        this._handleChainChanged = this._handleChainChanged.bind(this);\n        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const jsonRpcNotificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\n                this._handleAccountsChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\n                this._handleUnlockStateChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\n                this._handleChainChanged(params);\n            }\n        };\n        // json rpc notification listener\n        this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\n    }\n    /**\n   * Returns whether the inpage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    // Private Methods\n    //= ===================\n    /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */ async _initializeState() {\n        try {\n            const { accounts, chainId, isUnlocked } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this.emit(\"connect\", {\n                chainId\n            });\n            this._handleChainChanged({\n                chainId\n            });\n            this._handleUnlockStateChanged({\n                accounts,\n                isUnlocked\n            });\n            this._handleAccountsChanged(accounts);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized provider state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        let cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n            if (_payload.method === \"solana_accounts\" || _payload.method === \"solana_requestAccounts\") {\n                // handle accounts changing\n                cb = (err, res)=>{\n                    this._handleAccountsChanged(res.result || [], _payload.method === \"solana_accounts\", isInternal);\n                    callback(err, res);\n                };\n            } else if (_payload.method === \"wallet_getProviderState\") {\n                this._rpcEngine.handle(payload, cb);\n                return;\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(chainId) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                chainId\n            });\n            log.debug(messages.info.connected(chainId));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this.chainId = null;\n                this._state.accounts = null;\n                this.selectedAddress = null;\n                this._state.isUnlocked = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    /**\n   * Called when accounts may have changed.\n   */ _handleAccountsChanged(accounts) {\n        let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        // defensive programming\n        let finalAccounts = accounts;\n        if (!Array.isArray(finalAccounts)) {\n            log.error(\"Torus: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n            finalAccounts = [];\n        }\n        for (const account of accounts){\n            if (typeof account !== \"string\") {\n                log.error(\"Torus: Received non-string account. Please report this bug.\", accounts);\n                finalAccounts = [];\n                break;\n            }\n        }\n        // emit accountsChanged if anything about the accounts array has changed\n        if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default()(this._state.accounts, finalAccounts)) {\n            // we should always have the correct accounts even before solana_accounts\n            // returns, except in cases where isInternal is true\n            if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n                log.error('Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n            }\n            this._state.accounts = finalAccounts;\n            this.emit(\"accountsChanged\", finalAccounts);\n        }\n        // handle selectedAddress\n        if (this.selectedAddress !== finalAccounts[0]) {\n            this.selectedAddress = finalAccounts[0] || null;\n        }\n    }\n    /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits TorusInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */ _handleChainChanged() {\n        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!chainId) {\n            log.error(\"Torus: Received invalid network parameters. Please report this bug.\", {\n                chainId\n            });\n            return;\n        }\n        if (chainId === \"loading\") {\n            this._handleDisconnect(true);\n        } else {\n            this._handleConnect(chainId);\n            if (chainId !== this.chainId) {\n                this.chainId = chainId;\n                if (this._state.initialized) {\n                    this.emit(\"chainChanged\", this.chainId);\n                }\n            }\n        }\n    }\n    /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */ _handleUnlockStateChanged() {\n        let { accounts, isUnlocked } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (typeof isUnlocked !== \"boolean\") {\n            log.error(\"Torus: Received invalid isUnlocked parameter. Please report this bug.\", {\n                isUnlocked\n            });\n            return;\n        }\n        if (isUnlocked !== this._state.isUnlocked) {\n            this._state.isUnlocked = isUnlocked;\n            this._handleAccountsChanged(accounts || []);\n        }\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(TorusInPageProvider, \"_defaultState\", {\n    accounts: null,\n    isConnected: false,\n    isUnlocked: false,\n    initialized: false,\n    isPermanentlyDisconnected: false,\n    hasEmittedConnection: false\n});\n/**\n * Returns whether the given image URL exists\n */ function imgExists(url) {\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = document.createElement(\"img\");\n            img.onload = ()=>resolve(true);\n            img.onerror = ()=>resolve(false);\n            img.src = url;\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n/**\n * Extracts a name for the site from the DOM\n */ const getSiteName = (window1)=>{\n    const { document: document1 } = window1;\n    const siteName = document1.querySelector('head > meta[property=\"og:site_name\"]');\n    if (siteName) {\n        return siteName.content;\n    }\n    const metaTitle = document1.querySelector('head > meta[name=\"title\"]');\n    if (metaTitle) {\n        return metaTitle.content;\n    }\n    if (document1.title && document1.title.length > 0) {\n        return document1.title;\n    }\n    return window1.location.hostname;\n};\n/**\n * Extracts an icon for the site from the DOM\n */ async function getSiteIcon(window1) {\n    try {\n        const { document: document1 } = window1;\n        // Use the site's favicon if it exists\n        let icon = document1.querySelector('head > link[rel=\"shortcut icon\"]');\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        // Search through available icons in no particular order\n        icon = Array.from(document1.querySelectorAll('head > link[rel=\"icon\"]')).find((_icon)=>Boolean(_icon.href));\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        return \"\";\n    } catch (error) {\n        return \"\";\n    }\n}\n/**\n * Gets site metadata and returns it\n *\n */ const getSiteMetadata = async ()=>({\n        name: getSiteName(window),\n        icon: await getSiteIcon(window)\n    });\nconst PROVIDER_UNSAFE_METHODS = [\n    \"send_transaction\",\n    \"sign_transaction\",\n    \"sign_all_transactions\",\n    \"sign_message\",\n    \"connect\"\n];\nconst COMMUNICATION_UNSAFE_METHODS = [\n    _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER\n];\nconst isLocalStorageAvailable = storageAvailable(\"localStorage\");\n// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n(async function preLoadIframe() {\n    try {\n        if (typeof document === \"undefined\") return;\n        const torusIframeHtml = document.createElement(\"link\");\n        const { torusUrl } = await getTorusUrl(\"production\");\n        torusIframeHtml.href = `${torusUrl}/frame`;\n        torusIframeHtml.crossOrigin = \"anonymous\";\n        torusIframeHtml.type = \"text/html\";\n        torusIframeHtml.rel = \"prefetch\";\n        if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n            if (torusIframeHtml.relList.supports(\"prefetch\")) {\n                document.head.appendChild(torusIframeHtml);\n            }\n        }\n    } catch (error) {\n        log.warn(error);\n    }\n})();\nclass Torus {\n    constructor(){\n        let { modalZIndex = 99999 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isInitialized\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlert\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"modalZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"alertZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"requestedLoginProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"provider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"communicationProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isTopupHidden\", false);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusIframe\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"styleLink\", void 0);\n        this.torusUrl = \"\";\n        this.isInitialized = false; // init done\n        this.requestedLoginProvider = null;\n        this.modalZIndex = modalZIndex;\n        this.alertZIndex = modalZIndex + 1000;\n        this.dappStorageKey = \"\";\n    }\n    get isLoggedIn() {\n        if (!this.communicationProvider) return false;\n        return this.communicationProvider.isLoggedIn;\n    }\n    async init() {\n        let { buildEnv = TORUS_BUILD_ENV.PRODUCTION, enableLogging = false, network, showTorusButton = false, useLocalStorage = false, buttonPosition = BUTTON_POSITION.BOTTOM_LEFT, apiKey = \"torus-default\", extraParams = {}, whiteLabel } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (this.isInitialized) throw new Error(\"Already initialized\");\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_4__.setAPIKey)(apiKey);\n        const { torusUrl, logLevel } = await getTorusUrl(buildEnv);\n        log.enableAll();\n        log.info(torusUrl, \"url loaded\");\n        log.info(`Solana Embed Version :${version}`);\n        this.torusUrl = torusUrl;\n        log.setDefaultLevel(logLevel);\n        if (enableLogging) log.enableAll();\n        else log.disableAll();\n        const dappStorageKey = this.handleDappStorageKey(useLocalStorage);\n        const torusIframeUrl = new URL(torusUrl);\n        if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";\n        else torusIframeUrl.pathname += \"/frame\";\n        const hashParams = new URLSearchParams();\n        if (dappStorageKey) hashParams.append(\"dappStorageKey\", dappStorageKey);\n        hashParams.append(\"origin\", window.location.origin);\n        torusIframeUrl.hash = hashParams.toString();\n        // Iframe code\n        this.torusIframe = htmlToElement(`<iframe\n        id=\"torusIframe\"\n        class=\"torusIframe\"\n        src=\"${torusIframeUrl.href}\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}\"\n      ></iframe>`);\n        this.torusAlertContainer = htmlToElement(`<div id=\"torusAlertContainer\" style=\"display:none; z-index: ${this.alertZIndex.toString()}\"></div>`);\n        this.styleLink = htmlToElement(`<link href=\"${torusUrl}/css/widget.css\" rel=\"stylesheet\" type=\"text/css\">`);\n        return new Promise((resolve, reject)=>{\n            try {\n                this.torusIframe.addEventListener(\"load\", async ()=>{\n                    const dappMetadata = await getSiteMetadata();\n                    // send init params here\n                    this.torusIframe.contentWindow.postMessage({\n                        buttonPosition,\n                        apiKey,\n                        network,\n                        dappMetadata,\n                        extraParams,\n                        whiteLabel\n                    }, torusIframeUrl.origin);\n                    await this._setupWeb3({\n                        torusUrl\n                    });\n                    if (showTorusButton) this.showTorusButton();\n                    if (whiteLabel?.topupHide) this.isTopupHidden = whiteLabel.topupHide;\n                    else this.hideTorusButton();\n                    this.isInitialized = true;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    window.torus = this;\n                    resolve();\n                });\n                window.document.head.appendChild(this.styleLink);\n                window.document.body.appendChild(this.torusIframe);\n                window.document.body.appendChild(this.torusAlertContainer);\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    async login() {\n        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        try {\n            this.requestedLoginProvider = params.loginProvider || null;\n            if (!this.requestedLoginProvider) {\n                this.communicationProvider._displayIframe({\n                    isFull: true\n                });\n            }\n            // If user is already logged in, we assume they have given access to the website\n            const res = await new Promise((resolve, reject)=>{\n                // We use this method because we want to update inPage provider state with account info\n                this.provider._rpcRequest({\n                    method: \"solana_requestAccounts\",\n                    params: [\n                        this.requestedLoginProvider,\n                        params.login_hint\n                    ]\n                }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n            });\n            if (Array.isArray(res) && res.length > 0) {\n                return res;\n            }\n            // This would never happen, but just in case\n            throw new Error(\"Login failed\");\n        } catch (error) {\n            log.error(\"login failed\", error);\n            throw error;\n        } finally{\n            if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();\n        }\n    }\n    async loginWithPrivateKey(loginParams) {\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        const { privateKey, userInfo } = loginParams;\n        const { success } = await this.communicationProvider.request({\n            method: \"login_with_private_key\",\n            params: {\n                privateKey,\n                userInfo\n            }\n        });\n        if (!success) throw new Error(\"Login Failed\");\n    }\n    async logout() {\n        if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.LOGOUT,\n            params: []\n        });\n        this.requestedLoginProvider = null;\n    }\n    async cleanUp() {\n        if (this.communicationProvider.isLoggedIn) {\n            await this.logout();\n        }\n        this.clearInit();\n    }\n    clearInit() {\n        function isElement(element) {\n            return element instanceof Element || element instanceof Document;\n        }\n        if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n            this.styleLink.remove();\n            this.styleLink = undefined;\n        }\n        if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n            this.torusIframe.remove();\n            this.torusIframe = undefined;\n        }\n        if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n            this.torusAlert = undefined;\n            this.torusAlertContainer.remove();\n            this.torusAlertContainer = undefined;\n        }\n        this.isInitialized = false;\n    }\n    hideTorusButton() {\n        this.communicationProvider.hideTorusButton();\n    }\n    showTorusButton() {\n        this.communicationProvider.showTorusButton();\n    }\n    async setProvider(params) {\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER,\n            params: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, params)\n        });\n    }\n    async showWallet(path) {\n        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const instanceId = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,\n            params: []\n        });\n        const finalPath = path ? `/${path}` : \"\";\n        const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);\n        // Using URL constructor to prevent js injection and allow parameter validation.!\n        finalUrl.searchParams.append(\"instanceId\", instanceId);\n        Object.keys(params).forEach((x)=>{\n            finalUrl.searchParams.append(x, params[x]);\n        });\n        if (this.dappStorageKey) {\n            finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        // No need to track this window state. Hence, no _handleWindow call.\n        const walletWindow = new PopupHandler({\n            url: finalUrl,\n            features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)\n        });\n        walletWindow.open();\n    }\n    async getUserInfo() {\n        const userInfoResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.USER_INFO,\n            params: []\n        });\n        return userInfoResponse;\n    }\n    async initiateTopup(provider, params) {\n        if (!this.isInitialized) throw new Error(\"Torus is not initialized\");\n        const windowId = getWindowId();\n        this.communicationProvider._handleWindow(windowId);\n        const topupResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.TOPUP,\n            params: {\n                provider,\n                params,\n                windowId\n            }\n        });\n        return topupResponse;\n    }\n    // Solana specific API\n    async getAccounts() {\n        const response = await this.provider.request({\n            method: \"getAccounts\",\n            params: []\n        });\n        return response;\n    }\n    async sendTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                isLegacyTransaction\n            }\n        });\n        return response;\n    }\n    // support sendOptions\n    async signAndSendTransaction(transaction, options) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                options,\n                isLegacyTransaction\n            }\n        });\n        return {\n            signature: response\n        };\n    }\n    async signTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serializeMessage().toString(\"hex\") : Buffer.from(transaction.message.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"sign_transaction\",\n            params: {\n                message,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pair\n        const parsed = JSON.parse(response);\n        const signature = {\n            publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(parsed.publicKey),\n            signature: Buffer.from(parsed.signature, \"hex\")\n        };\n        transaction.addSignature(signature.publicKey, signature.signature);\n        return transaction;\n    }\n    async signAllTransactions(transactions) {\n        let isLegacyTransaction;\n        const encodedMessage = transactions.map((tx)=>{\n            isLegacyTransaction = isLegacyTransactionInstance(tx);\n            return isLegacyTransaction ? tx.serializeMessage().toString(\"hex\") : Buffer.from(tx.message.serialize()).toString(\"hex\");\n        });\n        const responses = await this.provider.request({\n            method: \"sign_all_transactions\",\n            params: {\n                message: encodedMessage,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pairs\n        const signatures = responses.map((item)=>{\n            const parsed = JSON.parse(item);\n            return {\n                publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(parsed.publicKey),\n                signature: Buffer.from(parsed.signature, \"hex\")\n            };\n        });\n        transactions.forEach((tx, idx)=>{\n            tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);\n            return tx;\n        });\n        return transactions;\n    }\n    async signMessage(data) {\n        const response = await this.provider.request({\n            method: \"sign_message\",\n            params: {\n                data\n            }\n        });\n        return response;\n    }\n    async getGaslessPublicKey() {\n        const response = await this.provider.request({\n            method: \"get_gasless_public_key\",\n            params: []\n        });\n        return response;\n    }\n    // async connect(): Promise<boolean> {\n    //   const response = (await this.provider.request({\n    //     method: \"connect\",\n    //     params: {},\n    //   })) as boolean;\n    //   return response;\n    // }\n    handleDappStorageKey(useLocalStorage) {\n        const localStorageKey = `${configuration.localStorageKeyPrefix}${window.location.hostname}`;\n        let dappStorageKey = \"\";\n        if (isLocalStorageAvailable && useLocalStorage) {\n            const storedKey = window.localStorage.getItem(localStorageKey);\n            if (storedKey) dappStorageKey = storedKey;\n            else {\n                const generatedKey = `torus-app-${getWindowId()}`;\n                window.localStorage.setItem(localStorageKey, generatedKey);\n                dappStorageKey = generatedKey;\n            }\n        }\n        this.dappStorageKey = dappStorageKey;\n        return dappStorageKey;\n    }\n    async _setupWeb3(providerParams) {\n        log.info(\"setupWeb3 running\");\n        // setup background connection\n        const providerStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.BasePostMessageStream({\n            name: \"embed_torus\",\n            target: \"iframe_torus\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n        const communicationStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.BasePostMessageStream({\n            name: \"embed_communication\",\n            target: \"iframe_communication\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // compose the inPage provider\n        const inPageProvider = new TorusInPageProvider(providerStream, {});\n        const communicationProvider = new TorusCommunicationProvider(communicationStream, {});\n        inPageProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {\n                if (!this.communicationProvider.isLoggedIn) throw new Error(\"User Not Logged In\");\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                // for inPageProvider methods sending windowId in request instead of params\n                // as params might be positional.\n                _payload.windowId = windowId;\n            }\n            inPageProvider._rpcEngine.handle(_payload, cb);\n        };\n        communicationProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all\n                });\n                // for communication methods sending window id in jrpc req params\n                _payload.params.windowId = windowId;\n            }\n            communicationProvider._rpcEngine.handle(_payload, cb);\n        };\n        // detect solana_requestAccounts and pipe to enable for now\n        const detectAccountRequestPrototypeModifier = (m)=>{\n            const originalMethod = inPageProvider[m];\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const self = this;\n            inPageProvider[m] = function providerFunc(request, cb) {\n                const { method, params = [] } = request;\n                if (method === \"solana_requestAccounts\") {\n                    if (!cb) return self.login({\n                        loginProvider: params[0]\n                    });\n                    self.login({\n                        loginProvider: params[0]\n                    })// eslint-disable-next-line promise/no-callback-in-promise\n                    .then((res)=>cb(null, res))// eslint-disable-next-line promise/no-callback-in-promise\n                    .catch((err)=>cb(err));\n                }\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                return originalMethod.apply(this, [\n                    request,\n                    cb\n                ]);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            };\n        };\n        // Detects call to solana_requestAccounts in request & sendAsync and passes to login\n        detectAccountRequestPrototypeModifier(\"request\");\n        detectAccountRequestPrototypeModifier(\"sendAsync\");\n        detectAccountRequestPrototypeModifier(\"send\");\n        const proxiedInPageProvider = new Proxy(inPageProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        const proxiedCommunicationProvider = new Proxy(communicationProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        this.provider = proxiedInPageProvider;\n        this.communicationProvider = proxiedCommunicationProvider;\n        await Promise.all([\n            inPageProvider._initializeState(),\n            communicationProvider._initializeState(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, providerParams), {}, {\n                dappStorageKey: this.dappStorageKey,\n                torusAlertContainer: this.torusAlertContainer,\n                torusIframe: this.torusIframe\n            }))\n        ]);\n        log.debug(\"Torus - injected provider\");\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvZGlzdC9zb2xhbmFFbWJlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ0c7QUFDeEI7QUFDaUk7QUFDekg7QUFDcUk7QUFDNUg7QUFDckM7QUFDUTtBQUNLO0FBRXJDLElBQUlxQixVQUFVO0FBRWQscURBQXFELEdBQ3JELFNBQVNDLFNBQVNDLE1BQU07SUFDdEIsT0FBT0EsV0FBVyxRQUFRLE9BQU9BLFdBQVcsWUFBWSxPQUFPQSxPQUFPQyxJQUFJLEtBQUs7QUFDakY7QUFDQSxTQUFTQyxpQkFBaUJGLE1BQU07SUFDOUIsT0FBT0QsU0FBU0MsV0FBV0EsT0FBT0csUUFBUSxLQUFLLFNBQVMsT0FBT0gsT0FBT0ksTUFBTSxLQUFLLGNBQWMsT0FBT0osT0FBT0ssY0FBYyxLQUFLO0FBQ2xJO0FBQ0EsU0FBU0MsaUJBQWlCTixNQUFNO0lBQzlCLE9BQU9ELFNBQVNDLFdBQVdBLE9BQU9PLFFBQVEsS0FBSyxTQUFTLE9BQU9QLE9BQU9RLEtBQUssS0FBSyxjQUFjLE9BQU9SLE9BQU9TLGNBQWMsS0FBSztBQUNqSTtBQUNBLFNBQVNDLGVBQWVWLE1BQU07SUFDNUIsT0FBT0UsaUJBQWlCRixXQUFXTSxpQkFBaUJOO0FBQ3REO0FBRUEsSUFBSVcsV0FBVztJQUNiQyxRQUFRO1FBQ05DLGNBQWMsSUFBTTtRQUNwQkMseUJBQXlCLElBQU07UUFDL0JDLGlCQUFpQkMsQ0FBQUEsU0FBVSxDQUFDLDZFQUE2RSxFQUFFQSxPQUFPLDhCQUE4QixDQUFDO1FBQ2pKQyxxQkFBcUIsSUFBTTtRQUMzQkMsZ0JBQWdCQyxDQUFBQSxvQkFBcUIsQ0FBQyxnREFBZ0QsRUFBRUEsa0JBQWtCLENBQUMsQ0FBQztRQUM1R0Msb0JBQW9CLElBQU0sQ0FBQyw4Q0FBOEMsQ0FBQztRQUMxRUMsc0JBQXNCLElBQU0sQ0FBQyx5Q0FBeUMsQ0FBQztRQUN2RUMsc0JB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LElBQUlxTSxLQUFLLENBQUM7SUFDWjtBQUNGO0FBRXFIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcW9nbml0YS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL3NvbGFuYS1lbWJlZC9kaXN0L3NvbGFuYUVtYmVkLmVzbS5qcz8wMDhiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUsIENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLCBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMsIFBST1ZJREVSX0pSUENfTUVUSE9EUywgUFJPVklERVJfTk9USUZJQ0FUSU9OUyB9IGZyb20gJ0B0b3J1c2xhYnMvYmFzZS1jb250cm9sbGVycyc7XG5pbXBvcnQgeyBzZXRBUElLZXkgfSBmcm9tICdAdG9ydXNsYWJzL2h0dHAtaGVscGVycyc7XG5pbXBvcnQgeyBTYWZlRXZlbnRFbWl0dGVyLCBPYmplY3RNdWx0aXBsZXgsIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUsIEpSUENFbmdpbmUsIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlLCBnZXRScGNQcm9taXNlQ2FsbGJhY2ssIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSB9IGZyb20gJ0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMnO1xuaW1wb3J0IHsgZXRoRXJyb3JzLCBFdGhlcmV1bVJwY0Vycm9yIH0gZnJvbSAnZXRoLXJwYy1lcnJvcnMnO1xuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XG5pbXBvcnQgbG9nbGV2ZWwgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IGRlcXVhbCBmcm9tICdmYXN0LWRlZXAtZXF1YWwnO1xuXG52YXIgdmVyc2lvbiA9IFwiMi4xLjBcIjtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gaXNTdHJlYW0oc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0gIT09IG51bGwgJiYgdHlwZW9mIHN0cmVhbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc3RyZWFtLnBpcGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzV3JpdGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gIHJldHVybiBpc1N0cmVhbShzdHJlYW0pICYmIHN0cmVhbS53cml0YWJsZSAhPT0gZmFsc2UgJiYgdHlwZW9mIHN0cmVhbS5fd3JpdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc3RyZWFtLl93cml0YWJsZVN0YXRlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgcmV0dXJuIGlzU3RyZWFtKHN0cmVhbSkgJiYgc3RyZWFtLnJlYWRhYmxlICE9PSBmYWxzZSAmJiB0eXBlb2Ygc3RyZWFtLl9yZWFkID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHN0cmVhbS5fcmVhZGFibGVTdGF0ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzRHVwbGV4U3RyZWFtKHN0cmVhbSkge1xuICByZXR1cm4gaXNXcml0YWJsZVN0cmVhbShzdHJlYW0pICYmIGlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbn1cblxudmFyIG1lc3NhZ2VzID0ge1xuICBlcnJvcnM6IHtcbiAgICBkaXNjb25uZWN0ZWQ6ICgpID0+IFwiVG9ydXM6IExvc3QgY29ubmVjdGlvbiB0byBUb3J1cy5cIixcbiAgICBwZXJtYW5lbnRseURpc2Nvbm5lY3RlZDogKCkgPT4gXCJUb3J1czogRGlzY29ubmVjdGVkIGZyb20gaWZyYW1lLiBQYWdlIHJlbG9hZCByZXF1aXJlZC5cIixcbiAgICB1bnN1cHBvcnRlZFN5bmM6IG1ldGhvZCA9PiBgVG9ydXM6IFRoZSBUb3J1cyBFdGhlcmV1bSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHN5bmNocm9ub3VzIG1ldGhvZHMgbGlrZSAke21ldGhvZH0gd2l0aG91dCBhIGNhbGxiYWNrIHBhcmFtZXRlci5gLFxuICAgIGludmFsaWREdXBsZXhTdHJlYW06ICgpID0+IFwiTXVzdCBwcm92aWRlIGEgTm9kZS5qcy1zdHlsZSBkdXBsZXggc3RyZWFtLlwiLFxuICAgIGludmFsaWRPcHRpb25zOiBtYXhFdmVudExpc3RlbmVycyA9PiBgSW52YWxpZCBvcHRpb25zLiBSZWNlaXZlZDogeyBtYXhFdmVudExpc3RlbmVyczogJHttYXhFdmVudExpc3RlbmVyc319YCxcbiAgICBpbnZhbGlkUmVxdWVzdEFyZ3M6ICgpID0+IGBFeHBlY3RlZCBhIHNpbmdsZSwgbm9uLWFycmF5LCBvYmplY3QgYXJndW1lbnQuYCxcbiAgICBpbnZhbGlkUmVxdWVzdE1ldGhvZDogKCkgPT4gYCdhcmdzLm1ldGhvZCcgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuYCxcbiAgICBpbnZhbGlkUmVxdWVzdFBhcmFtczogKCkgPT4gYCdhcmdzLnBhcmFtcycgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYXJyYXkgaWYgcHJvdmlkZWQuYCxcbiAgICBpbnZhbGlkTG9nZ2VyT2JqZWN0OiAoKSA9PiBgJ2FyZ3MubG9nZ2VyJyBtdXN0IGJlIGFuIG9iamVjdCBpZiBwcm92aWRlZC5gLFxuICAgIGludmFsaWRMb2dnZXJNZXRob2Q6IG1ldGhvZCA9PiBgJ2FyZ3MubG9nZ2VyJyBtdXN0IGluY2x1ZGUgcmVxdWlyZWQgbWV0aG9kICcke21ldGhvZH0nLmBcbiAgfSxcbiAgaW5mbzoge1xuICAgIGNvbm5lY3RlZDogY2hhaW5JZCA9PiBgVG9ydXM6IENvbm5lY3RlZCB0byBjaGFpbiB3aXRoIElEIFwiJHtjaGFpbklkfVwiLmBcbiAgfSxcbiAgd2FybmluZ3M6IHt9XG59O1xuXG5jb25zdCBQQVlNRU5UX1BST1ZJREVSID0ge1xuICBNT09OUEFZOiBcIm1vb25wYXlcIixcbiAgV1lSRTogXCJ3eXJlXCIsXG4gIFJBTVBORVRXT1JLOiBcInJhbXBuZXR3b3JrXCIsXG4gIFhBTlBPT0w6IFwieGFucG9vbFwiLFxuICBNRVJDVVJZTzogXCJtZXJjdXJ5b1wiLFxuICBUUkFOU0FLOiBcInRyYW5zYWtcIlxufTtcbmNvbnN0IFRPUlVTX0JVSUxEX0VOViA9IHtcbiAgUFJPRFVDVElPTjogXCJwcm9kdWN0aW9uXCIsXG4gIERFVkVMT1BNRU5UOiBcImRldmVsb3BtZW50XCIsXG4gIFRFU1RJTkc6IFwidGVzdGluZ1wiXG59O1xuY29uc3QgQlVUVE9OX1BPU0lUSU9OID0ge1xuICBCT1RUT01fTEVGVDogXCJib3R0b20tbGVmdFwiLFxuICBUT1BfTEVGVDogXCJ0b3AtbGVmdFwiLFxuICBCT1RUT01fUklHSFQ6IFwiYm90dG9tLXJpZ2h0XCIsXG4gIFRPUF9SSUdIVDogXCJ0b3AtcmlnaHRcIlxufTtcbmNvbnN0IExPR0lOX1BST1ZJREVSID0ge1xuICBHT09HTEU6IFwiZ29vZ2xlXCIsXG4gIEZBQ0VCT09LOiBcImZhY2Vib29rXCIsXG4gIFJFRERJVDogXCJyZWRkaXRcIixcbiAgRElTQ09SRDogXCJkaXNjb3JkXCIsXG4gIFRXSVRDSDogXCJ0d2l0Y2hcIixcbiAgQVBQTEU6IFwiYXBwbGVcIixcbiAgTElORTogXCJsaW5lXCIsXG4gIEdJVEhVQjogXCJnaXRodWJcIixcbiAgS0FLQU86IFwia2FrYW9cIixcbiAgTElOS0VESU46IFwibGlua2VkaW5cIixcbiAgVFdJVFRFUjogXCJ0d2l0dGVyXCIsXG4gIFdFSUJPOiBcIndlaWJvXCIsXG4gIFdFQ0hBVDogXCJ3ZWNoYXRcIixcbiAgRU1BSUxfUEFTU1dPUkRMRVNTOiBcImVtYWlsX3Bhc3N3b3JkbGVzc1wiXG59O1xuXG5jb25zdCB0cmFuc2xhdGlvbnMgPSB7XG4gIGVuOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIkNvbnRpbnVlXCIsXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCJBdXRob3JpemF0aW9uIHJlcXVpcmVkXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIkNsaWNrIGNvbnRpbnVlIHRvIHByb2NlZWQgd2l0aCB5b3VyIHJlcXVlc3QgaW4gYSBwb3B1cFwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIkNvb2tpZXMgUmVxdWlyZWRcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwiUGxlYXNlIGVuYWJsZSBjb29raWVzIGluIHlvdXIgYnJvd3NlciBwcmVmZXJlbmNlcyB0byBhY2Nlc3MgVG9ydXNcIixcbiAgICAgIGNsaWNrSGVyZTogXCJNb3JlIEluZm9cIlxuICAgIH1cbiAgfSxcbiAgZGU6IHtcbiAgICBlbWJlZDoge1xuICAgICAgY29udGludWU6IFwiRm9ydHNldHplblwiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwiQXV0b3Jpc2llcnVuZyBlcmZvcmRlcmxpY2hcIixcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwiS2xpY2tlbiBTaWUgaW4gZWluZW0gUG9wdXAgYXVmIFdlaXRlciwgdW0gbWl0IElocmVyIEFuZnJhZ2UgZm9ydHp1ZmFocmVuXCIsXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwiQ29va2llcyBiZW7DtnRpZ3RcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwiQml0dGUgYWt0aXZpZXJlbiBTaWUgQ29va2llcyBpbiBJaHJlbiBCcm93c2VyZWluc3RlbGx1bmdlbiwgdW0gYXVmIFRvcnVzIHp1enVncmVpZmVuXCIsXG4gICAgICBjbGlja0hlcmU6IFwiTWVociBJbmZvXCJcbiAgICB9XG4gIH0sXG4gIGphOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIue2mee2muOBmeOCi1wiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwi6KqN6Ki844GM5b+F6KaB44Gn44GZXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIue2muihjOOCkuOCr+ODquODg+OCr+OBl+OBpuOAgeODneODg+ODl+OCouODg+ODl+OBp+ODquOCr+OCqOOCueODiOOCkue2muihjOOBl+OBvuOBmVwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIuW/heimgeOBquOCr+ODg+OCreODvFwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCJUb3J1c+OBq+OCouOCr+OCu+OCueOBmeOCi+OBq+OBr+OAgeODluODqeOCpuOCtuOBruioreWumuOBp0Nvb2tpZeOCkuacieWKueOBq+OBl+OBpuOBj+OBoOOBleOBhOOAglwiLFxuICAgICAgY2xpY2tIZXJlOiBcIuips+OBl+OBj+OBr1wiXG4gICAgfVxuICB9LFxuICBrbzoge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCLqs4Tsho3tlZjri6RcIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIuyKueyduCDtlYTsmpRcIixcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwi7Yyd7JeF7JeQ7IScIOyalOyyreydhCDsp4TtlontlZjroKTrqbQg6rOE7IaN7J2EIO2BtOumre2VmOyLreyLnOyYpC5cIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCLsv6DtgqQg7ZWE7JqUXCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIuu4jOudvOyasOyggCDtmZjqsr0g7ISk7KCV7JeQ7IScIOy/oO2CpOulvCDtmZzshLHtmZTtlZjsl6wgVG9ydXPsl5Ag7JWh7IS47Iqk7ZWY7Iut7Iuc7JikLlwiLFxuICAgICAgY2xpY2tIZXJlOiBcIuuNlCDrp47snYAg7KCV67O0XCJcbiAgICB9XG4gIH0sXG4gIHpoOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIue7p+e7rVwiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwi6ZyA6KaB5o6I5p2DXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIuWNleWHu+e7p+e7reS7peWcqOW8ueWHuueql+WPo+S4ree7p+e7reaCqOeahOivt+axglwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIuW/heWhq0Nvb2tpZVwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCLor7flnKjmgqjnmoTmtY/op4jlmajpppbpgInpobnkuK3lkK/nlKhjb29raWXku6Xorr/pl65Ub3J1c+OAglwiLFxuICAgICAgY2xpY2tIZXJlOiBcIuabtOWkmuS/oeaBr1wiXG4gICAgfVxuICB9XG59O1xudmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gIHN1cHBvcnRlZFZlcmlmaWVyTGlzdDogW0xPR0lOX1BST1ZJREVSLkdPT0dMRSwgTE9HSU5fUFJPVklERVIuUkVERElULCBMT0dJTl9QUk9WSURFUi5ESVNDT1JEXSxcbiAgYXBpOiBcImh0dHBzOi8vYXBpLnRvci51c1wiLFxuICB0cmFuc2xhdGlvbnMsXG4gIHByb2RUb3J1c1VybDogXCJcIixcbiAgbG9jYWxTdG9yYWdlS2V5UHJlZml4OiBgdG9ydXMtYFxufTtcblxudmFyIGxvZyA9IGxvZ2xldmVsLmdldExvZ2dlcihcInNvbGFuYS1lbWJlZFwiKTtcblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxuLyoqXG4gKiBqc29uLXJwYy1lbmdpbmUgbWlkZGxld2FyZSB0aGF0IGxvZ3MgUlBDIGVycm9ycyBhbmQgYW5kIHZhbGlkYXRlcyByZXEubWV0aG9kLlxuICpcbiAqIEBwYXJhbSBsb2cgLSBUaGUgbG9nZ2luZyBBUEkgdG8gdXNlLlxuICogQHJldHVybnMgIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yTWlkZGxld2FyZSgpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgIC8vIGpzb24tcnBjLWVuZ2luZSB3aWxsIHRlcm1pbmF0ZSB0aGUgcmVxdWVzdCB3aGVuIGl0IG5vdGljZXMgdGhpcyBlcnJvclxuICAgIGlmICh0eXBlb2YgcmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCAhcmVxLm1ldGhvZCkge1xuICAgICAgcmVzLmVycm9yID0gZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgcmVxdWVzdCAnbWV0aG9kJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5gLFxuICAgICAgICBkYXRhOiByZXFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0KGRvbmUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJvclxuICAgICAgfSA9IHJlcztcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICAgIGxvZy5lcnJvcihgVG9ydXMgLSBSUEMgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIExvZ3MgYSBzdHJlYW0gZGlzY29ubmVjdGlvbiBlcnJvci4gRW1pdHMgYW4gJ2Vycm9yJyBpZiBnaXZlbiBhblxuICogRXZlbnRFbWl0dGVyIHRoYXQgaGFzIGxpc3RlbmVycyBmb3IgdGhlICdlcnJvcicgZXZlbnQuXG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXG4gKiBAcGFyYW0gcmVtb3RlTGFiZWwgLSBUaGUgbGFiZWwgb2YgdGhlIGRpc2Nvbm5lY3RlZCBzdHJlYW0uXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgYXNzb2NpYXRlZCBlcnJvciB0byBsb2cuXG4gKiBAcGFyYW0gZW1pdHRlciAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nKHJlbW90ZUxhYmVsLCBlcnJvciwgZW1pdHRlcikge1xuICBsZXQgd2FybmluZ01zZyA9IGBUb3J1czogTG9zdCBjb25uZWN0aW9uIHRvIFwiJHtyZW1vdGVMYWJlbH1cIi5gO1xuICBpZiAoZXJyb3I/LnN0YWNrKSB7XG4gICAgd2FybmluZ01zZyArPSBgXFxuJHtlcnJvci5zdGFja31gO1xuICB9XG4gIGxvZy53YXJuKHdhcm5pbmdNc2cpO1xuICBpZiAoZW1pdHRlciAmJiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoXCJlcnJvclwiKSA+IDApIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJlcnJvclwiLCB3YXJuaW5nTXNnKTtcbiAgfVxufVxuY29uc3QgZ2V0V2luZG93SWQgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmNvbnN0IGdldFRvcnVzVXJsID0gYXN5bmMgYnVpbGRFbnYgPT4ge1xuICBsZXQgdG9ydXNVcmw7XG4gIGxldCBsb2dMZXZlbDtcbiAgLy8gY29uc3QgdmVyc2lvblVzZWQgPSB2ZXJzaW9uO1xuICAvLyBsb2cuaW5mbyhcInNvbGFuYSBlbWJlZCB2ZXJzaW9uIHVzZWQ6IFwiLCB2ZXJzaW9uVXNlZCk7XG4gIHN3aXRjaCAoYnVpbGRFbnYpIHtcbiAgICBjYXNlIFwidGVzdGluZ1wiOlxuICAgICAgdG9ydXNVcmwgPSBcImh0dHBzOi8vc29sYW5hLXRlc3RpbmcudG9yLnVzXCI7XG4gICAgICBsb2dMZXZlbCA9IFwiZGVidWdcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkZXZlbG9wbWVudFwiOlxuICAgICAgdG9ydXNVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MFwiO1xuICAgICAgbG9nTGV2ZWwgPSBcImRlYnVnXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdG9ydXNVcmwgPSBgaHR0cHM6Ly9zb2xhbmEudG9yLnVzYDtcbiAgICAgIGxvZ0xldmVsID0gXCJlcnJvclwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3J1c1VybCxcbiAgICBsb2dMZXZlbFxuICB9O1xufTtcbmNvbnN0IGdldFVzZXJMYW5ndWFnZSA9ICgpID0+IHtcbiAgbGV0IHVzZXJMYW5ndWFnZSA9IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgXCJlbi1VU1wiO1xuICBjb25zdCB1c2VyTGFuZ3VhZ2VzID0gdXNlckxhbmd1YWdlLnNwbGl0KFwiLVwiKTtcbiAgdXNlckxhbmd1YWdlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ3VyYXRpb24udHJhbnNsYXRpb25zLCB1c2VyTGFuZ3VhZ2VzWzBdKSA/IHVzZXJMYW5ndWFnZXNbMF0gOiBcImVuXCI7XG4gIHJldHVybiB1c2VyTGFuZ3VhZ2U7XG59O1xuY29uc3QgRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA2NjAsXG4gIHdpZHRoOiAzNzVcbn07XG5jb25zdCBGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1cgPSB7XG4gIGhlaWdodDogNzQwLFxuICB3aWR0aDogMTMxNVxufTtcbmNvbnN0IEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XID0ge1xuICBoZWlnaHQ6IDcwMCxcbiAgd2lkdGg6IDEyMDBcbn07XG5jb25zdCBGRUFUVVJFU19DT05GSVJNX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA2MDAsXG4gIHdpZHRoOiA0MDBcbn07XG5mdW5jdGlvbiBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHtcbiAgbGV0IHN0b3JhZ2U7XG4gIHRyeSB7XG4gICAgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXTtcbiAgICBjb25zdCB4ID0gXCJfX3N0b3JhZ2VfdGVzdF9fXCI7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSh4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBlID0gZXJyb3I7XG4gICAgcmV0dXJuIGUgJiYgKFxuICAgIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IEZpcmVmb3hcbiAgICBlLmNvZGUgPT09IDIyIHx8XG4gICAgLy8gRmlyZWZveFxuICAgIGUuY29kZSA9PT0gMTAxNCB8fFxuICAgIC8vIHRlc3QgbmFtZSBmaWVsZCB0b28sIGJlY2F1c2UgY29kZSBtaWdodCBub3QgYmUgcHJlc2VudFxuICAgIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IEZpcmVmb3hcbiAgICBlLm5hbWUgPT09IFwiUXVvdGFFeGNlZWRlZEVycm9yXCIgfHxcbiAgICAvLyBGaXJlZm94XG4gICAgZS5uYW1lID09PSBcIk5TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEXCIpICYmXG4gICAgLy8gYWNrbm93bGVkZ2UgUXVvdGFFeGNlZWRlZEVycm9yIG9ubHkgaWYgdGhlcmUncyBzb21ldGhpbmcgYWxyZWFkeSBzdG9yZWRcbiAgICBzdG9yYWdlICYmIHN0b3JhZ2UubGVuZ3RoICE9PSAwO1xuICB9XG59XG5cbi8qKlxuICogcG9wdXAgaGFuZGxlciB1dGlsc1xuICovXG5mdW5jdGlvbiBnZXRQb3B1cEZlYXR1cmVzKF9yZWYpIHtcbiAgbGV0IHtcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGhcbiAgfSA9IF9yZWY7XG4gIC8vIEZpeGVzIGR1YWwtc2NyZWVuIHBvc2l0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3N0IGJyb3dzZXJzICAgICAgRmlyZWZveFxuICBjb25zdCBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuTGVmdCA6IHdpbmRvdy5zY3JlZW5YO1xuICBjb25zdCBkdWFsU2NyZWVuVG9wID0gd2luZG93LnNjcmVlblRvcCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHdpbmRvdy5zY3JlZW5ZO1xuICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoID8gd2luZG93LmlubmVyV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiB3aW5kb3cuc2NyZWVuLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBzeXN0ZW1ab29tID0gMTsgLy8gTm8gcmVsaWFibGUgZXN0aW1hdGVcblxuICBjb25zdCBsZWZ0ID0gTWF0aC5hYnMoKHdpZHRoIC0gdykgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5MZWZ0KTtcbiAgY29uc3QgdG9wID0gTWF0aC5hYnMoKGhlaWdodCAtIGgpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuVG9wKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBgdGl0bGViYXI9MCx0b29sYmFyPTAsc3RhdHVzPTAsbG9jYXRpb249MCxtZW51YmFyPTAsaGVpZ2h0PSR7aCAvIHN5c3RlbVpvb219LHdpZHRoPSR7dyAvIHN5c3RlbVpvb219LHRvcD0ke3RvcH0sbGVmdD0ke2xlZnR9YDtcbiAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG5jbGFzcyBCYXNlUHJvdmlkZXIgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvblN0cmVhbSwgX3JlZikge1xuICAgIGxldCB7XG4gICAgICBtYXhFdmVudExpc3RlbmVycyA9IDEwMCxcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lID0gXCJwcm92aWRlclwiXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0aW5nIHRoYXQgdGhpcyBwcm92aWRlciBpcyBhIFRvcnVzIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVG9ydXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcnBjRW5naW5lXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwianNvblJwY0Nvbm5lY3Rpb25FdmVudHNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RhdGVcIiwgdm9pZCAwKTtcbiAgICBpZiAoIWlzRHVwbGV4U3RyZWFtKGNvbm5lY3Rpb25TdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuZXJyb3JzLmludmFsaWREdXBsZXhTdHJlYW0oKSk7XG4gICAgfVxuICAgIHRoaXMuaXNUb3J1cyA9IHRydWU7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMobWF4RXZlbnRMaXN0ZW5lcnMpO1xuICAgIHRoaXMuX2hhbmRsZUNvbm5lY3QgPSB0aGlzLl9oYW5kbGVDb25uZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdCA9IHRoaXMuX2hhbmRsZURpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0ID0gdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSB0aGlzLl9ycGNSZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVN0YXRlID0gdGhpcy5faW5pdGlhbGl6ZVN0YXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZW5kQXN5bmMgPSB0aGlzLnNlbmRBc3luYy5iaW5kKHRoaXMpO1xuICAgIC8vIHRoaXMuZW5hYmxlID0gdGhpcy5lbmFibGUuYmluZCh0aGlzKTtcblxuICAgIC8vIHNldHVwIGNvbm5lY3Rpb25TdHJlYW0gbXVsdGlwbGV4aW5nXG4gICAgY29uc3QgbXV4ID0gbmV3IE9iamVjdE11bHRpcGxleCgpO1xuICAgIHB1bXAoY29ubmVjdGlvblN0cmVhbSwgbXV4LCBjb25uZWN0aW9uU3RyZWFtLCB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0LmJpbmQodGhpcywgXCJUb3J1c1wiKSk7XG5cbiAgICAvLyBpZ25vcmUgcGhpc2hpbmcgd2FybmluZyBtZXNzYWdlIChoYW5kbGVkIGVsc2V3aGVyZSlcbiAgICBtdXguaWdub3JlU3RyZWFtKFwicGhpc2hpbmdcIik7XG5cbiAgICAvLyBzZXR1cCBvd24gZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gY29ubmVjdCB0byBhc3luYyBwcm92aWRlclxuXG4gICAgY29uc3QganNvblJwY0Nvbm5lY3Rpb24gPSBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCk7XG4gICAgcHVtcChqc29uUnBjQ29ubmVjdGlvbi5zdHJlYW0sIG11eC5jcmVhdGVTdHJlYW0oanNvblJwY1N0cmVhbU5hbWUpLCBqc29uUnBjQ29ubmVjdGlvbi5zdHJlYW0sIHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QuYmluZCh0aGlzLCBcIlRvcnVzIFJwY1Byb3ZpZGVyXCIpKTtcblxuICAgIC8vIGhhbmRsZSBSUEMgcmVxdWVzdHMgdmlhIGRhcHAtc2lkZSBycGMgZW5naW5lXG4gICAgY29uc3QgcnBjRW5naW5lID0gbmV3IEpSUENFbmdpbmUoKTtcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSgpKTtcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVFcnJvck1pZGRsZXdhcmUoKSk7XG4gICAgcnBjRW5naW5lLnB1c2goY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSh7XG4gICAgICBvcmlnaW46IGxvY2F0aW9uLm9yaWdpblxuICAgIH0pKTtcbiAgICBycGNFbmdpbmUucHVzaChqc29uUnBjQ29ubmVjdGlvbi5taWRkbGV3YXJlKTtcbiAgICB0aGlzLl9ycGNFbmdpbmUgPSBycGNFbmdpbmU7XG4gICAgdGhpcy5qc29uUnBjQ29ubmVjdGlvbkV2ZW50cyA9IGpzb25ScGNDb25uZWN0aW9uLmV2ZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIGFuIFJQQyByZXF1ZXN0IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLCB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAqIFJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwsIG9yIHJlamVjdHMgb24gZXJyb3IuXG4gICAqL1xuICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkUmVxdWVzdEFyZ3MoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSBhcmdzO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcInN0cmluZ1wiIHx8IG1ldGhvZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlcy5lcnJvcnMuaW52YWxpZFJlcXVlc3RNZXRob2QoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpICYmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlcy5lcnJvcnMuaW52YWxpZFJlcXVlc3RQYXJhbXMoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9ycGNSZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0sIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3VibWl0cyBhbiBSUEMgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgc2VuZChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JwY1JlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBTdWJtaXRzIGFuIFJQQyByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICBzZW5kQXN5bmMocGF5bG9hZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9ycGNSZXF1ZXN0KHBheWxvYWQsIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGxvc3QgdG8gY3JpdGljYWwgc3RyZWFtcy5cbiAgICpcbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNkaXNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlU3RyZWFtRGlzY29ubmVjdChzdHJlYW1OYW1lLCBlcnJvcikge1xuICAgIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nKHN0cmVhbU5hbWUsIGVycm9yLCB0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0KGZhbHNlLCBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiB1bmRlZmluZWQpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBNZXRob2RzXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIuXG4gICAqIFBvcHVsYXRlcyBpbml0aWFsIHN0YXRlIGJ5IGNhbGxpbmcgJ3dhbGxldF9nZXRQcm92aWRlclN0YXRlJyBhbmQgZW1pdHNcbiAgICogbmVjZXNzYXJ5IGV2ZW50cy5cbiAgICovXG5cbiAgLyoqXG4gICAqIEludGVybmFsIFJQQyBtZXRob2QuIEZvcndhcmRzIHJlcXVlc3RzIHRvIGJhY2tncm91bmQgdmlhIHRoZSBSUEMgZW5naW5lLlxuICAgKiBBbHNvIHJlbWFwIGlkcyBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICAgKi9cblxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgSUQgb2YgdGhlIG5ld2x5IGNvbm5lY3RlZCBjaGFpbi5cbiAgICogZW1pdHMgVG9ydXNJblBhZ2VQcm92aWRlciNjb25uZWN0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGRpc2Nvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50IHdpdGggcmVzcGVjdCB0byB0aGUgaXNSZWNvdmVyYWJsZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEVycm9yIGNvZGVzIHBlciB0aGUgQ2xvc2VFdmVudCBzdGF0dXMgY29kZXMgYXMgcmVxdWlyZWQgYnkgRUlQLTExOTM6XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgKlxuICAgKiBAcGFyYW0gaXNSZWNvdmVyYWJsZSAtIFdoZXRoZXIgdGhlIGRpc2Nvbm5lY3Rpb24gaXMgcmVjb3ZlcmFibGUuXG4gICAqIEBwYXJhbSBlcnJvck1lc3NhZ2UgLSBBIGN1c3RvbSBlcnJvciBtZXNzYWdlLlxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Rpc2Nvbm5lY3RcbiAgICovXG59XG5cbmNvbnN0IGh0bWxUb0VsZW1lbnQgPSBodG1sID0+IHtcbiAgY29uc3QgdGVtcGxhdGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICBjb25zdCB0cmltbWVkSHRtbCA9IGh0bWwudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IHRyaW1tZWRIdG1sO1xuICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkO1xufTtcbmZ1bmN0aW9uIGlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSh0cmFuc2FjdGlvbikge1xuICByZXR1cm4gdHJhbnNhY3Rpb24udmVyc2lvbiA9PT0gdW5kZWZpbmVkO1xufVxuXG5jbGFzcyBQb3B1cEhhbmRsZXIgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICB1cmwsXG4gICAgICB0YXJnZXQsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIHRpbWVvdXQgPSAzMDAwMFxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidXJsXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidGFyZ2V0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aW5kb3dcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aW5kb3dUaW1lclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlDbG9zZWRXaW5kb3dcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0XCIsIHZvaWQgMCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQgfHwgXCJfYmxhbmtcIjtcbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXMgfHwgZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyk7XG4gICAgdGhpcy53aW5kb3cgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aW5kb3dUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlDbG9zZWRXaW5kb3cgPSBmYWxzZTtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIHRoaXMuX3NldHVwVGltZXIoKTtcbiAgfVxuICBfc2V0dXBUaW1lcigpIHtcbiAgICB0aGlzLndpbmRvd1RpbWVyID0gTnVtYmVyKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndpbmRvdyAmJiB0aGlzLndpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLndpbmRvd1RpbWVyKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlDbG9zZWRXaW5kb3cpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmlDbG9zZWRXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLndpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLndpbmRvdyA9PT0gdW5kZWZpbmVkKSBjbGVhckludGVydmFsKHRoaXMud2luZG93VGltZXIpO1xuICAgIH0sIDUwMCkpO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgdGhpcy53aW5kb3cgPSB3aW5kb3cub3Blbih0aGlzLnVybC5ocmVmLCB0aGlzLnRhcmdldCwgdGhpcy5mZWF0dXJlcyk7XG4gICAgaWYgKHRoaXMud2luZG93Py5mb2N1cykgdGhpcy53aW5kb3cuZm9jdXMoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pQ2xvc2VkV2luZG93ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy53aW5kb3cpIHRoaXMud2luZG93LmNsb3NlKCk7XG4gIH1cbiAgcmVkaXJlY3QobG9jYXRpb25SZXBsYWNlT25SZWRpcmVjdCkge1xuICAgIGlmIChsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0KSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh0aGlzLnVybC5ocmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0aGlzLnVybC5ocmVmO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJlYW0sIF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMgPSAxMDAsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZSA9IFwicHJvdmlkZXJcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKGNvbm5lY3Rpb25TdHJlYW0sIHtcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzLFxuICAgICAganNvblJwY1N0cmVhbU5hbWVcbiAgICB9KTtcblxuICAgIC8vIHByaXZhdGUgc3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbWJlZFRyYW5zbGF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzVXJsXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGFwcFN0b3JhZ2VLZXlcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aW5kb3dSZWZzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHJ5V2luZG93SGFuZGxlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNBbGVydENvbnRhaW5lclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzSWZyYW1lXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fc3RhdGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlci5fZGVmYXVsdFN0YXRlKTtcblxuICAgIC8vIHB1YmxpYyBzdGF0ZVxuICAgIHRoaXMudG9ydXNVcmwgPSBcIlwiO1xuICAgIHRoaXMuZGFwcFN0b3JhZ2VLZXkgPSBcIlwiO1xuICAgIGNvbnN0IGxhbmd1YWdlVHJhbnNsYXRpb25zID0gY29uZmlndXJhdGlvbi50cmFuc2xhdGlvbnNbZ2V0VXNlckxhbmd1YWdlKCldO1xuICAgIHRoaXMuZW1iZWRUcmFuc2xhdGlvbnMgPSBsYW5ndWFnZVRyYW5zbGF0aW9ucy5lbWJlZDtcbiAgICB0aGlzLndpbmRvd1JlZnMgPSB7fTtcblxuICAgIC8vIHNldHVwIG93biBldmVudCBsaXN0ZW5lcnNcblxuICAgIC8vIEVJUC0xMTkzIGNvbm5lY3RcbiAgICB0aGlzLm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSGFuZGxlciA9IHBheWxvYWQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfSA9IHBheWxvYWQ7XG4gICAgICBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuSUZSQU1FX1NUQVRVUykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaXNGdWxsU2NyZWVuLFxuICAgICAgICAgIHJpZFxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKHtcbiAgICAgICAgICBpc0Z1bGw6IGlzRnVsbFNjcmVlbixcbiAgICAgICAgICByaWQ6IHJpZFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgbWV0aG9kIHdoZW4gd2FsbGV0IGFkZHMgdmVyc2lvbmluZyBhbmQgc3RvcHMgc3VwcG9ydGluZyB0aGlzIG1ldGhvZFxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwiY3JlYXRlX3dpbmRvd1wiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICB1cmxcbiAgICAgICAgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXBCbG9ja0FsZXJ0KHdpbmRvd0lkLCB1cmwpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5DTE9TRV9XSU5ET1cpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2xvc2VXaW5kb3cocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuVVNFUl9MT0dHRURfSU4pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGN1cnJlbnRMb2dpblByb3ZpZGVyXG4gICAgICAgIH0gPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzTG9nZ2VkSW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5jdXJyZW50TG9naW5Qcm92aWRlciA9IGN1cnJlbnRMb2dpblByb3ZpZGVyO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5VU0VSX0xPR0dFRF9PVVQpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNMb2dnZWRJbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5jdXJyZW50TG9naW5Qcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlJZnJhbWUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuanNvblJwY0Nvbm5lY3Rpb25FdmVudHMub24oXCJub3RpZmljYXRpb25cIiwgbm90aWZpY2F0aW9uSGFuZGxlcik7XG4gIH1cbiAgZ2V0IGlzTG9nZ2VkSW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzTG9nZ2VkSW47XG4gIH1cbiAgZ2V0IGlzSUZyYW1lRnVsbFNjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNJRnJhbWVGdWxsU2NyZWVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5QYWdlIHByb3ZpZGVyIGlzIGNvbm5lY3RlZCB0byBUb3J1cy5cbiAgICovXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZDtcbiAgfVxuICBhc3luYyBfaW5pdGlhbGl6ZVN0YXRlKHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRvcnVzVXJsLFxuICAgICAgICBkYXBwU3RvcmFnZUtleSxcbiAgICAgICAgdG9ydXNBbGVydENvbnRhaW5lcixcbiAgICAgICAgdG9ydXNJZnJhbWVcbiAgICAgIH0gPSBwYXJhbXM7XG4gICAgICB0aGlzLnRvcnVzVXJsID0gdG9ydXNVcmw7XG4gICAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gZGFwcFN0b3JhZ2VLZXk7XG4gICAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIgPSB0b3J1c0FsZXJ0Q29udGFpbmVyO1xuICAgICAgdGhpcy50b3J1c0lmcmFtZSA9IHRvcnVzSWZyYW1lO1xuICAgICAgdGhpcy50b3J1c0lmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpZiBpZnJhbWUgaXMgbm90IGZ1bGwgc2NyZWVuXG4gICAgICAgIGlmICghdGhpcy5fc3RhdGUuaXNJRnJhbWVGdWxsU2NyZWVuKSB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudExvZ2luUHJvdmlkZXIsXG4gICAgICAgIGlzTG9nZ2VkSW5cbiAgICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkdFVF9QUk9WSURFUl9TVEFURSxcbiAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGluZGljYXRlIHRoYXQgd2UndmUgY29ubmVjdGVkLCBmb3IgRUlQLTExOTMgY29tcGxpYW5jZVxuICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdChjdXJyZW50TG9naW5Qcm92aWRlciwgaXNMb2dnZWRJbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBGYWlsZWQgdG8gZ2V0IGluaXRpYWwgc3RhdGUuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbG9nLmluZm8oXCJpbml0aWFsaXplZCBjb21tdW5pY2F0aW9uIHN0YXRlXCIpO1xuICAgICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiX2luaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlV2luZG93KHdpbmRvd0lkKSB7XG4gICAgbGV0IHtcbiAgICAgIHVybCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGZlYXR1cmVzXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybCB8fCBgJHt0aGlzLnRvcnVzVXJsfS9yZWRpcmVjdD93aW5kb3dJZD0ke3dpbmRvd0lkfWApO1xuICAgIGlmICh0aGlzLmRhcHBTdG9yYWdlS2V5KSB7XG4gICAgICAvLyBJZiBtdWx0aXBsZSBpbnN0YW5jZXMsIGl0IHJldHVybnMgdGhlIGZpcnN0IG9uZVxuICAgICAgaWYgKGZpbmFsVXJsLmhhc2gpIGZpbmFsVXJsLmhhc2ggKz0gYCZkYXBwU3RvcmFnZUtleT0ke3RoaXMuZGFwcFN0b3JhZ2VLZXl9YDtlbHNlIGZpbmFsVXJsLmhhc2ggPSBgI2RhcHBTdG9yYWdlS2V5PSR7dGhpcy5kYXBwU3RvcmFnZUtleX1gO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVkV2luZG93ID0gbmV3IFBvcHVwSGFuZGxlcih7XG4gICAgICB1cmw6IGZpbmFsVXJsLFxuICAgICAgdGFyZ2V0LFxuICAgICAgZmVhdHVyZXNcbiAgICB9KTtcbiAgICBoYW5kbGVkV2luZG93Lm9wZW4oKTtcbiAgICBpZiAoIWhhbmRsZWRXaW5kb3cud2luZG93KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cEJsb2NrQWxlcnQod2luZG93SWQsIGZpbmFsVXJsLmhyZWYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBZGQgdG8gY29sbGVjdGlvbiBvbmx5IGlmIHdpbmRvdyBpcyBvcGVuZWRcbiAgICB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdID0gaGFuZGxlZFdpbmRvdztcbiAgICAvLyBXZSB0ZWxsIHRoZSBpZnJhbWUgdGhhdCB0aGUgd2luZG93IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBvcGVuZWRcbiAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIm9wZW5lZF93aW5kb3dcIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB3aW5kb3dJZFxuICAgICAgfVxuICAgIH0pO1xuICAgIGhhbmRsZWRXaW5kb3cub25jZShcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIC8vIHVzZXIgY2xvc2VkIHRoZSB3aW5kb3dcbiAgICAgIGRlbGV0ZSB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdO1xuICAgICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5DTE9TRURfV0lORE9XLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfZGlzcGxheUlmcmFtZSgpIHtcbiAgICBsZXQge1xuICAgICAgaXNGdWxsID0gZmFsc2UsXG4gICAgICByaWQgPSBcIlwiXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgICAvLyBzZXQgcGhhc2VcbiAgICBpZiAoIWlzRnVsbCkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IHRoaXMuX3N0YXRlLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gXCI3MHB4XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IFwiNzBweFwiO1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZS5idXR0b25Qb3NpdGlvbikge1xuICAgICAgICBjYXNlIEJVVFRPTl9QT1NJVElPTi5UT1BfTEVGVDpcbiAgICAgICAgICBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCJhdXRvXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQlVUVE9OX1BPU0lUSU9OLlRPUF9SSUdIVDpcbiAgICAgICAgICBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCJhdXRvXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQlVUVE9OX1BPU0lUSU9OLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgICBzdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS50b3AgPSBcImF1dG9cIjtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQlVUVE9OX1BPU0lUSU9OLkJPVFRPTV9MRUZUOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUudG9wID0gXCJhdXRvXCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgIHN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICBzdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgICBzdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgIHN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy50b3J1c0lmcmFtZS5zdHlsZSwgc3R5bGUpO1xuICAgIHRoaXMuX3N0YXRlLmlzSUZyYW1lRnVsbFNjcmVlbiA9IGlzRnVsbDtcbiAgICB0aGlzLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5JRlJBTUVfU1RBVFVTLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGlzSUZyYW1lRnVsbFNjcmVlbjogaXNGdWxsLFxuICAgICAgICByaWRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBoaWRlVG9ydXNCdXR0b24oKSB7XG4gICAgdGhpcy5fc3RhdGUudG9ydXNXaWRnZXRWaXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICB9XG4gIHNob3dUb3J1c0J1dHRvbigpIHtcbiAgICB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPSB0cnVlO1xuICAgIHRoaXMuX2Rpc3BsYXlJZnJhbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSUEMgbWV0aG9kLiBGb3J3YXJkcyByZXF1ZXN0cyB0byBiYWNrZ3JvdW5kIHZpYSB0aGUgUlBDIGVuZ2luZS5cbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmRcbiAgICovXG4gIF9ycGNSZXF1ZXN0KHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KF9wYXlsb2FkKSkge1xuICAgICAgaWYgKCFfcGF5bG9hZC5qc29ucnBjKSB7XG4gICAgICAgIF9wYXlsb2FkLmpzb25ycGMgPSBcIjIuMFwiO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyeVdpbmRvd0hhbmRsZShfcGF5bG9hZCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBjdXJyZW50TG9naW5Qcm92aWRlciAtIFRoZSBsb2dpbiBQcm92aWRlclxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Nvbm5lY3RcbiAgICovXG4gIF9oYW5kbGVDb25uZWN0KGN1cnJlbnRMb2dpblByb3ZpZGVyLCBpc0xvZ2dlZEluKSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7XG4gICAgICAgIGN1cnJlbnRMb2dpblByb3ZpZGVyLFxuICAgICAgICBpc0xvZ2dlZEluXG4gICAgICB9KTtcbiAgICAgIGxvZy5kZWJ1ZyhtZXNzYWdlcy5pbmZvLmNvbm5lY3RlZChjdXJyZW50TG9naW5Qcm92aWRlcikpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGRpc2Nvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50IHdpdGggcmVzcGVjdCB0byB0aGUgaXNSZWNvdmVyYWJsZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEVycm9yIGNvZGVzIHBlciB0aGUgQ2xvc2VFdmVudCBzdGF0dXMgY29kZXMgYXMgcmVxdWlyZWQgYnkgRUlQLTExOTM6XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgKlxuICAgKiBAcGFyYW0gaXNSZWNvdmVyYWJsZSAtIFdoZXRoZXIgdGhlIGRpc2Nvbm5lY3Rpb24gaXMgcmVjb3ZlcmFibGUuXG4gICAqIEBwYXJhbSBlcnJvck1lc3NhZ2UgLSBBIGN1c3RvbSBlcnJvciBtZXNzYWdlLlxuICAgKiBlbWl0cyBUb3J1c0lucGFnZVByb3ZpZGVyI2Rpc2Nvbm5lY3RcbiAgICovXG4gIF9oYW5kbGVEaXNjb25uZWN0KGlzUmVjb3ZlcmFibGUsIGVycm9yTWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCB8fCAhdGhpcy5fc3RhdGUuaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCAmJiAhaXNSZWNvdmVyYWJsZSkge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIGlmIChpc1JlY292ZXJhYmxlKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEV0aGVyZXVtUnBjRXJyb3IoMTAxMyxcbiAgICAgICAgLy8gVHJ5IGFnYWluIGxhdGVyXG4gICAgICAgIGVycm9yTWVzc2FnZSB8fCBtZXNzYWdlcy5lcnJvcnMuZGlzY29ubmVjdGVkKCkpO1xuICAgICAgICBsb2cuZGVidWcoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDExLFxuICAgICAgICAvLyBJbnRlcm5hbCBlcnJvclxuICAgICAgICBlcnJvck1lc3NhZ2UgfHwgbWVzc2FnZXMuZXJyb3JzLnBlcm1hbmVudGx5RGlzY29ubmVjdGVkKCkpO1xuICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLl9zdGF0ZS5jdXJyZW50TG9naW5Qcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzTG9nZ2VkSW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGUudG9ydXNXaWRnZXRWaXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzSUZyYW1lRnVsbFNjcmVlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBpZiB0aGUgaWZyYW1lIHdhbnRzIHRvIGNsb3NlIHRoZSB3aW5kb3cgY2F1c2UgaXQgaXMgZG9uZSBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0XG4gIF9oYW5kbGVDbG9zZVdpbmRvdyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aW5kb3dJZFxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF0pIHtcbiAgICAgIHRoaXMud2luZG93UmVmc1t3aW5kb3dJZF0uY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdO1xuICAgIH1cbiAgfVxuICBhc3luYyBfY3JlYXRlUG9wdXBCbG9ja0FsZXJ0KHdpbmRvd0lkLCB1cmwpIHtcbiAgICBjb25zdCBsb2dvVXJsID0gdGhpcy5nZXRMb2dvVXJsKCk7XG4gICAgY29uc3QgdG9ydXNBbGVydCA9IGh0bWxUb0VsZW1lbnQoJzxkaXYgaWQ9XCJ0b3J1c0FsZXJ0XCIgY2xhc3M9XCJ0b3J1cy1hbGVydC0tdjJcIj4nICsgYDxkaXYgaWQ9XCJ0b3J1c0FsZXJ0X19sb2dvXCI+PGltZyBzcmM9XCIke2xvZ29Vcmx9XCIgLz48L2Rpdj5gICsgXCI8ZGl2PlwiICsgYDxoMSBpZD1cInRvcnVzQWxlcnRfX3RpdGxlXCI+JHt0aGlzLmVtYmVkVHJhbnNsYXRpb25zLmFjdGlvblJlcXVpcmVkfTwvaDE+YCArIGA8cCBpZD1cInRvcnVzQWxlcnRfX2Rlc2NcIj4ke3RoaXMuZW1iZWRUcmFuc2xhdGlvbnMucGVuZGluZ0FjdGlvbn08L3A+YCArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiKTtcbiAgICBjb25zdCBzdWNjZXNzQWxlcnQgPSBodG1sVG9FbGVtZW50KGA8ZGl2PjxhIGlkPVwidG9ydXNBbGVydF9fYnRuXCI+JHt0aGlzLmVtYmVkVHJhbnNsYXRpb25zLmNvbnRpbnVlfTwvYT48L2Rpdj5gKTtcbiAgICBjb25zdCBidG5Db250YWluZXIgPSBodG1sVG9FbGVtZW50KCc8ZGl2IGlkPVwidG9ydXNBbGVydF9fYnRuLWNvbnRhaW5lclwiPjwvZGl2PicpO1xuICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWNjZXNzQWxlcnQpO1xuICAgIHRvcnVzQWxlcnQuYXBwZW5kQ2hpbGQoYnRuQ29udGFpbmVyKTtcbiAgICBjb25zdCBiaW5kT25Mb2FkID0gKCkgPT4ge1xuICAgICAgc3VjY2Vzc0FsZXJ0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCwge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cpXG4gICAgICAgIH0pO1xuICAgICAgICB0b3J1c0FsZXJ0LnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXR0YWNoT25Mb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRvcnVzQWxlcnQpO1xuICAgIH07XG4gICAgYXR0YWNoT25Mb2FkKCk7XG4gICAgYmluZE9uTG9hZCgpO1xuICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG4gIGdldExvZ29VcmwoKSB7XG4gICAgY29uc3QgbG9nb1VybCA9IGAke3RoaXMudG9ydXNVcmx9L2ltYWdlcy90b3J1c19pY29uLWJsdWUuc3ZnYDtcbiAgICByZXR1cm4gbG9nb1VybDtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KFRvcnVzQ29tbXVuaWNhdGlvblByb3ZpZGVyLCBcIl9kZWZhdWx0U3RhdGVcIiwge1xuICBidXR0b25Qb3NpdGlvbjogXCJib3R0b20tbGVmdFwiLFxuICBjdXJyZW50TG9naW5Qcm92aWRlcjogbnVsbCxcbiAgaXNJRnJhbWVGdWxsU2NyZWVuOiBmYWxzZSxcbiAgaGFzRW1pdHRlZENvbm5lY3Rpb246IGZhbHNlLFxuICB0b3J1c1dpZGdldFZpc2liaWxpdHk6IGZhbHNlLFxuICBpbml0aWFsaXplZDogZmFsc2UsXG4gIGlzTG9nZ2VkSW46IGZhbHNlLFxuICBpc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkOiBmYWxzZSxcbiAgaXNDb25uZWN0ZWQ6IGZhbHNlXG59KTtcblxuY2xhc3MgVG9ydXNJblBhZ2VQcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJlYW0sIF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMgPSAxMDAsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZSA9IFwicHJvdmlkZXJcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKGNvbm5lY3Rpb25TdHJlYW0sIHtcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzLFxuICAgICAganNvblJwY1N0cmVhbU5hbWVcbiAgICB9KTtcblxuICAgIC8vIHByaXZhdGUgc3RhdGVcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhaW4gSUQgb2YgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgU29sYW5hIGNoYWluLlxuICAgICAqIFNlZSBbY2hhaW5JZC5uZXR3b3JrXXtAbGluayBodHRwczovL2NoYWluaWQubmV0d29ya30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhaW5JZFwiLCB2b2lkIDApO1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VyJ3MgY3VycmVudGx5IHNlbGVjdGVkIFNvbGFuYSBhZGRyZXNzLlxuICAgICAqIElmIG51bGwsIFRvcnVzIGlzIGVpdGhlciBsb2NrZWQgb3IgdGhlIHVzZXIgaGFzIG5vdCBwZXJtaXR0ZWQgYW55XG4gICAgICogYWRkcmVzc2VzIHRvIGJlIHZpZXdlZC5cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWxlY3RlZEFkZHJlc3NcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cnlXaW5kb3dIYW5kbGVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9zdGF0ZSA9IF9vYmplY3RTcHJlYWQoe30sIFRvcnVzSW5QYWdlUHJvdmlkZXIuX2RlZmF1bHRTdGF0ZSk7XG5cbiAgICAvLyBwdWJsaWMgc3RhdGVcbiAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IG51bGw7XG4gICAgdGhpcy5jaGFpbklkID0gbnVsbDtcbiAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQgPSB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVDaGFpbkNoYW5nZWQgPSB0aGlzLl9oYW5kbGVDaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQgPSB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQuYmluZCh0aGlzKTtcblxuICAgIC8vIHNldHVwIG93biBldmVudCBsaXN0ZW5lcnNcblxuICAgIC8vIEVJUC0xMTkzIGNvbm5lY3RcbiAgICB0aGlzLm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgY29uc3QganNvblJwY05vdGlmaWNhdGlvbkhhbmRsZXIgPSBwYXlsb2FkID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBwYXlsb2FkO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gUFJPVklERVJfTk9USUZJQ0FUSU9OUy5BQ0NPVU5UU19DSEFOR0VEKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFBST1ZJREVSX05PVElGSUNBVElPTlMuVU5MT0NLX1NUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gUFJPVklERVJfTk9USUZJQ0FUSU9OUy5DSEFJTl9DSEFOR0VEKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZChwYXJhbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBqc29uIHJwYyBub3RpZmljYXRpb24gbGlzdGVuZXJcbiAgICB0aGlzLmpzb25ScGNDb25uZWN0aW9uRXZlbnRzLm9uKFwibm90aWZpY2F0aW9uXCIsIGpzb25ScGNOb3RpZmljYXRpb25IYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGlucGFnZSBwcm92aWRlciBpcyBjb25uZWN0ZWQgdG8gVG9ydXMuXG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQ7XG4gIH1cblxuICAvLyBQcml2YXRlIE1ldGhvZHNcbiAgLy89ID09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGhlbHBlci5cbiAgICogUG9wdWxhdGVzIGluaXRpYWwgc3RhdGUgYnkgY2FsbGluZyAnd2FsbGV0X2dldFByb3ZpZGVyU3RhdGUnIGFuZCBlbWl0c1xuICAgKiBuZWNlc3NhcnkgZXZlbnRzLlxuICAgKi9cbiAgYXN5bmMgX2luaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgaXNVbmxvY2tlZFxuICAgICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogUFJPVklERVJfSlJQQ19NRVRIT0RTLkdFVF9QUk9WSURFUl9TVEFURSxcbiAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGluZGljYXRlIHRoYXQgd2UndmUgY29ubmVjdGVkLCBmb3IgRUlQLTExOTMgY29tcGxpYW5jZVxuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7XG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkKHtcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQoe1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgaXNVbmxvY2tlZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogRmFpbGVkIHRvIGdldCBpbml0aWFsIHN0YXRlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGxvZy5pbmZvKFwiaW5pdGlhbGl6ZWQgcHJvdmlkZXIgc3RhdGVcIik7XG4gICAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJfaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIFJQQyBtZXRob2QuIEZvcndhcmRzIHJlcXVlc3RzIHRvIGJhY2tncm91bmQgdmlhIHRoZSBSUEMgZW5naW5lLlxuICAgKiBBbHNvIHJlbWFwIGlkcyBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICAgKi9cbiAgX3JwY1JlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBsZXQgaXNJbnRlcm5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgbGV0IGNiID0gY2FsbGJhY2s7XG4gICAgY29uc3QgX3BheWxvYWQgPSBwYXlsb2FkO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkpIHtcbiAgICAgIGlmICghX3BheWxvYWQuanNvbnJwYykge1xuICAgICAgICBfcGF5bG9hZC5qc29ucnBjID0gXCIyLjBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChfcGF5bG9hZC5tZXRob2QgPT09IFwic29sYW5hX2FjY291bnRzXCIgfHwgX3BheWxvYWQubWV0aG9kID09PSBcInNvbGFuYV9yZXF1ZXN0QWNjb3VudHNcIikge1xuICAgICAgICAvLyBoYW5kbGUgYWNjb3VudHMgY2hhbmdpbmdcbiAgICAgICAgY2IgPSAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQocmVzLnJlc3VsdCB8fCBbXSwgX3BheWxvYWQubWV0aG9kID09PSBcInNvbGFuYV9hY2NvdW50c1wiLCBpc0ludGVybmFsKTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJ3YWxsZXRfZ2V0UHJvdmlkZXJTdGF0ZVwiKSB7XG4gICAgICAgIHRoaXMuX3JwY0VuZ2luZS5oYW5kbGUocGF5bG9hZCwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJ5V2luZG93SGFuZGxlKF9wYXlsb2FkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgSUQgb2YgdGhlIG5ld2x5IGNvbm5lY3RlZCBjaGFpbi5cbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlQ29ubmVjdChjaGFpbklkKSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7XG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0pO1xuICAgICAgbG9nLmRlYnVnKG1lc3NhZ2VzLmluZm8uY29ubmVjdGVkKGNoYWluSWQpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBkaXNjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIGlzUmVjb3ZlcmFibGUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBFcnJvciBjb2RlcyBwZXIgdGhlIENsb3NlRXZlbnQgc3RhdHVzIGNvZGVzIGFzIHJlcXVpcmVkIGJ5IEVJUC0xMTkzOlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXNcbiAgICpcbiAgICogQHBhcmFtIGlzUmVjb3ZlcmFibGUgLSBXaGV0aGVyIHRoZSBkaXNjb25uZWN0aW9uIGlzIHJlY292ZXJhYmxlLlxuICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlIC0gQSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNkaXNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlRGlzY29ubmVjdChpc1JlY292ZXJhYmxlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgfHwgIXRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgJiYgIWlzUmVjb3ZlcmFibGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBsZXQgZXJyb3I7XG4gICAgICBpZiAoaXNSZWNvdmVyYWJsZSkge1xuICAgICAgICBlcnJvciA9IG5ldyBFdGhlcmV1bVJwY0Vycm9yKDEwMTMsXG4gICAgICAgIC8vIFRyeSBhZ2FpbiBsYXRlclxuICAgICAgICBlcnJvck1lc3NhZ2UgfHwgbWVzc2FnZXMuZXJyb3JzLmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgICAgbG9nLmRlYnVnKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yID0gbmV3IEV0aGVyZXVtUnBjRXJyb3IoMTAxMSxcbiAgICAgICAgLy8gSW50ZXJuYWwgZXJyb3JcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5wZXJtYW5lbnRseURpc2Nvbm5lY3RlZCgpKTtcbiAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUuYWNjb3VudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzVW5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYWNjb3VudHMgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIF9oYW5kbGVBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICBsZXQgaXNFdGhBY2NvdW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgbGV0IGlzSW50ZXJuYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIC8vIGRlZmVuc2l2ZSBwcm9ncmFtbWluZ1xuICAgIGxldCBmaW5hbEFjY291bnRzID0gYWNjb3VudHM7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbmFsQWNjb3VudHMpKSB7XG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogUmVjZWl2ZWQgbm9uLWFycmF5IGFjY291bnRzIHBhcmFtZXRlci4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgZmluYWxBY2NvdW50cyk7XG4gICAgICBmaW5hbEFjY291bnRzID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhY2NvdW50cykge1xuICAgICAgaWYgKHR5cGVvZiBhY2NvdW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBSZWNlaXZlZCBub24tc3RyaW5nIGFjY291bnQuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIGFjY291bnRzKTtcbiAgICAgICAgZmluYWxBY2NvdW50cyA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbWl0IGFjY291bnRzQ2hhbmdlZCBpZiBhbnl0aGluZyBhYm91dCB0aGUgYWNjb3VudHMgYXJyYXkgaGFzIGNoYW5nZWRcbiAgICBpZiAoIWRlcXVhbCh0aGlzLl9zdGF0ZS5hY2NvdW50cywgZmluYWxBY2NvdW50cykpIHtcbiAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgaGF2ZSB0aGUgY29ycmVjdCBhY2NvdW50cyBldmVuIGJlZm9yZSBzb2xhbmFfYWNjb3VudHNcbiAgICAgIC8vIHJldHVybnMsIGV4Y2VwdCBpbiBjYXNlcyB3aGVyZSBpc0ludGVybmFsIGlzIHRydWVcbiAgICAgIGlmIChpc0V0aEFjY291bnRzICYmIEFycmF5LmlzQXJyYXkodGhpcy5fc3RhdGUuYWNjb3VudHMpICYmIHRoaXMuX3N0YXRlLmFjY291bnRzLmxlbmd0aCA+IDAgJiYgIWlzSW50ZXJuYWwpIHtcbiAgICAgICAgbG9nLmVycm9yKCdUb3J1czogXCJzb2xhbmFfYWNjb3VudHNcIiB1bmV4cGVjdGVkbHkgdXBkYXRlZCBhY2NvdW50cy4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy4nLCBmaW5hbEFjY291bnRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRlLmFjY291bnRzID0gZmluYWxBY2NvdW50cztcbiAgICAgIHRoaXMuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBmaW5hbEFjY291bnRzKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgc2VsZWN0ZWRBZGRyZXNzXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRBZGRyZXNzICE9PSBmaW5hbEFjY291bnRzWzBdKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IGZpbmFsQWNjb3VudHNbMF0gfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBvbiByZWNlaXB0IG9mIGEgbmV3IGNoYWluSWQgYW5kIG5ldHdvcmtWZXJzaW9uLCBlbWl0cyBjb3JyZXNwb25kaW5nXG4gICAqIGV2ZW50cyBhbmQgc2V0cyByZWxldmFudCBwdWJsaWMgc3RhdGUuXG4gICAqIERvZXMgbm90aGluZyBpZiBuZWl0aGVyIHRoZSBjaGFpbklkIG5vciB0aGUgbmV0d29ya1ZlcnNpb24gYXJlIGRpZmZlcmVudFxuICAgKiBmcm9tIGV4aXN0aW5nIHZhbHVlcy5cbiAgICpcbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNjaGFpbkNoYW5nZWRcbiAgICogQHBhcmFtIG5ldHdvcmtJbmZvIC0gQW4gb2JqZWN0IHdpdGggbmV0d29yayBpbmZvLlxuICAgKi9cbiAgX2hhbmRsZUNoYWluQ2hhbmdlZCgpIHtcbiAgICBsZXQge1xuICAgICAgY2hhaW5JZFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IFJlY2VpdmVkIGludmFsaWQgbmV0d29yayBwYXJhbWV0ZXJzLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCB7XG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hhaW5JZCA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZUNvbm5lY3QoY2hhaW5JZCk7XG4gICAgICBpZiAoY2hhaW5JZCAhPT0gdGhpcy5jaGFpbklkKSB7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgIHRoaXMuZW1pdChcImNoYWluQ2hhbmdlZFwiLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwb24gcmVjZWlwdCBvZiBhIG5ldyBpc1VubG9ja2VkIHN0YXRlLCBzZXRzIHJlbGV2YW50IHB1YmxpYyBzdGF0ZS5cbiAgICogQ2FsbHMgdGhlIGFjY291bnRzIGNoYW5nZWQgaGFuZGxlciB3aXRoIHRoZSByZWNlaXZlZCBhY2NvdW50cywgb3IgYW4gZW1wdHlcbiAgICogYXJyYXkuXG4gICAqXG4gICAqIERvZXMgbm90aGluZyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIGV4aXN0aW5nIHZhbHVlLlxuICAgKiBUaGVyZSBhcmUgbm8gbG9jay91bmxvY2sgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgKi9cbiAgX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCgpIHtcbiAgICBsZXQge1xuICAgICAgYWNjb3VudHMsXG4gICAgICBpc1VubG9ja2VkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKHR5cGVvZiBpc1VubG9ja2VkICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IFJlY2VpdmVkIGludmFsaWQgaXNVbmxvY2tlZCBwYXJhbWV0ZXIuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIHtcbiAgICAgICAgaXNVbmxvY2tlZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1VubG9ja2VkICE9PSB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gaXNVbmxvY2tlZDtcbiAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cyB8fCBbXSk7XG4gICAgfVxuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoVG9ydXNJblBhZ2VQcm92aWRlciwgXCJfZGVmYXVsdFN0YXRlXCIsIHtcbiAgYWNjb3VudHM6IG51bGwsXG4gIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgaXNVbmxvY2tlZDogZmFsc2UsXG4gIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZDogZmFsc2UsXG4gIGhhc0VtaXR0ZWRDb25uZWN0aW9uOiBmYWxzZVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBpbWFnZSBVUkwgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGltZ0V4aXN0cyh1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHRydWUpO1xuICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZXNvbHZlKGZhbHNlKTtcbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgYSBuYW1lIGZvciB0aGUgc2l0ZSBmcm9tIHRoZSBET01cbiAqL1xuY29uc3QgZ2V0U2l0ZU5hbWUgPSB3aW5kb3cgPT4ge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IHdpbmRvdztcbiAgY29uc3Qgc2l0ZU5hbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkID4gbWV0YVtwcm9wZXJ0eT1cIm9nOnNpdGVfbmFtZVwiXScpO1xuICBpZiAoc2l0ZU5hbWUpIHtcbiAgICByZXR1cm4gc2l0ZU5hbWUuY29udGVudDtcbiAgfVxuICBjb25zdCBtZXRhVGl0bGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkID4gbWV0YVtuYW1lPVwidGl0bGVcIl0nKTtcbiAgaWYgKG1ldGFUaXRsZSkge1xuICAgIHJldHVybiBtZXRhVGl0bGUuY29udGVudDtcbiAgfVxuICBpZiAoZG9jdW1lbnQudGl0bGUgJiYgZG9jdW1lbnQudGl0bGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkb2N1bWVudC50aXRsZTtcbiAgfVxuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhbiBpY29uIGZvciB0aGUgc2l0ZSBmcm9tIHRoZSBET01cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0U2l0ZUljb24od2luZG93KSB7XG4gIHRyeSB7XG4gICAgY29uc3Qge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gd2luZG93O1xuXG4gICAgLy8gVXNlIHRoZSBzaXRlJ3MgZmF2aWNvbiBpZiBpdCBleGlzdHNcbiAgICBsZXQgaWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQgPiBsaW5rW3JlbD1cInNob3J0Y3V0IGljb25cIl0nKTtcbiAgICBpZiAoaWNvbiAmJiAoYXdhaXQgaW1nRXhpc3RzKGljb24uaHJlZikpKSB7XG4gICAgICByZXR1cm4gaWNvbi5ocmVmO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCB0aHJvdWdoIGF2YWlsYWJsZSBpY29ucyBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyXG4gICAgaWNvbiA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaGVhZCA+IGxpbmtbcmVsPVwiaWNvblwiXScpKS5maW5kKF9pY29uID0+IEJvb2xlYW4oX2ljb24uaHJlZikpO1xuICAgIGlmIChpY29uICYmIChhd2FpdCBpbWdFeGlzdHMoaWNvbi5ocmVmKSkpIHtcbiAgICAgIHJldHVybiBpY29uLmhyZWY7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBzaXRlIG1ldGFkYXRhIGFuZCByZXR1cm5zIGl0XG4gKlxuICovXG5jb25zdCBnZXRTaXRlTWV0YWRhdGEgPSBhc3luYyAoKSA9PiAoe1xuICBuYW1lOiBnZXRTaXRlTmFtZSh3aW5kb3cpLFxuICBpY29uOiBhd2FpdCBnZXRTaXRlSWNvbih3aW5kb3cpXG59KTtcblxuY29uc3QgUFJPVklERVJfVU5TQUZFX01FVEhPRFMgPSBbXCJzZW5kX3RyYW5zYWN0aW9uXCIsIFwic2lnbl90cmFuc2FjdGlvblwiLCBcInNpZ25fYWxsX3RyYW5zYWN0aW9uc1wiLCBcInNpZ25fbWVzc2FnZVwiLCBcImNvbm5lY3RcIl07XG5jb25zdCBDT01NVU5JQ0FUSU9OX1VOU0FGRV9NRVRIT0RTID0gW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNFVF9QUk9WSURFUl07XG5jb25zdCBpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSA9IHN0b3JhZ2VBdmFpbGFibGUoXCJsb2NhbFN0b3JhZ2VcIik7XG5cbi8vIHByZWxvYWQgZm9yIGlmcmFtZSBkb2Vzbid0IHdvcmsgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTkzMjY3XG4oYXN5bmMgZnVuY3Rpb24gcHJlTG9hZElmcmFtZSgpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgY29uc3QgdG9ydXNJZnJhbWVIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgY29uc3Qge1xuICAgICAgdG9ydXNVcmxcbiAgICB9ID0gYXdhaXQgZ2V0VG9ydXNVcmwoXCJwcm9kdWN0aW9uXCIpO1xuICAgIHRvcnVzSWZyYW1lSHRtbC5ocmVmID0gYCR7dG9ydXNVcmx9L2ZyYW1lYDtcbiAgICB0b3J1c0lmcmFtZUh0bWwuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIHRvcnVzSWZyYW1lSHRtbC50eXBlID0gXCJ0ZXh0L2h0bWxcIjtcbiAgICB0b3J1c0lmcmFtZUh0bWwucmVsID0gXCJwcmVmZXRjaFwiO1xuICAgIGlmICh0b3J1c0lmcmFtZUh0bWwucmVsTGlzdCAmJiB0b3J1c0lmcmFtZUh0bWwucmVsTGlzdC5zdXBwb3J0cykge1xuICAgICAgaWYgKHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0LnN1cHBvcnRzKFwicHJlZmV0Y2hcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0b3J1c0lmcmFtZUh0bWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cud2FybihlcnJvcik7XG4gIH1cbn0pKCk7XG5jbGFzcyBUb3J1cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB7XG4gICAgICBtb2RhbFpJbmRleCA9IDk5OTk5XG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNJbml0aWFsaXplZFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzQWxlcnRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RhbFpJbmRleFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsZXJ0WkluZGV4XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVxdWVzdGVkTG9naW5Qcm92aWRlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3ZpZGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29tbXVuaWNhdGlvblByb3ZpZGVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGFwcFN0b3JhZ2VLZXlcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RvcHVwSGlkZGVuXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0FsZXJ0Q29udGFpbmVyXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNVcmxcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0lmcmFtZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0eWxlTGlua1wiLCB2b2lkIDApO1xuICAgIHRoaXMudG9ydXNVcmwgPSBcIlwiO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlOyAvLyBpbml0IGRvbmVcbiAgICB0aGlzLnJlcXVlc3RlZExvZ2luUHJvdmlkZXIgPSBudWxsO1xuICAgIHRoaXMubW9kYWxaSW5kZXggPSBtb2RhbFpJbmRleDtcbiAgICB0aGlzLmFsZXJ0WkluZGV4ID0gbW9kYWxaSW5kZXggKyAxMDAwO1xuICAgIHRoaXMuZGFwcFN0b3JhZ2VLZXkgPSBcIlwiO1xuICB9XG4gIGdldCBpc0xvZ2dlZEluKCkge1xuICAgIGlmICghdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNMb2dnZWRJbjtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIGxldCB7XG4gICAgICBidWlsZEVudiA9IFRPUlVTX0JVSUxEX0VOVi5QUk9EVUNUSU9OLFxuICAgICAgZW5hYmxlTG9nZ2luZyA9IGZhbHNlLFxuICAgICAgbmV0d29yayxcbiAgICAgIHNob3dUb3J1c0J1dHRvbiA9IGZhbHNlLFxuICAgICAgdXNlTG9jYWxTdG9yYWdlID0gZmFsc2UsXG4gICAgICBidXR0b25Qb3NpdGlvbiA9IEJVVFRPTl9QT1NJVElPTi5CT1RUT01fTEVGVCxcbiAgICAgIGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiLFxuICAgICAgZXh0cmFQYXJhbXMgPSB7fSxcbiAgICAgIHdoaXRlTGFiZWxcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGluaXRpYWxpemVkXCIpO1xuICAgIHNldEFQSUtleShhcGlLZXkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcnVzVXJsLFxuICAgICAgbG9nTGV2ZWxcbiAgICB9ID0gYXdhaXQgZ2V0VG9ydXNVcmwoYnVpbGRFbnYpO1xuICAgIGxvZy5lbmFibGVBbGwoKTtcbiAgICBsb2cuaW5mbyh0b3J1c1VybCwgXCJ1cmwgbG9hZGVkXCIpO1xuICAgIGxvZy5pbmZvKGBTb2xhbmEgRW1iZWQgVmVyc2lvbiA6JHt2ZXJzaW9ufWApO1xuICAgIHRoaXMudG9ydXNVcmwgPSB0b3J1c1VybDtcbiAgICBsb2cuc2V0RGVmYXVsdExldmVsKGxvZ0xldmVsKTtcbiAgICBpZiAoZW5hYmxlTG9nZ2luZykgbG9nLmVuYWJsZUFsbCgpO2Vsc2UgbG9nLmRpc2FibGVBbGwoKTtcbiAgICBjb25zdCBkYXBwU3RvcmFnZUtleSA9IHRoaXMuaGFuZGxlRGFwcFN0b3JhZ2VLZXkodXNlTG9jYWxTdG9yYWdlKTtcbiAgICBjb25zdCB0b3J1c0lmcmFtZVVybCA9IG5ldyBVUkwodG9ydXNVcmwpO1xuICAgIGlmICh0b3J1c0lmcmFtZVVybC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHRvcnVzSWZyYW1lVXJsLnBhdGhuYW1lICs9IFwiZnJhbWVcIjtlbHNlIHRvcnVzSWZyYW1lVXJsLnBhdGhuYW1lICs9IFwiL2ZyYW1lXCI7XG4gICAgY29uc3QgaGFzaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoZGFwcFN0b3JhZ2VLZXkpIGhhc2hQYXJhbXMuYXBwZW5kKFwiZGFwcFN0b3JhZ2VLZXlcIiwgZGFwcFN0b3JhZ2VLZXkpO1xuICAgIGhhc2hQYXJhbXMuYXBwZW5kKFwib3JpZ2luXCIsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgIHRvcnVzSWZyYW1lVXJsLmhhc2ggPSBoYXNoUGFyYW1zLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBJZnJhbWUgY29kZVxuICAgIHRoaXMudG9ydXNJZnJhbWUgPSBodG1sVG9FbGVtZW50KGA8aWZyYW1lXG4gICAgICAgIGlkPVwidG9ydXNJZnJhbWVcIlxuICAgICAgICBjbGFzcz1cInRvcnVzSWZyYW1lXCJcbiAgICAgICAgc3JjPVwiJHt0b3J1c0lmcmFtZVVybC5ocmVmfVwiXG4gICAgICAgIHN0eWxlPVwiZGlzcGxheTogbm9uZTsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IHJpZ2h0OiAwOyB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlOyBib3JkZXI6IG5vbmU7IGJvcmRlci1yYWRpdXM6IDA7IHotaW5kZXg6ICR7dGhpcy5tb2RhbFpJbmRleC50b1N0cmluZygpfVwiXG4gICAgICA+PC9pZnJhbWU+YCk7XG4gICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyID0gaHRtbFRvRWxlbWVudChgPGRpdiBpZD1cInRvcnVzQWxlcnRDb250YWluZXJcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTsgei1pbmRleDogJHt0aGlzLmFsZXJ0WkluZGV4LnRvU3RyaW5nKCl9XCI+PC9kaXY+YCk7XG4gICAgdGhpcy5zdHlsZUxpbmsgPSBodG1sVG9FbGVtZW50KGA8bGluayBocmVmPVwiJHt0b3J1c1VybH0vY3NzL3dpZGdldC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+YCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudG9ydXNJZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhcHBNZXRhZGF0YSA9IGF3YWl0IGdldFNpdGVNZXRhZGF0YSgpO1xuICAgICAgICAgIC8vIHNlbmQgaW5pdCBwYXJhbXMgaGVyZVxuICAgICAgICAgIHRoaXMudG9ydXNJZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBidXR0b25Qb3NpdGlvbixcbiAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgIG5ldHdvcmssXG4gICAgICAgICAgICBkYXBwTWV0YWRhdGEsXG4gICAgICAgICAgICBleHRyYVBhcmFtcyxcbiAgICAgICAgICAgIHdoaXRlTGFiZWxcbiAgICAgICAgICB9LCB0b3J1c0lmcmFtZVVybC5vcmlnaW4pO1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwV2ViMyh7XG4gICAgICAgICAgICB0b3J1c1VybFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzaG93VG9ydXNCdXR0b24pIHRoaXMuc2hvd1RvcnVzQnV0dG9uKCk7XG4gICAgICAgICAgaWYgKHdoaXRlTGFiZWw/LnRvcHVwSGlkZSkgdGhpcy5pc1RvcHVwSGlkZGVuID0gd2hpdGVMYWJlbC50b3B1cEhpZGU7ZWxzZSB0aGlzLmhpZGVUb3J1c0J1dHRvbigpO1xuICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICB3aW5kb3cudG9ydXMgPSB0aGlzO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuc3R5bGVMaW5rKTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy50b3J1c0lmcmFtZSk7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9ydXNBbGVydENvbnRhaW5lcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxvZ2luKCkge1xuICAgIGxldCBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsIGluaXQoKSBmaXJzdFwiKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5yZXF1ZXN0ZWRMb2dpblByb3ZpZGVyID0gcGFyYW1zLmxvZ2luUHJvdmlkZXIgfHwgbnVsbDtcbiAgICAgIGlmICghdGhpcy5yZXF1ZXN0ZWRMb2dpblByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLl9kaXNwbGF5SWZyYW1lKHtcbiAgICAgICAgICBpc0Z1bGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB1c2VyIGlzIGFscmVhZHkgbG9nZ2VkIGluLCB3ZSBhc3N1bWUgdGhleSBoYXZlIGdpdmVuIGFjY2VzcyB0byB0aGUgd2Vic2l0ZVxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBXZSB1c2UgdGhpcyBtZXRob2QgYmVjYXVzZSB3ZSB3YW50IHRvIHVwZGF0ZSBpblBhZ2UgcHJvdmlkZXIgc3RhdGUgd2l0aCBhY2NvdW50IGluZm9cbiAgICAgICAgdGhpcy5wcm92aWRlci5fcnBjUmVxdWVzdCh7XG4gICAgICAgICAgbWV0aG9kOiBcInNvbGFuYV9yZXF1ZXN0QWNjb3VudHNcIixcbiAgICAgICAgICBwYXJhbXM6IFt0aGlzLnJlcXVlc3RlZExvZ2luUHJvdmlkZXIsIHBhcmFtcy5sb2dpbl9oaW50XVxuICAgICAgICB9LCBnZXRScGNQcm9taXNlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd291bGQgbmV2ZXIgaGFwcGVuLCBidXQganVzdCBpbiBjYXNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dpbiBmYWlsZWRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcImxvZ2luIGZhaWxlZFwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzSUZyYW1lRnVsbFNjcmVlbikgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuX2Rpc3BsYXlJZnJhbWUoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9naW5XaXRoUHJpdmF0ZUtleShsb2dpblBhcmFtcykge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsIGluaXQoKSBmaXJzdFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBwcml2YXRlS2V5LFxuICAgICAgdXNlckluZm9cbiAgICB9ID0gbG9naW5QYXJhbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3VjY2Vzc1xuICAgIH0gPSBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJsb2dpbl93aXRoX3ByaXZhdGVfa2V5XCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgdXNlckluZm9cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXN1Y2Nlc3MpIHRocm93IG5ldyBFcnJvcihcIkxvZ2luIEZhaWxlZFwiKTtcbiAgfVxuICBhc3luYyBsb2dvdXQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0xvZ2dlZEluKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgbG9nZ2VkIGluXCIpO1xuICAgIGF3YWl0IHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5MT0dPVVQsXG4gICAgICBwYXJhbXM6IFtdXG4gICAgfSk7XG4gICAgdGhpcy5yZXF1ZXN0ZWRMb2dpblByb3ZpZGVyID0gbnVsbDtcbiAgfVxuICBhc3luYyBjbGVhblVwKCkge1xuICAgIGlmICh0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0xvZ2dlZEluKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ291dCgpO1xuICAgIH1cbiAgICB0aGlzLmNsZWFySW5pdCgpO1xuICB9XG4gIGNsZWFySW5pdCgpIHtcbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudDtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudCh0aGlzLnN0eWxlTGluaykgJiYgd2luZG93LmRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5zdHlsZUxpbmspKSB7XG4gICAgICB0aGlzLnN0eWxlTGluay5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVMaW5rID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KHRoaXMudG9ydXNJZnJhbWUpICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMudG9ydXNJZnJhbWUpKSB7XG4gICAgICB0aGlzLnRvcnVzSWZyYW1lLnJlbW92ZSgpO1xuICAgICAgdGhpcy50b3J1c0lmcmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudCh0aGlzLnRvcnVzQWxlcnRDb250YWluZXIpICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMudG9ydXNBbGVydENvbnRhaW5lcikpIHtcbiAgICAgIHRoaXMudG9ydXNBbGVydCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cbiAgaGlkZVRvcnVzQnV0dG9uKCkge1xuICAgIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmhpZGVUb3J1c0J1dHRvbigpO1xuICB9XG4gIHNob3dUb3J1c0J1dHRvbigpIHtcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5zaG93VG9ydXNCdXR0b24oKTtcbiAgfVxuICBhc3luYyBzZXRQcm92aWRlcihwYXJhbXMpIHtcbiAgICBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0VUX1BST1ZJREVSLFxuICAgICAgcGFyYW1zOiBfb2JqZWN0U3ByZWFkKHt9LCBwYXJhbXMpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2hvd1dhbGxldChwYXRoKSB7XG4gICAgbGV0IHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgaW5zdGFuY2VJZCA9IGF3YWl0IHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5XQUxMRVRfSU5TVEFOQ0VfSUQsXG4gICAgICBwYXJhbXM6IFtdXG4gICAgfSk7XG4gICAgY29uc3QgZmluYWxQYXRoID0gcGF0aCA/IGAvJHtwYXRofWAgOiBcIlwiO1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTChgJHt0aGlzLnRvcnVzVXJsfS93YWxsZXQke2ZpbmFsUGF0aH1gKTtcbiAgICAvLyBVc2luZyBVUkwgY29uc3RydWN0b3IgdG8gcHJldmVudCBqcyBpbmplY3Rpb24gYW5kIGFsbG93IHBhcmFtZXRlciB2YWxpZGF0aW9uLiFcbiAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5zdGFuY2VJZFwiLCBpbnN0YW5jZUlkKTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goeCA9PiB7XG4gICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKHgsIHBhcmFtc1t4XSk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGFwcFN0b3JhZ2VLZXkpIHtcbiAgICAgIGZpbmFsVXJsLmhhc2ggPSBgI2RhcHBTdG9yYWdlS2V5PSR7dGhpcy5kYXBwU3RvcmFnZUtleX1gO1xuICAgIH1cbiAgICAvLyBObyBuZWVkIHRvIHRyYWNrIHRoaXMgd2luZG93IHN0YXRlLiBIZW5jZSwgbm8gX2hhbmRsZVdpbmRvdyBjYWxsLlxuICAgIGNvbnN0IHdhbGxldFdpbmRvdyA9IG5ldyBQb3B1cEhhbmRsZXIoe1xuICAgICAgdXJsOiBmaW5hbFVybCxcbiAgICAgIGZlYXR1cmVzOiBnZXRQb3B1cEZlYXR1cmVzKEZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVylcbiAgICB9KTtcbiAgICB3YWxsZXRXaW5kb3cub3BlbigpO1xuICB9XG4gIGFzeW5jIGdldFVzZXJJbmZvKCkge1xuICAgIGNvbnN0IHVzZXJJbmZvUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuVVNFUl9JTkZPLFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiB1c2VySW5mb1Jlc3BvbnNlO1xuICB9XG4gIGFzeW5jIGluaXRpYXRlVG9wdXAocHJvdmlkZXIsIHBhcmFtcykge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB0aHJvdyBuZXcgRXJyb3IoXCJUb3J1cyBpcyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgY29uc3Qgd2luZG93SWQgPSBnZXRXaW5kb3dJZCgpO1xuICAgIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLl9oYW5kbGVXaW5kb3cod2luZG93SWQpO1xuICAgIGNvbnN0IHRvcHVwUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuVE9QVVAsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgd2luZG93SWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdG9wdXBSZXNwb25zZTtcbiAgfVxuXG4gIC8vIFNvbGFuYSBzcGVjaWZpYyBBUElcbiAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImdldEFjY291bnRzXCIsXG4gICAgICBwYXJhbXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IGlzTGVnYWN5VHJhbnNhY3Rpb24gPSBpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0xlZ2FjeVRyYW5zYWN0aW9uID8gdHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZVxuICAgIH0pLnRvU3RyaW5nKFwiaGV4XCIpIDogQnVmZmVyLmZyb20odHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJzZW5kX3RyYW5zYWN0aW9uXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgaXNMZWdhY3lUcmFuc2FjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIC8vIHN1cHBvcnQgc2VuZE9wdGlvbnNcbiAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlzTGVnYWN5VHJhbnNhY3Rpb24gPSBpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0xlZ2FjeVRyYW5zYWN0aW9uID8gdHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZVxuICAgIH0pLnRvU3RyaW5nKFwiaGV4XCIpIDogQnVmZmVyLmZyb20odHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJzZW5kX3RyYW5zYWN0aW9uXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaXNMZWdhY3lUcmFuc2FjdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmU6IHJlc3BvbnNlXG4gICAgfTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBpc0xlZ2FjeVRyYW5zYWN0aW9uID0gaXNMZWdhY3lUcmFuc2FjdGlvbkluc3RhbmNlKHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNMZWdhY3lUcmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZyhcImhleFwiKSA6IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLm1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJzaWduX3RyYW5zYWN0aW9uXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZU9ubHk6IHRydWUsXG4gICAgICAgIGlzTGVnYWN5VHJhbnNhY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlY29uc3RydWN0IHNpZ25hdHVyZSBwYWlyXG4gICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0ge1xuICAgICAgcHVibGljS2V5OiBuZXcgUHVibGljS2V5KHBhcnNlZC5wdWJsaWNLZXkpLFxuICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShwYXJzZWQuc2lnbmF0dXJlLCBcImhleFwiKVxuICAgIH07XG4gICAgdHJhbnNhY3Rpb24uYWRkU2lnbmF0dXJlKHNpZ25hdHVyZS5wdWJsaWNLZXksIHNpZ25hdHVyZS5zaWduYXR1cmUpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuICBhc3luYyBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgIGxldCBpc0xlZ2FjeVRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlID0gdHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB7XG4gICAgICBpc0xlZ2FjeVRyYW5zYWN0aW9uID0gaXNMZWdhY3lUcmFuc2FjdGlvbkluc3RhbmNlKHR4KTtcbiAgICAgIHJldHVybiBpc0xlZ2FjeVRyYW5zYWN0aW9uID8gdHguc2VyaWFsaXplTWVzc2FnZSgpLnRvU3RyaW5nKFwiaGV4XCIpIDogQnVmZmVyLmZyb20odHgubWVzc2FnZS5zZXJpYWxpemUoKSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJzaWduX2FsbF90cmFuc2FjdGlvbnNcIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtZXNzYWdlOiBlbmNvZGVkTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZU9ubHk6IHRydWUsXG4gICAgICAgIGlzTGVnYWN5VHJhbnNhY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlY29uc3RydWN0IHNpZ25hdHVyZSBwYWlyc1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSByZXNwb25zZXMubWFwKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHB1YmxpY0tleTogbmV3IFB1YmxpY0tleShwYXJzZWQucHVibGljS2V5KSxcbiAgICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShwYXJzZWQuc2lnbmF0dXJlLCBcImhleFwiKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHgsIGlkeCkgPT4ge1xuICAgICAgdHguYWRkU2lnbmF0dXJlKHNpZ25hdHVyZXNbaWR4XS5wdWJsaWNLZXksIHNpZ25hdHVyZXNbaWR4XS5zaWduYXR1cmUpO1xuICAgICAgcmV0dXJuIHR4O1xuICAgIH0pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbnM7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UoZGF0YSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJzaWduX21lc3NhZ2VcIixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBkYXRhXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIGdldEdhc2xlc3NQdWJsaWNLZXkoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImdldF9nYXNsZXNzX3B1YmxpY19rZXlcIixcbiAgICAgIHBhcmFtczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICAvLyBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAvLyAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gIC8vICAgICBtZXRob2Q6IFwiY29ubmVjdFwiLFxuICAvLyAgICAgcGFyYW1zOiB7fSxcbiAgLy8gICB9KSkgYXMgYm9vbGVhbjtcbiAgLy8gICByZXR1cm4gcmVzcG9uc2U7XG4gIC8vIH1cblxuICBoYW5kbGVEYXBwU3RvcmFnZUtleSh1c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JhZ2VLZXkgPSBgJHtjb25maWd1cmF0aW9uLmxvY2FsU3RvcmFnZUtleVByZWZpeH0ke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX1gO1xuICAgIGxldCBkYXBwU3RvcmFnZUtleSA9IFwiXCI7XG4gICAgaWYgKGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlICYmIHVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgY29uc3Qgc3RvcmVkS2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU3RvcmFnZUtleSk7XG4gICAgICBpZiAoc3RvcmVkS2V5KSBkYXBwU3RvcmFnZUtleSA9IHN0b3JlZEtleTtlbHNlIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkS2V5ID0gYHRvcnVzLWFwcC0ke2dldFdpbmRvd0lkKCl9YDtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZUtleSwgZ2VuZXJhdGVkS2V5KTtcbiAgICAgICAgZGFwcFN0b3JhZ2VLZXkgPSBnZW5lcmF0ZWRLZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGFwcFN0b3JhZ2VLZXkgPSBkYXBwU3RvcmFnZUtleTtcbiAgICByZXR1cm4gZGFwcFN0b3JhZ2VLZXk7XG4gIH1cbiAgYXN5bmMgX3NldHVwV2ViMyhwcm92aWRlclBhcmFtcykge1xuICAgIGxvZy5pbmZvKFwic2V0dXBXZWIzIHJ1bm5pbmdcIik7XG4gICAgLy8gc2V0dXAgYmFja2dyb3VuZCBjb25uZWN0aW9uXG4gICAgY29uc3QgcHJvdmlkZXJTdHJlYW0gPSBuZXcgQmFzZVBvc3RNZXNzYWdlU3RyZWFtKHtcbiAgICAgIG5hbWU6IFwiZW1iZWRfdG9ydXNcIixcbiAgICAgIHRhcmdldDogXCJpZnJhbWVfdG9ydXNcIixcbiAgICAgIHRhcmdldFdpbmRvdzogdGhpcy50b3J1c0lmcmFtZS5jb250ZW50V2luZG93XG4gICAgfSk7XG5cbiAgICAvLyBXZSBjcmVhdGUgYW5vdGhlciBMb2NhbE1lc3NhZ2VEdXBsZXhTdHJlYW0gZm9yIGNvbW11bmljYXRpb24gYmV0d2VlbiBkYXBwIDw+IGlmcmFtZVxuICAgIGNvbnN0IGNvbW11bmljYXRpb25TdHJlYW0gPSBuZXcgQmFzZVBvc3RNZXNzYWdlU3RyZWFtKHtcbiAgICAgIG5hbWU6IFwiZW1iZWRfY29tbXVuaWNhdGlvblwiLFxuICAgICAgdGFyZ2V0OiBcImlmcmFtZV9jb21tdW5pY2F0aW9uXCIsXG4gICAgICB0YXJnZXRXaW5kb3c6IHRoaXMudG9ydXNJZnJhbWUuY29udGVudFdpbmRvd1xuICAgIH0pO1xuXG4gICAgLy8gY29tcG9zZSB0aGUgaW5QYWdlIHByb3ZpZGVyXG4gICAgY29uc3QgaW5QYWdlUHJvdmlkZXIgPSBuZXcgVG9ydXNJblBhZ2VQcm92aWRlcihwcm92aWRlclN0cmVhbSwge30pO1xuICAgIGNvbnN0IGNvbW11bmljYXRpb25Qcm92aWRlciA9IG5ldyBUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlcihjb21tdW5pY2F0aW9uU3RyZWFtLCB7fSk7XG4gICAgaW5QYWdlUHJvdmlkZXIudHJ5V2luZG93SGFuZGxlID0gKHBheWxvYWQsIGNiKSA9PiB7XG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3BheWxvYWQpICYmIFBST1ZJREVSX1VOU0FGRV9NRVRIT0RTLmluY2x1ZGVzKF9wYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0xvZ2dlZEluKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIE5vdCBMb2dnZWQgSW5cIik7XG4gICAgICAgIGNvbnN0IHdpbmRvd0lkID0gZ2V0V2luZG93SWQoKTtcbiAgICAgICAgY29tbXVuaWNhdGlvblByb3ZpZGVyLl9oYW5kbGVXaW5kb3cod2luZG93SWQsIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmb3IgaW5QYWdlUHJvdmlkZXIgbWV0aG9kcyBzZW5kaW5nIHdpbmRvd0lkIGluIHJlcXVlc3QgaW5zdGVhZCBvZiBwYXJhbXNcbiAgICAgICAgLy8gYXMgcGFyYW1zIG1pZ2h0IGJlIHBvc2l0aW9uYWwuXG4gICAgICAgIF9wYXlsb2FkLndpbmRvd0lkID0gd2luZG93SWQ7XG4gICAgICB9XG4gICAgICBpblBhZ2VQcm92aWRlci5fcnBjRW5naW5lLmhhbmRsZShfcGF5bG9hZCwgY2IpO1xuICAgIH07XG4gICAgY29tbXVuaWNhdGlvblByb3ZpZGVyLnRyeVdpbmRvd0hhbmRsZSA9IChwYXlsb2FkLCBjYikgPT4ge1xuICAgICAgY29uc3QgX3BheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KF9wYXlsb2FkKSAmJiBDT01NVU5JQ0FUSU9OX1VOU0FGRV9NRVRIT0RTLmluY2x1ZGVzKF9wYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgY29uc3Qgd2luZG93SWQgPSBnZXRXaW5kb3dJZCgpO1xuICAgICAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIuX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCwge1xuICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XKSAvLyB0b2RvOiBhcmUgdGhlc2UgZmVhdHVyZXMgZ2VuZXJpYyBmb3IgYWxsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmb3IgY29tbXVuaWNhdGlvbiBtZXRob2RzIHNlbmRpbmcgd2luZG93IGlkIGluIGpycGMgcmVxIHBhcmFtc1xuICAgICAgICBfcGF5bG9hZC5wYXJhbXMud2luZG93SWQgPSB3aW5kb3dJZDtcbiAgICAgIH1cbiAgICAgIGNvbW11bmljYXRpb25Qcm92aWRlci5fcnBjRW5naW5lLmhhbmRsZShfcGF5bG9hZCwgY2IpO1xuICAgIH07XG5cbiAgICAvLyBkZXRlY3Qgc29sYW5hX3JlcXVlc3RBY2NvdW50cyBhbmQgcGlwZSB0byBlbmFibGUgZm9yIG5vd1xuICAgIGNvbnN0IGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIgPSBtID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gaW5QYWdlUHJvdmlkZXJbbV07XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgaW5QYWdlUHJvdmlkZXJbbV0gPSBmdW5jdGlvbiBwcm92aWRlckZ1bmMocmVxdWVzdCwgY2IpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBwYXJhbXMgPSBbXVxuICAgICAgICB9ID0gcmVxdWVzdDtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJzb2xhbmFfcmVxdWVzdEFjY291bnRzXCIpIHtcbiAgICAgICAgICBpZiAoIWNiKSByZXR1cm4gc2VsZi5sb2dpbih7XG4gICAgICAgICAgICBsb2dpblByb3ZpZGVyOiBwYXJhbXNbMF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmxvZ2luKHtcbiAgICAgICAgICAgIGxvZ2luUHJvdmlkZXI6IHBhcmFtc1swXVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2Uvbm8tY2FsbGJhY2staW4tcHJvbWlzZVxuICAgICAgICAgIC50aGVuKHJlcyA9PiBjYihudWxsLCByZXMpKVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IGNiKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgW3JlcXVlc3QsIGNiXSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBEZXRlY3RzIGNhbGwgdG8gc29sYW5hX3JlcXVlc3RBY2NvdW50cyBpbiByZXF1ZXN0ICYgc2VuZEFzeW5jIGFuZCBwYXNzZXMgdG8gbG9naW5cbiAgICBkZXRlY3RBY2NvdW50UmVxdWVzdFByb3RvdHlwZU1vZGlmaWVyKFwicmVxdWVzdFwiKTtcbiAgICBkZXRlY3RBY2NvdW50UmVxdWVzdFByb3RvdHlwZU1vZGlmaWVyKFwic2VuZEFzeW5jXCIpO1xuICAgIGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIoXCJzZW5kXCIpO1xuICAgIGNvbnN0IHByb3hpZWRJblBhZ2VQcm92aWRlciA9IG5ldyBQcm94eShpblBhZ2VQcm92aWRlciwge1xuICAgICAgLy8gc3RyYWlnaHQgdXAgbGllIHRoYXQgd2UgZGVsZXRlZCB0aGUgcHJvcGVydHkgc28gdGhhdCBpdCBkb2Vzbid0XG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBpbiBzdHJpY3QgbW9kZVxuICAgICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBwcm94aWVkQ29tbXVuaWNhdGlvblByb3ZpZGVyID0gbmV3IFByb3h5KGNvbW11bmljYXRpb25Qcm92aWRlciwge1xuICAgICAgLy8gc3RyYWlnaHQgdXAgbGllIHRoYXQgd2UgZGVsZXRlZCB0aGUgcHJvcGVydHkgc28gdGhhdCBpdCBkb2Vzbid0XG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBpbiBzdHJpY3QgbW9kZVxuICAgICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJveGllZEluUGFnZVByb3ZpZGVyO1xuICAgIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyID0gcHJveGllZENvbW11bmljYXRpb25Qcm92aWRlcjtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbaW5QYWdlUHJvdmlkZXIuX2luaXRpYWxpemVTdGF0ZSgpLCBjb21tdW5pY2F0aW9uUHJvdmlkZXIuX2luaXRpYWxpemVTdGF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3ZpZGVyUGFyYW1zKSwge30sIHtcbiAgICAgIGRhcHBTdG9yYWdlS2V5OiB0aGlzLmRhcHBTdG9yYWdlS2V5LFxuICAgICAgdG9ydXNBbGVydENvbnRhaW5lcjogdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLFxuICAgICAgdG9ydXNJZnJhbWU6IHRoaXMudG9ydXNJZnJhbWVcbiAgICB9KSldKTtcbiAgICBsb2cuZGVidWcoXCJUb3J1cyAtIGluamVjdGVkIHByb3ZpZGVyXCIpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJVVFRPTl9QT1NJVElPTiwgTE9HSU5fUFJPVklERVIsIFBBWU1FTlRfUFJPVklERVIsIFRPUlVTX0JVSUxEX0VOViwgVG9ydXNJblBhZ2VQcm92aWRlciwgVG9ydXMgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIl9vYmplY3RTcHJlYWQiLCJfZGVmaW5lUHJvcGVydHkiLCJQdWJsaWNLZXkiLCJjcmVhdGVMb2dnZXJNaWRkbGV3YXJlIiwiQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMiLCJDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMiLCJQUk9WSURFUl9KUlBDX01FVEhPRFMiLCJQUk9WSURFUl9OT1RJRklDQVRJT05TIiwic2V0QVBJS2V5IiwiU2FmZUV2ZW50RW1pdHRlciIsIk9iamVjdE11bHRpcGxleCIsImNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUiLCJKUlBDRW5naW5lIiwiY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUiLCJnZXRScGNQcm9taXNlQ2FsbGJhY2siLCJCYXNlUG9zdE1lc3NhZ2VTdHJlYW0iLCJldGhFcnJvcnMiLCJFdGhlcmV1bVJwY0Vycm9yIiwicHVtcCIsImxvZ2xldmVsIiwiZGVxdWFsIiwidmVyc2lvbiIsImlzU3RyZWFtIiwic3RyZWFtIiwicGlwZSIsImlzV3JpdGFibGVTdHJlYW0iLCJ3cml0YWJsZSIsIl93cml0ZSIsIl93cml0YWJsZVN0YXRlIiwiaXNSZWFkYWJsZVN0cmVhbSIsInJlYWRhYmxlIiwiX3JlYWQiLCJfcmVhZGFibGVTdGF0ZSIsImlzRHVwbGV4U3RyZWFtIiwibWVzc2FnZXMiLCJlcnJvcnMiLCJkaXNjb25uZWN0ZWQiLCJwZXJtYW5lbnRseURpc2Nvbm5lY3RlZCIsInVuc3VwcG9ydGVkU3luYyIsIm1ldGhvZCIsImludmFsaWREdXBsZXhTdHJlYW0iLCJpbnZhbGlkT3B0aW9ucyIsIm1heEV2ZW50TGlzdGVuZXJzIiwiaW52YWxpZFJlcXVlc3RBcmdzIiwiaW52YWxpZFJlcXVlc3RNZXRob2QiLCJpbnZhbGlkUmVxdWVzdFBhcmFtcyIsImludmFsaWRMb2dnZXJPYmplY3QiLCJpbnZhbGlkTG9nZ2VyTWV0aG9kIiwiaW5mbyIsImNvbm5lY3RlZCIsImNoYWluSWQiLCJ3YXJuaW5ncyIsIlBBWU1FTlRfUFJPVklERVIiLCJNT09OUEFZIiwiV1lSRSIsIlJBTVBORVRXT1JLIiwiWEFOUE9PTCIsIk1FUkNVUllPIiwiVFJBTlNBSyIsIlRPUlVTX0JVSUxEX0VOViIsIlBST0RVQ1RJT04iLCJERVZFTE9QTUVOVCIsIlRFU1RJTkciLCJCVVRUT05fUE9TSVRJT04iLCJCT1RUT01fTEVGVCIsIlRPUF9MRUZUIiwiQk9UVE9NX1JJR0hUIiwiVE9QX1JJR0hUIiwiTE9HSU5fUFJPVklERVIiLCJHT09HTEUiLCJGQUNFQk9PSyIsIlJFRERJVCIsIkRJU0NPUkQiLCJUV0lUQ0giLCJBUFBMRSIsIkxJTkUiLCJHSVRIVUIiLCJLQUtBTyIsIkxJTktFRElOIiwiVFdJVFRFUiIsIldFSUJPIiwiV0VDSEFUIiwiRU1BSUxfUEFTU1dPUkRMRVNTIiwidHJhbnNsYXRpb25zIiwiZW4iLCJlbWJlZCIsImNvbnRpbnVlIiwiYWN0aW9uUmVxdWlyZWQiLCJwZW5kaW5nQWN0aW9uIiwiY29va2llc1JlcXVpcmVkIiwiZW5hYmxlQ29va2llcyIsImNsaWNrSGVyZSIsImRlIiwiamEiLCJrbyIsInpoIiwiY29uZmlndXJhdGlvbiIsInN1cHBvcnRlZFZlcmlmaWVyTGlzdCIsImFwaSIsInByb2RUb3J1c1VybCIsImxvY2FsU3RvcmFnZUtleVByZWZpeCIsImxvZyIsImdldExvZ2dlciIsImNyZWF0ZUVycm9yTWlkZGxld2FyZSIsInJlcSIsInJlcyIsIm5leHQiLCJlcnJvciIsInJwYyIsImludmFsaWRSZXF1ZXN0IiwibWVzc2FnZSIsImRhdGEiLCJkb25lIiwibG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmciLCJyZW1vdGVMYWJlbCIsImVtaXR0ZXIiLCJ3YXJuaW5nTXNnIiwic3RhY2siLCJ3YXJuIiwibGlzdGVuZXJDb3VudCIsImVtaXQiLCJnZXRXaW5kb3dJZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiZ2V0VG9ydXNVcmwiLCJidWlsZEVudiIsInRvcnVzVXJsIiwibG9nTGV2ZWwiLCJnZXRVc2VyTGFuZ3VhZ2UiLCJ1c2VyTGFuZ3VhZ2UiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsInVzZXJMYW5ndWFnZXMiLCJzcGxpdCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1ciLCJoZWlnaHQiLCJ3aWR0aCIsIkZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVyIsIkZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XIiwiRkVBVFVSRVNfQ09ORklSTV9XSU5ET1ciLCJzdG9yYWdlQXZhaWxhYmxlIiwidHlwZSIsInN0b3JhZ2UiLCJ4Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlIiwiY29kZSIsIm5hbWUiLCJsZW5ndGgiLCJnZXRQb3B1cEZlYXR1cmVzIiwiX3JlZiIsInciLCJoIiwiZHVhbFNjcmVlbkxlZnQiLCJzY3JlZW5MZWZ0IiwidW5kZWZpbmVkIiwic2NyZWVuWCIsImR1YWxTY3JlZW5Ub3AiLCJzY3JlZW5Ub3AiLCJzY3JlZW5ZIiwiaW5uZXJXaWR0aCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJzY3JlZW4iLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsInN5c3RlbVpvb20iLCJsZWZ0IiwiYWJzIiwidG9wIiwiZmVhdHVyZXMiLCJCYXNlUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb25TdHJlYW0iLCJqc29uUnBjU3RyZWFtTmFtZSIsIkVycm9yIiwiaXNUb3J1cyIsInNldE1heExpc3RlbmVycyIsIl9oYW5kbGVDb25uZWN0IiwiYmluZCIsIl9oYW5kbGVEaXNjb25uZWN0IiwiX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QiLCJfcnBjUmVxdWVzdCIsIl9pbml0aWFsaXplU3RhdGUiLCJyZXF1ZXN0Iiwic2VuZEFzeW5jIiwibXV4IiwiaWdub3JlU3RyZWFtIiwianNvblJwY0Nvbm5lY3Rpb24iLCJjcmVhdGVTdHJlYW0iLCJycGNFbmdpbmUiLCJwdXNoIiwib3JpZ2luIiwibG9jYXRpb24iLCJtaWRkbGV3YXJlIiwiX3JwY0VuZ2luZSIsImpzb25ScGNDb25uZWN0aW9uRXZlbnRzIiwiZXZlbnRzIiwiYXJncyIsIkFycmF5IiwiaXNBcnJheSIsInBhcmFtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic2VuZCIsInBheWxvYWQiLCJjYWxsYmFjayIsInN0cmVhbU5hbWUiLCJodG1sVG9FbGVtZW50IiwiaHRtbCIsInRlbXBsYXRlIiwiY3JlYXRlRWxlbWVudCIsInRyaW1tZWRIdG1sIiwidHJpbSIsImlubmVySFRNTCIsImNvbnRlbnQiLCJmaXJzdENoaWxkIiwiaXNMZWdhY3lUcmFuc2FjdGlvbkluc3RhbmNlIiwidHJhbnNhY3Rpb24iLCJQb3B1cEhhbmRsZXIiLCJ1cmwiLCJ0YXJnZXQiLCJ0aW1lb3V0Iiwid2luZG93VGltZXIiLCJpQ2xvc2VkV2luZG93IiwiX3NldHVwVGltZXIiLCJOdW1iZXIiLCJzZXRJbnRlcnZhbCIsImNsb3NlZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRUaW1lb3V0Iiwib3BlbiIsImhyZWYiLCJmb2N1cyIsImNsb3NlIiwicmVkaXJlY3QiLCJsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0IiwicmVwbGFjZSIsIlRvcnVzQ29tbXVuaWNhdGlvblByb3ZpZGVyIiwiX3N0YXRlIiwiX2RlZmF1bHRTdGF0ZSIsImRhcHBTdG9yYWdlS2V5IiwibGFuZ3VhZ2VUcmFuc2xhdGlvbnMiLCJlbWJlZFRyYW5zbGF0aW9ucyIsIndpbmRvd1JlZnMiLCJvbiIsImlzQ29ubmVjdGVkIiwibm90aWZpY2F0aW9uSGFuZGxlciIsIklGUkFNRV9TVEFUVVMiLCJpc0Z1bGxTY3JlZW4iLCJyaWQiLCJfZGlzcGxheUlmcmFtZSIsImlzRnVsbCIsIndpbmRvd0lkIiwiX2NyZWF0ZVBvcHVwQmxvY2tBbGVydCIsIkNMT1NFX1dJTkRPVyIsIl9oYW5kbGVDbG9zZVdpbmRvdyIsIlVTRVJfTE9HR0VEX0lOIiwiY3VycmVudExvZ2luUHJvdmlkZXIiLCJpc0xvZ2dlZEluIiwiVVNFUl9MT0dHRURfT1VUIiwiaXNJRnJhbWVGdWxsU2NyZWVuIiwidG9ydXNBbGVydENvbnRhaW5lciIsInRvcnVzSWZyYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsIkdFVF9QUk9WSURFUl9TVEFURSIsImluaXRpYWxpemVkIiwiX2hhbmRsZVdpbmRvdyIsImFyZ3VtZW50cyIsImZpbmFsVXJsIiwiVVJMIiwiaGFzaCIsImhhbmRsZWRXaW5kb3ciLCJvbmNlIiwiQ0xPU0VEX1dJTkRPVyIsInN0eWxlIiwiZGlzcGxheSIsInRvcnVzV2lkZ2V0VmlzaWJpbGl0eSIsImJ1dHRvblBvc2l0aW9uIiwicmlnaHQiLCJib3R0b20iLCJhc3NpZ24iLCJoaWRlVG9ydXNCdXR0b24iLCJzaG93VG9ydXNCdXR0b24iLCJjYiIsIl9wYXlsb2FkIiwianNvbnJwYyIsInRyeVdpbmRvd0hhbmRsZSIsImRlYnVnIiwiaXNSZWNvdmVyYWJsZSIsImVycm9yTWVzc2FnZSIsImlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQiLCJsb2dvVXJsIiwiZ2V0TG9nb1VybCIsInRvcnVzQWxlcnQiLCJzdWNjZXNzQWxlcnQiLCJidG5Db250YWluZXIiLCJhcHBlbmRDaGlsZCIsImJpbmRPbkxvYWQiLCJyZW1vdmUiLCJjaGlsZHJlbiIsImF0dGFjaE9uTG9hZCIsImhhc0VtaXR0ZWRDb25uZWN0aW9uIiwiVG9ydXNJblBhZ2VQcm92aWRlciIsInNlbGVjdGVkQWRkcmVzcyIsIl9oYW5kbGVBY2NvdW50c0NoYW5nZWQiLCJfaGFuZGxlQ2hhaW5DaGFuZ2VkIiwiX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCIsImpzb25ScGNOb3RpZmljYXRpb25IYW5kbGVyIiwiQUNDT1VOVFNfQ0hBTkdFRCIsIlVOTE9DS19TVEFURV9DSEFOR0VEIiwiQ0hBSU5fQ0hBTkdFRCIsImFjY291bnRzIiwiaXNVbmxvY2tlZCIsImlzSW50ZXJuYWwiLCJlcnIiLCJyZXN1bHQiLCJoYW5kbGUiLCJpc0V0aEFjY291bnRzIiwiZmluYWxBY2NvdW50cyIsImFjY291bnQiLCJpbWdFeGlzdHMiLCJpbWciLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwiZ2V0U2l0ZU5hbWUiLCJzaXRlTmFtZSIsInF1ZXJ5U2VsZWN0b3IiLCJtZXRhVGl0bGUiLCJ0aXRsZSIsImhvc3RuYW1lIiwiZ2V0U2l0ZUljb24iLCJpY29uIiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmaW5kIiwiX2ljb24iLCJCb29sZWFuIiwiZ2V0U2l0ZU1ldGFkYXRhIiwiUFJPVklERVJfVU5TQUZFX01FVEhPRFMiLCJDT01NVU5JQ0FUSU9OX1VOU0FGRV9NRVRIT0RTIiwiU0VUX1BST1ZJREVSIiwiaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUiLCJwcmVMb2FkSWZyYW1lIiwidG9ydXNJZnJhbWVIdG1sIiwiY3Jvc3NPcmlnaW4iLCJyZWwiLCJyZWxMaXN0Iiwic3VwcG9ydHMiLCJoZWFkIiwiVG9ydXMiLCJtb2RhbFpJbmRleCIsImlzSW5pdGlhbGl6ZWQiLCJyZXF1ZXN0ZWRMb2dpblByb3ZpZGVyIiwiYWxlcnRaSW5kZXgiLCJjb21tdW5pY2F0aW9uUHJvdmlkZXIiLCJpbml0IiwiZW5hYmxlTG9nZ2luZyIsIm5ldHdvcmsiLCJ1c2VMb2NhbFN0b3JhZ2UiLCJhcGlLZXkiLCJleHRyYVBhcmFtcyIsIndoaXRlTGFiZWwiLCJlbmFibGVBbGwiLCJzZXREZWZhdWx0TGV2ZWwiLCJkaXNhYmxlQWxsIiwiaGFuZGxlRGFwcFN0b3JhZ2VLZXkiLCJ0b3J1c0lmcmFtZVVybCIsInBhdGhuYW1lIiwiZW5kc1dpdGgiLCJoYXNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwic3R5bGVMaW5rIiwiZGFwcE1ldGFkYXRhIiwiY29udGVudFdpbmRvdyIsInBvc3RNZXNzYWdlIiwiX3NldHVwV2ViMyIsInRvcHVwSGlkZSIsImlzVG9wdXBIaWRkZW4iLCJ0b3J1cyIsImJvZHkiLCJsb2dpbiIsImxvZ2luUHJvdmlkZXIiLCJwcm92aWRlciIsImxvZ2luX2hpbnQiLCJsb2dpbldpdGhQcml2YXRlS2V5IiwibG9naW5QYXJhbXMiLCJwcml2YXRlS2V5IiwidXNlckluZm8iLCJzdWNjZXNzIiwibG9nb3V0IiwiTE9HT1VUIiwiY2xlYW5VcCIsImNsZWFySW5pdCIsImlzRWxlbWVudCIsImVsZW1lbnQiLCJFbGVtZW50IiwiRG9jdW1lbnQiLCJjb250YWlucyIsInNldFByb3ZpZGVyIiwic2hvd1dhbGxldCIsInBhdGgiLCJpbnN0YW5jZUlkIiwiV0FMTEVUX0lOU1RBTkNFX0lEIiwiZmluYWxQYXRoIiwic2VhcmNoUGFyYW1zIiwia2V5cyIsImZvckVhY2giLCJ3YWxsZXRXaW5kb3ciLCJnZXRVc2VySW5mbyIsInVzZXJJbmZvUmVzcG9uc2UiLCJVU0VSX0lORk8iLCJpbml0aWF0ZVRvcHVwIiwidG9wdXBSZXNwb25zZSIsIlRPUFVQIiwiZ2V0QWNjb3VudHMiLCJyZXNwb25zZSIsInNlbmRUcmFuc2FjdGlvbiIsImlzTGVnYWN5VHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJyZXF1aXJlQWxsU2lnbmF0dXJlcyIsIkJ1ZmZlciIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iLCJvcHRpb25zIiwic2lnbmF0dXJlIiwic2lnblRyYW5zYWN0aW9uIiwic2VyaWFsaXplTWVzc2FnZSIsIm1lc3NhZ2VPbmx5IiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwicHVibGljS2V5IiwiYWRkU2lnbmF0dXJlIiwic2lnbkFsbFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsImVuY29kZWRNZXNzYWdlIiwibWFwIiwidHgiLCJyZXNwb25zZXMiLCJzaWduYXR1cmVzIiwiaXRlbSIsImlkeCIsInNpZ25NZXNzYWdlIiwiZ2V0R2FzbGVzc1B1YmxpY0tleSIsImxvY2FsU3RvcmFnZUtleSIsInN0b3JlZEtleSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJnZW5lcmF0ZWRLZXkiLCJwcm92aWRlclBhcmFtcyIsInByb3ZpZGVyU3RyZWFtIiwidGFyZ2V0V2luZG93IiwiY29tbXVuaWNhdGlvblN0cmVhbSIsImluUGFnZVByb3ZpZGVyIiwiaW5jbHVkZXMiLCJkZXRlY3RBY2NvdW50UmVxdWVzdFByb3RvdHlwZU1vZGlmaWVyIiwibSIsIm9yaWdpbmFsTWV0aG9kIiwic2VsZiIsInByb3ZpZGVyRnVuYyIsInRoZW4iLCJjYXRjaCIsImFwcGx5IiwicHJveGllZEluUGFnZVByb3ZpZGVyIiwiUHJveHkiLCJkZWxldGVQcm9wZXJ0eSIsInByb3hpZWRDb21tdW5pY2F0aW9uUHJvdmlkZXIiLCJhbGwiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js\n");

/***/ })

};
;