import { NextRequest, NextResponse } from 'next/server'
import OpenAI from 'openai'
import { availableTools, SOLANA_ANALYST_SYSTEM_PROMPT } from '@/lib/ai-tools'
import {
  getTransactionHistory,
  getSolBalance,
  getTokenHoldings,
  getLastTransaction,
  getAccountInfo,
  countTransactionsByDateRange
} from '@/services/solana-tools'

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || '',
})
export async function POST(request: NextRequest) {
  try {
    console.log('üîç Chat API called')
    const body = await request.json()
    console.log('üìù Request body:', body)
    
    const { query, address } = body

    if (!query || !address) {
      console.log('‚ùå Missing query or address:', { query, address })
      return NextResponse.json(
        { error: 'Query and address are required' },
        { status: 400 }
      )
    }

    console.log(`ü§ñ Processing query: "${query}" for address: ${address}`)

    // Check if OpenAI is configured, if not use simple fallback
    if (!process.env.OPENAI_API_KEY) {
      console.log('‚ö†Ô∏è OpenAI not configured, using simple fallback')
      return NextResponse.json({
        response: "OpenAI is not configured. Please set up the OPENAI_API_KEY environment variable to enable intelligent chat analysis.",
        error: "OpenAI API key not configured"
      }, { status: 500 })
    }

    // === STEP 1: Initial AI conversation with tools ===
    const messages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
      {
        role: "system",
        content: SOLANA_ANALYST_SYSTEM_PROMPT
      },
      {
        role: "user",
        content: `User query about Solana address ${address}: ${query}`
      }
    ]

    console.log('üîß Sending query to AI with available tools...')

    const initialResponse = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: messages,
      tools: availableTools,
      tool_choice: "auto",
      temperature: 0.1, // Low temperature for factual accuracy
    })

    const responseMessage = initialResponse.choices[0].message
    const toolCalls = responseMessage.tool_calls

    // === STEP 2: Execute tool calls if requested ===
    if (toolCalls && toolCalls.length > 0) {
      console.log(`üõ†Ô∏è AI requested ${toolCalls.length} tool calls`)

      // Add the AI's response to conversation history
      messages.push(responseMessage)

      // Execute each tool call
      for (const toolCall of toolCalls) {
        const functionName = toolCall.function.name
        const functionArgs = JSON.parse(toolCall.function.arguments)

        console.log(`üîß Executing tool: ${functionName} with args:`, functionArgs)

        let functionResponse: any
        let processedData: string

        try {
          // Execute the appropriate function based on AI's request
          switch (functionName) {
            case "getTransactionHistory":
              functionResponse = await getTransactionHistory(
                functionArgs.address || address,
                functionArgs.limit || 1000
              )
              processedData = JSON.stringify(functionResponse)
              break

            case "countTransactionsByDateRange":
              functionResponse = await countTransactionsByDateRange(
                functionArgs.address || address,
                functionArgs.startDate,
                functionArgs.endDate
              )
              processedData = `Transaction count: ${functionResponse}`
              break

            case "getSolBalance":
              functionResponse = await getSolBalance(functionArgs.address || address)
              processedData = `Current SOL balance: ${functionResponse} SOL`
              break

            case "getTokenHoldings":
              functionResponse = await getTokenHoldings(functionArgs.address || address)
              processedData = `Token holdings: ${functionResponse.length} different tokens found. Details: ${JSON.stringify(functionResponse.slice(0, 10))}` // Limit for context
              break

            case "getLastTransaction":
              functionResponse = await getLastTransaction(functionArgs.address || address)
              if (functionResponse) {
                const daysAgo = functionResponse.blockTime ?
                  Math.floor((Date.now() - functionResponse.blockTime) / (1000 * 60 * 60 * 24)) : 'unknown'
                processedData = `Last transaction: ${functionResponse.signature} on ${new Date(functionResponse.blockTime || 0).toLocaleDateString()} (${daysAgo} days ago). Status: ${functionResponse.status}`
              } else {
                processedData = "No transactions found for this address"
              }
              break

            case "getAccountInfo":
              functionResponse = await getAccountInfo(functionArgs.address || address)
              processedData = `Account info: Balance ${functionResponse.lamports / 1e9} SOL, Owner: ${functionResponse.owner}, Executable: ${functionResponse.executable}`
              break

            default:
              throw new Error(`Unknown function: ${functionName}`)
          }

          // Add the function result to conversation history
          messages.push({
            tool_call_id: toolCall.id,
            role: "tool",
            content: processedData
          })

          console.log(`‚úÖ Tool ${functionName} executed successfully`)

        } catch (error) {
          console.error(`‚ùå Tool ${functionName} failed:`, error)

          // Add error to conversation so AI can handle it
          messages.push({
            tool_call_id: toolCall.id,
            role: "tool",
            content: `Error executing ${functionName}: ${error instanceof Error ? error.message : String(error)}`
          })
        }
      }

      // === STEP 3: Get final AI response with tool results ===
      console.log('üß† Getting final AI response with tool results...')

      const finalResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: messages,
        temperature: 0.1
      })

      const finalAnswer = finalResponse.choices[0].message.content

      console.log('‚úÖ AI analysis complete')
      return NextResponse.json({
        response: finalAnswer,
        toolsUsed: toolCalls.map(tc => tc.function.name)
      })
    } else {
      // AI can answer without tools
      console.log('üí¨ AI answered directly without tools')
      return NextResponse.json({
        response: responseMessage.content,
        toolsUsed: []
      })
    }

  } catch (error) {
    console.error('‚ùå Chat enhanced error:', error)
    return NextResponse.json(
      {
        error: 'Failed to process query',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    )
  }
}

/**
 * Processes transaction data based on the user's query
 * This is where we handle specific questions like "transfers in June"
 */
async function processTransactionData(transactions: Transaction[], originalQuery: string): Promise<string> {
  const queryLower = originalQuery.toLowerCase()

  // Handle month-specific queries
  const monthNames = ['january', 'february', 'march', 'april', 'may', 'june',
    'july', 'august', 'september', 'october', 'november', 'december']

  for (const month of monthNames) {
    if (queryLower.includes(month)) {
      const currentYear = new Date().getFullYear()
      const count = countTransfersInMonth(transactions, month, currentYear)
      return `Transaction analysis: Found ${count} transfers in ${month.charAt(0).toUpperCase() + month.slice(1)} ${currentYear}. Total transactions analyzed: ${transactions.length}`
    }
  }

  // Handle "last X days" queries
  const daysMatch = queryLower.match(/(\d+)\s+days?/)
  if (daysMatch) {
    const days = parseInt(daysMatch[1])
    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)
    const endDate = new Date()
    const recentTxs = getTransactionsInDateRange(transactions, startDate, endDate)
    return `Transaction analysis: Found ${recentTxs.length} transactions in the last ${days} days. Total transactions analyzed: ${transactions.length}`
  }

  // Handle "how many" queries
  if (queryLower.includes('how many')) {
    const successfulTxs = transactions.filter(tx => tx.status === 'Success')
    const lastTx = transactions[transactions.length - 1]
    const daysSinceFirst = transactions.length > 0 && lastTx?.blockTime ?
      Math.floor((Date.now() - lastTx.blockTime) / (1000 * 60 * 60 * 24)) : 0

    return `Transaction analysis: Total ${transactions.length} transactions found (${successfulTxs.length} successful). Account active for approximately ${daysSinceFirst} days.`
  }

  // Default comprehensive summary
  const successfulTxs = transactions.filter(tx => tx.status === 'Success')
  const daysSinceLastActivity = getDaysSinceLastActivity(transactions)

  return `Transaction analysis: Found ${transactions.length} total transactions (${successfulTxs.length} successful). Last activity: ${daysSinceLastActivity} days ago.`
}

// Pattern matching fallback when OpenAI is not available
async function handleQueryWithPatternMatching(query: string, address: string) {
  try {
    console.log(`üîç Pattern matching for query: "${query}" with address: ${address}`)
    const queryLower = query.toLowerCase()

    // Handle "last X transactions" queries
    if (queryLower.includes('last') && (queryLower.includes('transactions') || queryLower.includes('transaction'))) {
      console.log('üìä Fetching transaction history...')
      const transactions = await getTransactionHistory(address, 100)
      console.log(`‚úÖ Found ${transactions.length} transactions`)

      const count = queryLower.includes('5') ? 5 :
        queryLower.includes('10') ? 10 :
          queryLower.includes('3') ? 3 : 5 // default to 5

      const recentTxs = transactions.slice(0, count)
      let response = `Here are the last ${count} transactions for this wallet:\n\n`

      recentTxs.forEach((tx, index) => {
        const date = tx.blockTime ? new Date(tx.blockTime).toLocaleDateString() : 'Unknown date'
        response += `${index + 1}. ${tx.signature.substring(0, 20)}... (${date}) - ${tx.status}\n`
      })

      if (recentTxs.length === 0) {
        response = "No transactions found for this wallet."
      }

      return NextResponse.json({
        response,
        data: { transactions: recentTxs, count: recentTxs.length }
      })
    }

    // Handle transaction count queries for specific months
    if (queryLower.includes('november 2024') || queryLower.includes('nov 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'november', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in November 2024.`,
        data: { transactionCount: novemberCount, month: 'November 2024' }
      })
    }

    if (queryLower.includes('september 2024') || queryLower.includes('sep 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'september', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in September 2024.`,
        data: { transactionCount: novemberCount, month: 'September 2024' }
      })
    }

    if (queryLower.includes('august 2024') || queryLower.includes('aug 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'august', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in August 2024.`,
        data: { transactionCount: novemberCount, month: 'August 2024' }
      })
    }

    if (queryLower.includes('july 2024') || queryLower.includes('jul 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'july', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in July 2024.`,
        data: { transactionCount: novemberCount, month: 'July 2024' }
      })
    }

    if (queryLower.includes('june 2024') || queryLower.includes('jun 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'june', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in June 2024.`,
        data: { transactionCount: novemberCount, month: 'June 2024' }
      })
    }

    if (queryLower.includes('may 2024') || queryLower.includes('may 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'may', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in May 2024.`,
        data: { transactionCount: novemberCount, month: 'May 2024' }
      })
    }

    if (queryLower.includes('april 2024') || queryLower.includes('apr 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'april', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in April 2024.`,
        data: { transactionCount: novemberCount, month: 'April 2024' }
      })
    }

    if (queryLower.includes('march 2024') || queryLower.includes('mar 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'march', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in March 2024.`,
        data: { transactionCount: novemberCount, month: 'March 2024' }
      })
    }

    if (queryLower.includes('february 2024') || queryLower.includes('feb 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'february', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in February 2024.`,
        data: { transactionCount: novemberCount, month: 'February 2024' }
      })
    }

    if (queryLower.includes('january 2024') || queryLower.includes('jan 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'january', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in January 2024.`,
        data: { transactionCount: novemberCount, month: 'January 2024' }
      })
    }

    if (queryLower.includes('december 2024') || queryLower.includes('dec 2024')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'december', 2024)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in December 2024.`,
        data: { transactionCount: novemberCount, month: 'December 2024' }
      })
    }

    if (queryLower.includes('january 2025') || queryLower.includes('jan 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'january', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in January 2025.`,
        data: { transactionCount: novemberCount, month: 'January 2025' }
      })
    }

    if (queryLower.includes('december 2025') || queryLower.includes('dec 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'december', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in December 2025.`,
        data: { transactionCount: novemberCount, month: 'December 2025' }
      })
    }

    if (queryLower.includes('november 2025') || queryLower.includes('nov 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'november', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in November 2025.`,
        data: { transactionCount: novemberCount, month: 'November 2025' }
      })
    }

    if (queryLower.includes('october 2025') || queryLower.includes('oct 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'october', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in October 2025.`,
        data: { transactionCount: novemberCount, month: 'October 2025' }
      })
    }

    if (queryLower.includes('september 2025') || queryLower.includes('sep 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'september', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in September 2025.`,
        data: { transactionCount: novemberCount, month: 'September 2025' }
      })
    }

    if (queryLower.includes('august 2025') || queryLower.includes('aug 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'august', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in August 2025.`,
        data: { transactionCount: novemberCount, month: 'August 2025' }
      })
    }

    if (queryLower.includes('july 2025') || queryLower.includes('jul 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'july', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in July 2025.`,
        data: { transactionCount: novemberCount, month: 'July 2025' }
      })
    }

    if (queryLower.includes('june 2025') || queryLower.includes('jun 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'june', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in June 2025.`,
        data: { transactionCount: novemberCount, month: 'June 2025' }
      })
    }

    if (queryLower.includes('may 2025') || queryLower.includes('may 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'may', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in May 2025.`,
        data: { transactionCount: novemberCount, month: 'May 2025' }
      })
    }

    if (queryLower.includes('april 2025') || queryLower.includes('apr 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'april', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in April 2025.`,
        data: { transactionCount: novemberCount, month: 'April 2025' }
      })
    }

    if (queryLower.includes('march 2025') || queryLower.includes('mar 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'march', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in March 2025.`,
        data: { transactionCount: novemberCount, month: 'March 2025' }
      })
    }

    if (queryLower.includes('february 2025') || queryLower.includes('feb 2025')) {
      const transactions = await getTransactionHistory(address, 5000)
      const novemberCount = countTransfersInMonth(transactions, 'february', 2025)
      return NextResponse.json({
        response: `This wallet carried out ${novemberCount} transactions in February 2025.`,
        data: { transactionCount: novemberCount, month: 'February 2025' }
      })
    }


    // Handle general transaction count queries
    if (queryLower.includes('how many transactions') || queryLower.includes('transaction count')) {
      const transactions = await getTransactionHistory(address, 5000)
      return NextResponse.json({
        response: `This wallet has a total of ${transactions.length} transactions in its history.`,
        data: { totalTransactions: transactions.length }
      })
    }

    // Handle balance queries
    if (queryLower.includes('balance') || queryLower.includes('sol balance')) {
      const balance = await getSolBalance(address)
      return NextResponse.json({
        response: `The current SOL balance is ${balance} SOL.`,
        data: { balance, currency: 'SOL' }
      })
    }

    // Handle token holdings queries
    if (queryLower.includes('tokens') || queryLower.includes('holdings')) {
      const tokens = await getTokenHoldings(address)
      return NextResponse.json({
        response: `This wallet holds ${tokens.length} different tokens.`,
        data: { tokenCount: tokens.length, tokens }
      })
    }

    // Handle last transaction queries
    if (queryLower.includes('last transaction') || queryLower.includes('recent transaction')) {
      const lastTx = await getLastTransaction(address)
      if (lastTx && lastTx.blockTime) {
        const timeAgo = Math.floor((Date.now() - lastTx.blockTime) / (1000 * 60 * 60 * 24))
        return NextResponse.json({
          response: `The last transaction was ${timeAgo} days ago. It was a ${lastTx.type} transaction.`,
          data: { lastTransaction: lastTx, daysAgo: timeAgo }
        })
      } else {
        return NextResponse.json({
          response: "No recent transactions found for this wallet.",
          data: { lastTransaction: null }
        })
      }
    }

    // Default response
    return NextResponse.json({
      response: "I can help you analyze this wallet. Try asking about transaction counts, balance, token holdings, or recent activity.",
      data: { suggestion: "Ask specific questions about this wallet's activity" }
    })

  } catch (error) {
    console.error('‚ùå Pattern matching error:', error)
    console.error('Error details:', {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      query,
      address
    })
    return NextResponse.json({
      response: "I encountered an error analyzing this wallet. Please try again.",
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

// Export for use in other parts of the app
export { processTransactionData }